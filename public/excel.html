<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
  <meta name="theme-color" content="#217346">
  <meta name="description" content="NinjaCalc - Powerful spreadsheets with formulas, charts, pivot tables and data analysis">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>NinjaCalc - Spreadsheet</title>
  <link rel="manifest" href="manifest.json">
  <link rel="stylesheet" href="css/styles.css">
  <script src="js/officeninja.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    /* Format Painter */
    #formatPainterBtn.active {
      background: #1a73e8 !important;
      color: white !important;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
    }
    .format-painter-cursor td {
      cursor: crosshair !important;
    }
    .spreadsheet-table {
      border-collapse: collapse;
      table-layout: fixed;
      user-select: none;
    }
    .spreadsheet-table th {
      background: #f1f3f4;
      border: 1px solid #e0e0e0;
      padding: 4px 8px;
      font-weight: 500;
      font-size: 12px;
      min-width: 80px;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .spreadsheet-table th.row-header {
      position: sticky;
      left: 0;
      z-index: 11;
      width: 40px;
      min-width: 40px;
    }
    .spreadsheet-table th.corner {
      position: sticky;
      left: 0;
      top: 0;
      z-index: 12;
    }
    .spreadsheet-table td {
      border: 1px solid #e0e0e0;
      padding: 0;
      font-size: 13px;
      min-width: 80px;
      max-width: 200px;
      height: 24px;
      position: relative;
    }
    .spreadsheet-table td.row-header {
      background: #f1f3f4;
      text-align: center;
      font-weight: 500;
      position: sticky;
      left: 0;
      padding: 4px 8px;
    }
    .cell {
      width: 100%;
      height: 100%;
      border: none;
      padding: 4px 6px;
      font-size: 13px;
      font-family: inherit;
      outline: none;
      box-sizing: border-box;
    }
    .cell:focus {
      background: #e8f0fe;
      outline: 2px solid #1a73e8;
      outline-offset: -2px;
    }
    .cell.selected {
      background: #e8f0fe;
    }
    .cell.formula {
      color: #1a73e8;
    }
    .cell.error {
      color: #d93025;
      background: #fce8e6;
    }
    /* Conditional Formatting Colors */
    .cf-high { background: #34a853 !important; color: white; }
    .cf-medium { background: #fbbc04 !important; }
    .cf-low { background: #ea4335 !important; color: white; }

    /* Formula Range Highlighting */
    .formula-ref-1 { outline: 2px solid #4285f4 !important; background: rgba(66, 133, 244, 0.15) !important; }
    .formula-ref-2 { outline: 2px solid #ea4335 !important; background: rgba(234, 67, 53, 0.15) !important; }
    .formula-ref-3 { outline: 2px solid #34a853 !important; background: rgba(52, 168, 83, 0.15) !important; }
    .formula-ref-4 { outline: 2px solid #fbbc04 !important; background: rgba(251, 188, 4, 0.15) !important; }
    .formula-ref-5 { outline: 2px solid #9334e6 !important; background: rgba(147, 52, 230, 0.15) !important; }
    .formula-ref-6 { outline: 2px solid #00897b !important; background: rgba(0, 137, 123, 0.15) !important; }

    /* Row/Column Highlighter */
    .row-highlight-active .spreadsheet-table tr.row-highlighted td {
      background-color: rgba(66, 133, 244, 0.08) !important;
    }
    .row-highlight-active .spreadsheet-table td.col-highlighted {
      background-color: rgba(66, 133, 244, 0.08) !important;
    }
    .row-highlight-active .spreadsheet-table tr.row-highlighted td.col-highlighted {
      background-color: rgba(66, 133, 244, 0.18) !important;
    }
    .row-highlight-active .spreadsheet-table tr.row-highlighted td.row-header,
    .row-highlight-active .spreadsheet-table th.col-highlighted {
      background-color: rgba(66, 133, 244, 0.25) !important;
      color: #1a73e8;
    }
    body.dark-mode .row-highlight-active .spreadsheet-table tr.row-highlighted td {
      background-color: rgba(138, 180, 248, 0.1) !important;
    }
    body.dark-mode .row-highlight-active .spreadsheet-table td.col-highlighted {
      background-color: rgba(138, 180, 248, 0.1) !important;
    }
    body.dark-mode .row-highlight-active .spreadsheet-table tr.row-highlighted td.col-highlighted {
      background-color: rgba(138, 180, 248, 0.2) !important;
    }

    /* Mini Chart Tooltip */
    .mini-chart-tooltip {
      position: fixed;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      padding: 12px;
      z-index: 10002;
      display: none;
      min-width: 180px;
      max-width: 280px;
      animation: miniChartIn 0.15s ease-out;
    }
    @keyframes miniChartIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    .mini-chart-tooltip.visible { display: block; }
    .mini-chart-tooltip-header {
      font-size: 0.75rem;
      color: #5f6368;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .mini-chart-tooltip-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #202124;
      margin-bottom: 8px;
    }
    .mini-chart-tooltip-chart {
      background: #f8f9fa;
      border-radius: 4px;
      padding: 8px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      height: 60px;
      gap: 3px;
    }
    .mini-chart-bar {
      background: linear-gradient(180deg, #4285f4, #669df6);
      border-radius: 2px 2px 0 0;
      min-width: 8px;
      transition: height 0.2s ease;
    }
    .mini-chart-bar.current {
      background: linear-gradient(180deg, #1a73e8, #4285f4);
      box-shadow: 0 0 4px rgba(26, 115, 232, 0.4);
    }
    .mini-chart-bar.negative {
      background: linear-gradient(180deg, #ea4335, #f28b82);
    }
    .mini-chart-tooltip-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
      margin-top: 8px;
      font-size: 0.7rem;
      color: #5f6368;
    }
    .mini-chart-tooltip-stats span {
      padding: 2px 4px;
      background: #f1f3f4;
      border-radius: 3px;
    }
    body.dark-mode .mini-chart-tooltip {
      background: #292a2d;
      border-color: #3c4043;
    }
    body.dark-mode .mini-chart-tooltip-value {
      color: #e8eaed;
    }
    body.dark-mode .mini-chart-tooltip-header {
      color: #9aa0a6;
    }
    body.dark-mode .mini-chart-tooltip-chart {
      background: #202124;
    }
    body.dark-mode .mini-chart-tooltip-stats span {
      background: #3c4043;
      color: #9aa0a6;
    }

    /* Cell Notes */
    .cell-has-note {
      position: relative;
    }
    .cell-has-note::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-top: 8px solid #fbbc04;
    }
    .cell-note-tooltip {
      position: fixed;
      background: #fffde7;
      border: 1px solid #fbc02d;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(251, 192, 45, 0.3);
      padding: 10px 14px;
      max-width: 280px;
      min-width: 150px;
      z-index: 10002;
      display: none;
      font-size: 0.85rem;
      line-height: 1.4;
      animation: noteIn 0.15s ease-out;
    }
    @keyframes noteIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .cell-note-tooltip.visible { display: block; }
    .cell-note-tooltip-header {
      font-weight: 600;
      color: #f57f17;
      margin-bottom: 6px;
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .cell-note-tooltip-content {
      color: #5d4037;
      white-space: pre-wrap;
    }
    .cell-note-tooltip-footer {
      margin-top: 8px;
      font-size: 0.7rem;
      color: #8d6e63;
      border-top: 1px solid #ffe082;
      padding-top: 6px;
    }
    body.dark-mode .cell-note-tooltip {
      background: #3e2723;
      border-color: #ffb300;
    }
    body.dark-mode .cell-note-tooltip-header {
      color: #ffca28;
    }
    body.dark-mode .cell-note-tooltip-content {
      color: #ffe0b2;
    }
    body.dark-mode .cell-note-tooltip-footer {
      color: #bcaaa4;
      border-color: #5d4037;
    }

    /* Error Tooltip */
    .error-tooltip {
      position: fixed;
      background: #fff;
      border: 1px solid #d93025;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(217, 48, 37, 0.2);
      padding: 12px 16px;
      max-width: 320px;
      z-index: 10001;
      display: none;
      animation: errorTooltipIn 0.15s ease-out;
    }
    @keyframes errorTooltipIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .error-tooltip.visible { display: block; }
    .error-tooltip-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-weight: 600;
      color: #d93025;
    }
    .error-tooltip-icon {
      width: 24px;
      height: 24px;
      background: #fce8e6;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .error-tooltip-desc {
      font-size: 13px;
      color: #555;
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .error-tooltip-fix {
      font-size: 12px;
      color: #1a73e8;
      background: #e8f0fe;
      padding: 8px 10px;
      border-radius: 4px;
    }
    .error-tooltip-fix strong { color: #174ea6; }
    body.dark-mode .error-tooltip { background: #2d2d2d; border-color: #f28b82; }
    body.dark-mode .error-tooltip-header { color: #f28b82; }
    body.dark-mode .error-tooltip-icon { background: rgba(242, 139, 130, 0.2); }
    body.dark-mode .error-tooltip-desc { color: #bbb; }
    body.dark-mode .error-tooltip-fix { background: rgba(138, 180, 248, 0.15); color: #8ab4f8; }
    body.dark-mode .error-tooltip-fix strong { color: #aecbfa; }

    .chart-modal {
      width: 600px;
      height: 400px;
    }
    .pivot-modal {
      width: 800px;
      max-height: 80vh;
    }
    .macro-editor {
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }
    .filter-active {
      background: #e8f0fe !important;
    }
    .filter-icon {
      cursor: pointer;
      opacity: 0.5;
    }
    .filter-icon:hover, .filter-icon.active {
      opacity: 1;
    }
    .sheet-tabs { display: flex; background: #f1f3f4; border-top: 1px solid #e0e0e0; padding: 0.25rem 0.5rem; gap: 2px; }
    .sheet-tab { padding: 0.4rem 1rem; background: #e8e8e8; border: 1px solid #ccc; border-bottom: none; border-radius: 4px 4px 0 0; cursor: pointer; font-size: 0.85rem; }
    .sheet-tab.active { background: white; border-bottom: 1px solid white; margin-bottom: -1px; }
    .sheet-tab-add { padding: 0.4rem 0.75rem; cursor: pointer; font-size: 1rem; }
    .find-bar { background: #fff3cd; padding: 0.5rem 1rem; display: none; align-items: center; gap: 0.5rem; border-bottom: 1px solid #ffc107; }
    .find-bar input { padding: 0.4rem; border: 1px solid #ccc; border-radius: 4px; width: 200px; }
    .zoom-controls { display: flex; align-items: center; gap: 0.5rem; margin-left: auto; }
    .zoom-btn { padding: 0.25rem 0.5rem; cursor: pointer; }
    .zoom-display { min-width: 50px; text-align: center; font-size: 0.85rem; }
    .freeze-indicator { background: #4285f4; position: sticky; z-index: 20; }
    /* Print Area */
    .print-area-cell {
      outline: 2px dashed #4285f4 !important;
      background: rgba(66, 133, 244, 0.05) !important;
    }
    /* Split View */
    .split-view-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .split-view-container.horizontal {
      flex-direction: row;
    }
    .split-pane {
      flex: 1;
      overflow: auto;
      border: 1px solid #1a73e8;
    }
    .split-divider {
      background: #1a73e8;
      cursor: ns-resize;
      height: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .split-view-container.horizontal .split-divider {
      width: 6px;
      height: auto;
      cursor: ew-resize;
    }
    .split-divider::after {
      content: '‚ãØ';
      color: white;
      font-size: 10px;
    }
    .split-view-container.horizontal .split-divider::after {
      content: '‚ãÆ';
    }
    .has-comment { position: relative; }
    .has-comment::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-top: 8px solid #ea4335;
    }
    /* Dark Mode */
    body.dark-mode {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    body.dark-mode .app-container {
      background: #1e1e1e;
    }
    body.dark-mode .app-header {
      background: #252526;
      border-color: #3c3c3c;
    }
    body.dark-mode .ribbon {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .ribbon-tab {
      color: #cccccc;
    }
    body.dark-mode .ribbon-tab.active {
      background: #3c3c3c;
      color: #ffffff;
    }
    body.dark-mode .toolbar {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .toolbar-btn {
      background: #3c3c3c;
      color: #cccccc;
      border-color: #505050;
    }
    body.dark-mode .toolbar-btn:hover {
      background: #505050;
      color: #ffffff;
    }
    body.dark-mode .toolbar-select {
      background: #3c3c3c;
      color: #cccccc;
      border-color: #505050;
    }
    body.dark-mode .spreadsheet-container {
      background: #1e1e1e;
    }
    body.dark-mode .spreadsheet-table th {
      background: #2d2d2d;
      border-color: #3c3c3c;
      color: #cccccc;
    }
    body.dark-mode .spreadsheet-table td {
      background: #1e1e1e;
      border-color: #3c3c3c;
      color: #e0e0e0;
    }
    body.dark-mode .spreadsheet-table td.selected,
    body.dark-mode .spreadsheet-table td.in-selection {
      background: #264f78 !important;
    }
    body.dark-mode .cell-input {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    body.dark-mode .formula-bar {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .formula-bar input {
      background: #1e1e1e;
      color: #e0e0e0;
      border-color: #3c3c3c;
    }
    body.dark-mode .sheet-tabs {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .sheet-tab {
      background: #3c3c3c;
      color: #cccccc;
      border-color: #505050;
    }
    body.dark-mode .sheet-tab.active {
      background: #1e1e1e;
      color: #ffffff;
    }
    body.dark-mode .status-bar {
      background: #007acc;
      color: #ffffff;
    }
    body.dark-mode .dropdown-menu {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .dropdown-item {
      color: #cccccc;
    }
    body.dark-mode .dropdown-item:hover {
      background: #3c3c3c;
    }
    body.dark-mode .file-name {
      background: #3c3c3c;
      color: #cccccc;
      border-color: #505050;
    }
    body.dark-mode .modal-content {
      background: #2d2d2d;
      color: #e0e0e0;
    }
    body.dark-mode .modal-content input,
    body.dark-mode .modal-content select,
    body.dark-mode .modal-content textarea {
      background: #3c3c3c;
      color: #e0e0e0;
      border-color: #505050;
    }
    body.dark-mode .find-bar {
      background: #3c3c3c;
      border-color: #505050;
    }
    body.dark-mode .toast {
      background: #3c3c3c;
      color: #e0e0e0;
    }
    /* Quick Analysis Styles */
    .qa-tab {
      padding: 0.5rem 1rem;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 0.85rem;
      color: #666;
      border-bottom: 2px solid transparent;
    }
    .qa-tab:hover { color: #1a73e8; }
    .qa-tab.active {
      color: #1a73e8;
      border-bottom-color: #1a73e8;
    }
    .qa-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    .qa-option:hover {
      border-color: #1a73e8;
      background: #e8f0fe;
    }
    .qa-option span {
      font-size: 0.7rem;
      margin-top: 0.25rem;
      color: #666;
    }
    body.dark-mode .qa-tab { color: #999; }
    body.dark-mode .qa-tab.active { color: #4da3ff; border-bottom-color: #4da3ff; }
    body.dark-mode .qa-option {
      background: #3c3c3c;
      border-color: #505050;
      color: #ccc;
    }
    body.dark-mode .qa-option:hover {
      background: #505050;
      border-color: #4da3ff;
    }
    /* Watch Window Styles */
    .watch-window {
      position: fixed;
      top: 200px;
      right: 20px;
      width: 350px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 1000;
      display: none;
    }
    .watch-window.visible { display: block; }
    .watch-window-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f1f3f4;
      border-bottom: 1px solid #ddd;
      border-radius: 8px 8px 0 0;
      cursor: move;
    }
    .watch-window-header h4 { margin: 0; font-size: 0.9rem; }
    .watch-window-close {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: #666;
    }
    .watch-window-body {
      max-height: 300px;
      overflow-y: auto;
    }
    .watch-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    .watch-table th {
      background: #f8f9fa;
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid #ddd;
      font-weight: 500;
    }
    .watch-table td {
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }
    .watch-table tr:hover { background: #f5f5f5; }
    .watch-cell-ref {
      font-weight: 600;
      color: #1a73e8;
      cursor: pointer;
    }
    .watch-cell-ref:hover { text-decoration: underline; }
    .watch-value { font-family: monospace; }
    .watch-formula { font-size: 0.75rem; color: #666; font-style: italic; }
    .watch-remove {
      background: none;
      border: none;
      color: #d93025;
      cursor: pointer;
      font-size: 1rem;
    }
    .watch-empty {
      padding: 2rem;
      text-align: center;
      color: #999;
      font-style: italic;
    }
    body.dark-mode .watch-window {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .watch-window-header {
      background: #3c3c3c;
      border-color: #505050;
    }
    body.dark-mode .watch-window-close { color: #ccc; }
    body.dark-mode .watch-table th {
      background: #3c3c3c;
      border-color: #505050;
      color: #ccc;
    }
    body.dark-mode .watch-table td { border-color: #3c3c3c; color: #e0e0e0; }
    body.dark-mode .watch-table tr:hover { background: #3c3c3c; }
    body.dark-mode .watch-cell-ref { color: #4da3ff; }
    body.dark-mode .watch-formula { color: #999; }
    /* Keyboard Shortcuts Styles */
    .shortcuts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
    }
    .shortcuts-section h4 {
      margin: 0 0 0.75rem 0;
      color: #1a73e8;
      font-size: 0.95rem;
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 0.5rem;
    }
    .shortcut-item {
      display: flex;
      align-items: center;
      padding: 0.4rem 0;
      font-size: 0.85rem;
    }
    .shortcut-item kbd {
      background: #f1f3f4;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.2rem 0.5rem;
      font-family: monospace;
      font-size: 0.8rem;
      margin: 0 0.25rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .shortcut-item span {
      margin-left: auto;
      color: #666;
    }
    body.dark-mode .shortcuts-section h4 {
      color: #4da3ff;
      border-color: #3c3c3c;
    }
    body.dark-mode .shortcut-item kbd {
      background: #3c3c3c;
      border-color: #505050;
      color: #ccc;
    }
    body.dark-mode .shortcut-item span { color: #999; }
    /* Submenu styles */
    .submenu-parent { position: relative; }
    .submenu {
      display: none;
      position: absolute;
      left: 100%;
      top: 0;
      min-width: 220px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1001;
    }
    .submenu.show { display: block; }
    .submenu-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .submenu-item:hover { background: #f0f0f0; }
    .submenu-item .file-date { font-size: 0.75rem; color: #888; }
    .submenu-empty { padding: 12px; color: #888; font-style: italic; text-align: center; }
    body.dark-mode .submenu { background: #2d2d2d; border-color: #444; }
    body.dark-mode .submenu-item:hover { background: #3c3c3c; }
    /* Quick Access Toolbar */
    .quick-access-toolbar {
      background: #f0f0f0;
      padding: 2px 8px;
      display: flex;
      align-items: center;
      gap: 2px;
      border-bottom: 1px solid #ddd;
      font-size: 0.75rem;
    }
    .quick-access-toolbar .qat-btn {
      padding: 4px 8px;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 3px;
      font-size: 14px;
      opacity: 0.8;
    }
    .quick-access-toolbar .qat-btn:hover {
      background: #e0e0e0;
      opacity: 1;
    }
    .quick-access-toolbar .qat-separator {
      width: 1px;
      height: 16px;
      background: #ccc;
      margin: 0 4px;
    }
    .quick-access-toolbar .qat-customize {
      margin-left: auto;
      font-size: 10px;
      color: #666;
    }
    body.dark-mode .quick-access-toolbar {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .quick-access-toolbar .qat-btn:hover {
      background: #3c3c3c;
    }
    .qat-modal-items {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.5rem;
    }
    .qat-modal-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 4px;
    }
    .qat-modal-item:hover {
      background: #e8f0fe;
    }
    /* Context Menu Styles */
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      min-width: 200px;
      z-index: 50000;
      display: none;
      padding: 6px 0;
      animation: contextMenuIn 0.12s ease-out;
    }
    @keyframes contextMenuIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    .context-menu.visible { display: block; }
    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
      transition: background 0.1s;
    }
    .context-menu-item:hover { background: #e8f0fe; }
    .context-menu-item.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    .context-menu-item-icon {
      width: 20px;
      text-align: center;
    }
    .context-menu-item-shortcut {
      margin-left: auto;
      color: #888;
      font-size: 11px;
    }
    .context-menu-divider {
      height: 1px;
      background: #e0e0e0;
      margin: 6px 0;
    }
    .context-menu-submenu {
      position: relative;
    }
    .context-menu-submenu::after {
      content: '‚ñ∏';
      margin-left: auto;
      color: #666;
    }
    body.dark-mode .context-menu {
      background: #2d2d2d;
      border-color: #3c3c3c;
    }
    body.dark-mode .context-menu-item:hover {
      background: #3c3c3c;
    }
    body.dark-mode .context-menu-item {
      color: #e0e0e0;
    }
    body.dark-mode .context-menu-divider {
      background: #3c3c3c;
    }
    /* Drag & Drop Overlay */
    .drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(26, 115, 232, 0.9);
      z-index: 100000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 1rem;
    }
    .drop-overlay.visible { display: flex; }
    .drop-overlay-icon {
      font-size: 80px;
      animation: dropBounce 0.5s ease infinite alternate;
    }
    @keyframes dropBounce {
      from { transform: translateY(0); }
      to { transform: translateY(-10px); }
    }
    .drop-overlay-text { font-size: 24px; color: white; font-weight: 500; }
    .drop-overlay-subtext { font-size: 14px; color: rgba(255,255,255,0.8); }
    /* Auto-save indicator */
    .autosave-indicator {
      position: fixed;
      bottom: 40px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 10000;
    }
    .autosave-indicator.visible { display: flex; }
    .autosave-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Global Search Spotlight */
    .spotlight-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 100000;
      display: none;
      justify-content: center;
      padding-top: 15vh;
    }
    .spotlight-overlay.visible { display: flex; }
    .spotlight-container {
      width: 600px;
      max-width: 90vw;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.3);
      overflow: hidden;
      animation: spotlightIn 0.2s ease-out;
      max-height: 60vh;
      display: flex;
      flex-direction: column;
    }
    @keyframes spotlightIn {
      from { opacity: 0; transform: scale(0.95) translateY(-10px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }
    .spotlight-input-wrapper {
      padding: 16px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .spotlight-search-icon { font-size: 20px; color: #666; }
    .spotlight-input {
      flex: 1;
      border: none;
      outline: none;
      font-size: 18px;
      background: transparent;
    }
    .spotlight-results {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }
    .spotlight-section-title {
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      color: #666;
      letter-spacing: 0.5px;
    }
    .spotlight-item {
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      transition: background 0.1s;
    }
    .spotlight-item:hover, .spotlight-item.selected { background: #e8f0fe; }
    .spotlight-item-icon { font-size: 18px; width: 24px; text-align: center; }
    .spotlight-item-content { flex: 1; }
    .spotlight-item-title { font-size: 14px; font-weight: 500; }
    .spotlight-item-desc { font-size: 12px; color: #666; }
    .spotlight-item-shortcut {
      font-size: 11px;
      color: #888;
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 3px;
    }
    .spotlight-footer {
      padding: 10px 16px;
      background: #f8f9fa;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: #666;
    }
    body.dark-mode .spotlight-container { background: #2d2d2d; }
    body.dark-mode .spotlight-input-wrapper { border-color: #444; }
    body.dark-mode .spotlight-input { color: #e0e0e0; }
    body.dark-mode .spotlight-section-title { color: #888; }
    body.dark-mode .spotlight-item:hover, body.dark-mode .spotlight-item.selected { background: #3c3c3c; }
    body.dark-mode .spotlight-item-desc { color: #999; }
    body.dark-mode .spotlight-footer { background: #252525; border-color: #444; }
    /* Floating Action Button */
    .fab-container {
      position: fixed;
      bottom: 80px;
      right: 30px;
      z-index: 9999;
    }
    .fab-main {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: #1a73e8;
      color: white;
      border: none;
      font-size: 28px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(26, 115, 232, 0.4);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .fab-main:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(26, 115, 232, 0.5);
    }
    .fab-main.active {
      transform: rotate(45deg);
      background: #d93025;
    }
    .fab-menu {
      position: absolute;
      bottom: 70px;
      right: 0;
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    .fab-menu.visible { display: flex; }
    .fab-item {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: flex-end;
      animation: fabItemIn 0.2s ease-out backwards;
    }
    .fab-item:nth-child(1) { animation-delay: 0.05s; }
    .fab-item:nth-child(2) { animation-delay: 0.1s; }
    .fab-item:nth-child(3) { animation-delay: 0.15s; }
    .fab-item:nth-child(4) { animation-delay: 0.2s; }
    @keyframes fabItemIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .fab-item-label {
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 13px;
      white-space: nowrap;
    }
    .fab-item-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: white;
      border: none;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: transform 0.2s;
    }
    .fab-item-btn:hover { transform: scale(1.1); }
    /* Interactive Status Bar */
    .status-bar-item {
      cursor: pointer;
      padding: 2px 8px;
      border-radius: 4px;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .status-bar-item:hover {
      background: rgba(26, 115, 232, 0.1);
      color: #1a73e8;
    }
    .status-bar-item:active { transform: scale(0.98); }
    .status-bar-item .status-icon { font-size: 12px; }
    body.dark-mode .status-bar-item:hover {
      background: rgba(138, 180, 248, 0.15);
      color: #8ab4f8;
    }
    /* Calculation Mode Popup */
    .calc-mode-popup {
      position: fixed;
      bottom: 40px;
      right: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 12px;
      z-index: 10001;
      display: none;
      flex-direction: column;
      gap: 8px;
      min-width: 180px;
      animation: popupSlideUp 0.2s ease-out;
    }
    .calc-mode-popup.visible { display: flex; }
    @keyframes popupSlideUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .calc-mode-popup-header {
      font-weight: 600;
      font-size: 14px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .calc-mode-option {
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background 0.15s;
    }
    .calc-mode-option:hover { background: #f0f0f0; }
    .calc-mode-option.active { background: #e8f0fe; color: #1a73e8; }
    body.dark-mode .calc-mode-popup { background: #2d2d2d; color: #e0e0e0; }
    body.dark-mode .calc-mode-popup-header { border-color: #444; }
    body.dark-mode .calc-mode-option:hover { background: #3c3c3c; }
    body.dark-mode .calc-mode-option.active { background: rgba(138, 180, 248, 0.15); color: #8ab4f8; }
    /* Zoom Popup */
    .zoom-popup {
      position: fixed;
      bottom: 40px;
      right: 200px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 16px;
      z-index: 10001;
      display: none;
      flex-direction: column;
      gap: 12px;
      min-width: 220px;
      animation: popupSlideUp 0.2s ease-out;
    }
    .zoom-popup.visible { display: flex; }
    .zoom-popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 14px;
    }
    .zoom-popup-close {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 16px;
      color: #666;
    }
    .zoom-slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .zoom-slider {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: #e0e0e0;
      border-radius: 2px;
      outline: none;
    }
    .zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #1a73e8;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .zoom-presets {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .zoom-preset-btn {
      padding: 4px 10px;
      border: 1px solid #ddd;
      background: #f8f9fa;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }
    .zoom-preset-btn:hover { background: #e8f0fe; border-color: #1a73e8; color: #1a73e8; }
    .zoom-preset-btn.active { background: #1a73e8; color: white; border-color: #1a73e8; }
    body.dark-mode .zoom-popup { background: #2d2d2d; color: #e0e0e0; }
    body.dark-mode .zoom-slider { background: #444; }
    body.dark-mode .zoom-preset-btn { background: #3c3c3c; border-color: #555; color: #e0e0e0; }
    body.dark-mode .zoom-preset-btn:hover { background: #4a4a4a; border-color: #8ab4f8; color: #8ab4f8; }

    /* Formula Autocomplete */
    .formula-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      max-height: 300px;
      overflow-y: auto;
      z-index: 10000;
      display: none;
    }
    .formula-autocomplete.visible { display: block; }
    .formula-autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.15s;
    }
    .formula-autocomplete-item:last-child { border-bottom: none; }
    .formula-autocomplete-item:hover,
    .formula-autocomplete-item.selected { background: #e8f5e9; }
    .formula-autocomplete-item.selected { background: #c8e6c9; }
    .formula-icon {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #0f9d58, #34a853);
      color: white;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 12px;
      flex-shrink: 0;
    }
    .formula-icon.math { background: linear-gradient(135deg, #1a73e8, #4285f4); }
    .formula-icon.text { background: linear-gradient(135deg, #ea4335, #f28b82); }
    .formula-icon.logic { background: linear-gradient(135deg, #fbbc04, #fdd663); color: #333; }
    .formula-icon.lookup { background: linear-gradient(135deg, #9334e6, #af5cf7); }
    .formula-icon.date { background: linear-gradient(135deg, #00897b, #4db6ac); }
    .formula-icon.stat { background: linear-gradient(135deg, #f57c00, #ffb74d); }
    .formula-info {
      flex: 1;
      min-width: 0;
    }
    .formula-name {
      font-weight: 600;
      font-size: 13px;
      color: #333;
    }
    .formula-syntax {
      font-size: 11px;
      color: #666;
      font-family: 'Consolas', monospace;
      margin-top: 2px;
    }
    .formula-desc {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .formula-category {
      font-size: 10px;
      color: #999;
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 4px;
      flex-shrink: 0;
    }
    body.dark-mode .formula-autocomplete { background: #2d2d2d; border-color: #444; }
    body.dark-mode .formula-autocomplete-item { border-color: #3c3c3c; }
    body.dark-mode .formula-autocomplete-item:hover,
    body.dark-mode .formula-autocomplete-item.selected { background: rgba(15, 157, 88, 0.2); }
    body.dark-mode .formula-name { color: #e0e0e0; }
    body.dark-mode .formula-syntax { color: #aaa; }
    body.dark-mode .formula-desc { color: #888; }
    body.dark-mode .formula-category { background: #3c3c3c; color: #aaa; }

    /* Welcome Modal */
    .welcome-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 100001;
      display: none;
      justify-content: center;
      align-items: center;
    }
    .welcome-modal.visible { display: flex; }
    .welcome-container {
      width: 550px;
      max-width: 90vw;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
      animation: welcomeSlide 0.4s ease;
    }
    @keyframes welcomeSlide {
      from { opacity: 0; transform: scale(0.9) translateY(20px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }
    .welcome-header {
      background: linear-gradient(135deg, #0f9d58, #34a853);
      color: white;
      padding: 30px;
      text-align: center;
    }
    .welcome-header h2 { margin: 0 0 8px 0; font-size: 28px; }
    .welcome-header p { margin: 0; opacity: 0.9; font-size: 14px; }
    .welcome-tips { padding: 24px; }
    .welcome-tip {
      display: flex;
      align-items: flex-start;
      gap: 16px;
      padding: 14px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    .welcome-tip:last-child { border-bottom: none; }
    .welcome-tip-icon {
      width: 44px;
      height: 44px;
      background: #e6f4ea;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }
    .welcome-tip-content h4 { margin: 0 0 4px 0; font-size: 15px; font-weight: 600; }
    .welcome-tip-content p { margin: 0; font-size: 13px; color: #5f6368; line-height: 1.4; }
    .welcome-tip-content kbd {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #ddd;
    }
    .welcome-footer {
      padding: 16px 24px;
      background: #f8f9fa;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .welcome-checkbox { display: flex; align-items: center; gap: 8px; font-size: 13px; color: #5f6368; cursor: pointer; }
    .welcome-btn {
      background: #0f9d58;
      color: white;
      border: none;
      padding: 10px 24px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
    }
    .welcome-btn:hover { background: #0b8043; }
    body.dark-mode .welcome-container { background: #2d2d2d; }
    body.dark-mode .welcome-tip { border-color: #3c3c3c; }
    body.dark-mode .welcome-tip-icon { background: #1e3a2f; }
    body.dark-mode .welcome-tip-content h4 { color: #e0e0e0; }
    body.dark-mode .welcome-footer { background: #252525; }

    /* Quick Formula Buttons */
    .quick-formula-bar {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20px;
      background: white;
      border: 1px solid #dadce0;
      border-radius: 12px;
      padding: 8px 12px;
      display: none;
      gap: 4px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      align-items: center;
    }
    .quick-formula-bar.visible {
      display: flex;
    }
    .quick-formula-btn {
      padding: 6px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }
    .quick-formula-btn:hover {
      background: #f1f3f4;
      border-color: #0f9d58;
      color: #0f9d58;
    }
    .quick-formula-btn.primary {
      background: #0f9d58;
      color: white;
      border-color: #0f9d58;
    }
    .quick-formula-btn.primary:hover {
      background: #0b8043;
    }
    .quick-formula-btn-icon {
      font-size: 1rem;
    }
    .quick-formula-divider {
      width: 1px;
      height: 24px;
      background: #e0e0e0;
      margin: 0 4px;
    }
    .quick-formula-result {
      padding: 4px 10px;
      background: #e8f5e9;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      color: #0f9d58;
      min-width: 60px;
      text-align: center;
    }
    .quick-formula-result.error {
      background: #fce8e6;
      color: #d93025;
    }
    body.dark-mode .quick-formula-bar {
      background: #292a2d;
      border-color: #3c4043;
    }
    body.dark-mode .quick-formula-btn {
      background: #292a2d;
      border-color: #3c4043;
      color: #e8eaed;
    }
    body.dark-mode .quick-formula-btn:hover {
      background: #3c4043;
      color: #81c995;
    }
    body.dark-mode .quick-formula-result {
      background: #1e3a2f;
      color: #81c995;
    }

    /* Formula Palette */
    .formula-palette {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.25);
      width: 500px;
      max-height: 70vh;
      z-index: 100003;
      display: none;
      overflow: hidden;
    }
    .formula-palette.visible {
      display: block;
    }
    .formula-palette-header {
      background: linear-gradient(135deg, #0f9d58, #34a853);
      color: white;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .formula-palette-header h3 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    .formula-palette-close {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .formula-palette-close:hover {
      background: rgba(255,255,255,0.3);
    }
    .formula-palette-search {
      padding: 12px 16px;
      border-bottom: 1px solid #e0e0e0;
    }
    .formula-palette-search input {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid #dadce0;
      border-radius: 8px;
      font-size: 0.95rem;
      outline: none;
    }
    .formula-palette-search input:focus {
      border-color: #0f9d58;
      box-shadow: 0 0 0 2px rgba(15, 157, 88, 0.2);
    }
    .formula-palette-body {
      padding: 0;
      max-height: 50vh;
      overflow-y: auto;
    }
    .formula-category {
      padding: 12px 16px;
      border-bottom: 1px solid #f0f0f0;
    }
    .formula-category-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: #5f6368;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .formula-list {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }
    .formula-item {
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .formula-item:hover {
      background: #e8f5e9;
      border-color: #0f9d58;
    }
    .formula-item-name {
      font-weight: 600;
      font-size: 0.85rem;
      color: #0f9d58;
    }
    .formula-item-desc {
      font-size: 0.7rem;
      color: #5f6368;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    body.dark-mode .formula-palette {
      background: #292a2d;
    }
    body.dark-mode .formula-palette-search {
      border-color: #3c4043;
    }
    body.dark-mode .formula-palette-search input {
      background: #202124;
      border-color: #3c4043;
      color: #e8eaed;
    }
    body.dark-mode .formula-palette-search input:focus {
      border-color: #81c995;
    }
    body.dark-mode .formula-category {
      border-color: #3c4043;
    }
    body.dark-mode .formula-category-title {
      color: #9aa0a6;
    }
    body.dark-mode .formula-item {
      border-color: #3c4043;
    }
    body.dark-mode .formula-item:hover {
      background: #1e3a2f;
      border-color: #81c995;
    }
    body.dark-mode .formula-item-name {
      color: #81c995;
    }
    body.dark-mode .formula-item-desc {
      color: #9aa0a6;
    }

    /* Formula Helper */
    .formula-helper-popup {
      position: fixed;
      background: white;
      border: 1px solid #dadce0;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      padding: 12px;
      z-index: 10003;
      display: none;
      max-width: 350px;
      font-size: 0.85rem;
    }
    .formula-helper-popup.visible {
      display: block;
    }
    .formula-helper-title {
      font-weight: 600;
      color: #0f9d58;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .formula-helper-syntax {
      background: #f8f9fa;
      padding: 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.8rem;
      margin-bottom: 8px;
      color: #202124;
    }
    .formula-helper-desc {
      color: #5f6368;
      line-height: 1.4;
    }
    .formula-helper-example {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
    }
    .formula-helper-example-title {
      font-weight: 500;
      color: #5f6368;
      font-size: 0.75rem;
      margin-bottom: 4px;
    }
    .formula-helper-example-code {
      font-family: monospace;
      font-size: 0.8rem;
      color: #1a73e8;
    }
    body.dark-mode .formula-helper-popup {
      background: #292a2d;
      border-color: #3c4043;
    }
    body.dark-mode .formula-helper-title {
      color: #81c995;
    }
    body.dark-mode .formula-helper-syntax {
      background: #202124;
      color: #e8eaed;
    }
    body.dark-mode .formula-helper-desc {
      color: #9aa0a6;
    }
    body.dark-mode .formula-helper-example {
      border-color: #3c4043;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Quick Access Toolbar -->
    <div class="quick-access-toolbar" id="quickAccessToolbar">
      <button class="qat-btn" onclick="saveSpreadsheet()" title="Save (Ctrl+S)">üíæ</button>
      <button class="qat-btn" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü∂</button>
      <button class="qat-btn" onclick="redo()" title="Redo (Ctrl+Y)">‚Ü∑</button>
      <span class="qat-separator"></span>
      <button class="qat-btn" onclick="exportPDF()" title="Export PDF">üìÑ</button>
      <button class="qat-btn" onclick="window.print()" title="Print">üñ®Ô∏è</button>
      <button class="qat-btn qat-customize" onclick="showQATCustomization()" title="Customize Quick Access Toolbar">‚ñº Customize</button>
    </div>

    <!-- Header -->
    <div class="app-header">
      <a href="index.html" class="app-logo">
        <div class="app-logo-icon excel">X</div>
        <span class="app-title">NinjaCalc</span>
      </a>
      <input type="text" class="file-name" id="fileName" value="Untitled Spreadsheet">
      <div class="header-actions">
        <div class="dropdown">
          <button class="btn btn-secondary" onclick="toggleFileMenu()">üìÅ File ‚ñæ</button>
          <div class="dropdown-menu" id="fileMenu">
            <div class="dropdown-item" onclick="newSpreadsheet()">üìÑ New</div>
            <div class="dropdown-item" onclick="showOpenDialog()">üìÇ Open...</div>
            <div class="dropdown-item" onclick="saveSpreadsheet()">üíæ Save</div>
            <div class="dropdown-item" onclick="saveSpreadsheetAs()">üíæ Save As...</div>
            <div class="dropdown-divider"></div>
            <div class="dropdown-item submenu-parent" onclick="toggleRecentFiles(event)">
              üïí Recent Files ‚ñ∏
              <div class="submenu" id="recentFilesMenu"></div>
            </div>
            <div class="dropdown-divider"></div>
            <div class="dropdown-item" onclick="exportToFile()">üì§ Export as File</div>
            <div class="dropdown-item" onclick="importFromFile()">üì• Import from File</div>
            <div class="dropdown-divider"></div>
            <div class="dropdown-item" onclick="importXlsx()">üìä Import XLSX</div>
            <div class="dropdown-item" onclick="exportXlsx()">üìä Export XLSX</div>
            <div class="dropdown-item" onclick="exportHTML()">üåê Export HTML</div>
          </div>
        </div>
        <button class="btn btn-secondary" onclick="undo()" title="Undo (Ctrl+Z)" id="undoBtn">‚Ü∂ Undo</button>
        <button class="btn btn-secondary" onclick="redo()" title="Redo (Ctrl+Y)" id="redoBtn">‚Ü∑ Redo</button>
        <button class="btn btn-secondary" onclick="showFindBar()">üîç Find</button>
        <button class="btn btn-secondary" onclick="showRecentSpreadsheets()">üìÇ Recent</button>
        <button class="btn btn-secondary" onclick="showChartModal()">üìä Chart</button>
        <button class="btn btn-secondary" onclick="showPivotModal()">üìã Pivot Table</button>
        <button class="btn btn-secondary" onclick="showMacroModal()">‚ö° Macros</button>
        <button class="btn btn-primary" onclick="exportCSV()">Export CSV</button>
        <div class="zoom-controls">
          <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
          <span class="zoom-display" id="zoomLevel">100%</span>
          <button class="zoom-btn" onclick="zoomIn()">+</button>
        </div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tab-container">
      <button class="tab active" data-tab="home">Home</button>
      <button class="tab" data-tab="formulas">Formulas</button>
      <button class="tab" data-tab="data">Data</button>
      <button class="tab" data-tab="view">View</button>
    </div>

    <!-- Toolbar -->
    <div class="toolbar" id="homeToolbar">
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="formatCell('bold')" title="Bold"><b>B</b></button>
        <button class="toolbar-btn" onclick="formatCell('italic')" title="Italic"><i>I</i></button>
        <button class="toolbar-btn" onclick="formatCell('underline')" title="Underline"><u>U</u></button>
        <button class="toolbar-btn" onclick="toggleFormatPainter()" id="formatPainterBtn" title="Format Painter">üñåÔ∏è</button>
      </div>
      <div class="toolbar-group">
        <input type="color" class="color-picker-btn" id="cellTextColor" value="#000000" onchange="applyCellColor('color', this.value)" title="Text Color">
        <input type="color" class="color-picker-btn" id="cellBgColor" value="#ffffff" onchange="applyCellColor('background', this.value)" title="Fill Color">
      </div>
      <div class="toolbar-group">
        <select class="toolbar-select" id="numberFormat" onchange="applyNumberFormat(this.value)" title="Number Format" style="width: 100px;">
          <option value="general">General</option>
          <option value="number">Number</option>
          <option value="currency">$ Currency</option>
          <option value="currency-euro">‚Ç¨ Euro</option>
          <option value="currency-pound">¬£ Pound</option>
          <option value="accounting">Accounting</option>
          <option value="percent">Percent</option>
          <option value="scientific">Scientific</option>
          <option value="thousands">Thousands (K)</option>
          <option value="millions">Millions (M)</option>
        </select>
        <button class="toolbar-btn" onclick="applyNumberFormat('currency')" title="Currency">$</button>
        <button class="toolbar-btn" onclick="applyNumberFormat('percent')" title="Percent">%</button>
        <button class="toolbar-btn" onclick="formatNumber('decimal')" title="Increase Decimals">.0</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showConditionalFormat()" title="Conditional Formatting">üé®</button>
        <button class="toolbar-btn" onclick="showQuickAnalysis()" title="Quick Analysis (Ctrl+Q)">‚ö° Quick</button>
        <button class="toolbar-btn" onclick="sortData('asc')" title="Sort A-Z">‚ÜëAZ</button>
        <button class="toolbar-btn" onclick="sortData('desc')" title="Sort Z-A">‚ÜìZA</button>
        <button class="toolbar-btn" onclick="toggleFilter()" title="Filter">üîΩ</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="mergeCells()" title="Merge Cells">‚äû Merge</button>
        <button class="toolbar-btn" onclick="unmergeCells()" title="Unmerge Cells">‚äü Unmerge</button>
        <button class="toolbar-btn" onclick="toggleTextWrap()" title="Wrap Text">‚Ü© Wrap</button>
        <button class="toolbar-btn" onclick="showTextRotation(event)" title="Text Rotation">‚ü≥ Rotate</button>
        <button class="toolbar-btn" onclick="decreaseIndent()" title="Decrease Indent">‚á§</button>
        <button class="toolbar-btn" onclick="increaseIndent()" title="Increase Indent">‚á•</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="insertRow()" title="Insert Row">+‚Üì</button>
        <button class="toolbar-btn" onclick="insertColumn()" title="Insert Column">+‚Üí</button>
        <button class="toolbar-btn" onclick="deleteRow()" title="Delete Row">‚àí‚Üì</button>
        <button class="toolbar-btn" onclick="deleteColumn()" title="Delete Column">‚àí‚Üí</button>
        <button class="toolbar-btn" onclick="hideRow()" title="Hide Row">‚äü‚Üì</button>
        <button class="toolbar-btn" onclick="hideColumn()" title="Hide Column">‚äü‚Üí</button>
        <button class="toolbar-btn" onclick="showAllRowsCols()" title="Unhide All">üëÅ</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="autoFitColumnWidth()" title="Auto-fit Column Width">‚Üî AutoFit</button>
        <button class="toolbar-btn" onclick="selectEntireRow()" title="Select Entire Row">‚á• Row</button>
        <button class="toolbar-btn" onclick="selectEntireColumn()" title="Select Entire Column">‚á§ Col</button>
        <button class="toolbar-btn" onclick="showGoToCell()" title="Go To Cell (Ctrl+G)">‚åñ Go To</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="autoSum()" title="AutoSum (Alt+=)" style="font-weight: bold;">Œ£ AutoSum</button>
        <button class="toolbar-btn" onclick="autoAverage()" title="Auto Average">xÃÑ Avg</button>
        <button class="toolbar-btn" onclick="autoCount()" title="Auto Count"># Count</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="copyCells()" title="Copy (Ctrl+C)">üìã Copy</button>
        <button class="toolbar-btn" onclick="cutCells()" title="Cut (Ctrl+X)">‚úÇÔ∏è Cut</button>
        <button class="toolbar-btn" onclick="pasteCells()" title="Paste (Ctrl+V)">üìÑ Paste</button>
        <button class="toolbar-btn" onclick="showPasteSpecial()" title="Paste Special">üìÑ+ Paste Special</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="fillDown()" title="Fill Down (Ctrl+D)">‚¨áÔ∏è Fill Down</button>
        <button class="toolbar-btn" onclick="fillRight()" title="Fill Right (Ctrl+R)">‚û°Ô∏è Fill Right</button>
        <button class="toolbar-btn" onclick="showInsertHyperlink()" title="Insert Hyperlink">üîó Hyperlink</button>
        <button class="toolbar-btn" onclick="showStockImages()" title="Stock Images">üåê Stock Images</button>
        <button class="toolbar-btn" onclick="showQRCodeGenerator()" title="QR Code">‚ñ£ QR Code</button>
        <button class="toolbar-btn" onclick="showFindReplace()" title="Find & Replace (Ctrl+H)">üîç Find & Replace</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="clearCellFormatting()" title="Clear Formatting">üßπ Clear Format</button>
        <button class="toolbar-btn" onclick="clearCellContents()" title="Clear Contents">üóë Clear</button>
        <button class="toolbar-btn" onclick="clearCellAll()" title="Clear All">‚úï Clear All</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="toggleDictation()" title="Dictation (Voice Input)" id="dictationBtn">üé§ Dictate</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showCellStyles(event)" title="Cell Styles">üé® Cell Styles</button>
      </div>
    </div>

    <!-- Formulas Toolbar -->
    <div class="toolbar" id="formulasToolbar" style="display: none;">
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showFormulaBuilder()" title="Insert Function (Shift+F3)" style="background: #e8f0fe;">ùëìùë• Insert Function</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="insertFunction('SUM')" title="SUM">Œ£ SUM</button>
        <button class="toolbar-btn" onclick="insertFunction('AVERAGE')" title="AVERAGE">xÃÑ AVG</button>
        <button class="toolbar-btn" onclick="insertFunction('COUNT')" title="COUNT"># COUNT</button>
        <button class="toolbar-btn" onclick="insertFunction('MAX')" title="MAX">‚Üë MAX</button>
        <button class="toolbar-btn" onclick="insertFunction('MIN')" title="MIN">‚Üì MIN</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="insertFunction('IF')" title="IF">? IF</button>
        <button class="toolbar-btn" onclick="insertFunction('VLOOKUP')" title="VLOOKUP">‚áä VLOOKUP</button>
        <button class="toolbar-btn" onclick="insertFunction('HLOOKUP')" title="HLOOKUP">‚áâ HLOOKUP</button>
        <button class="toolbar-btn" onclick="insertFunction('INDEX')" title="INDEX">‚ä° INDEX</button>
        <button class="toolbar-btn" onclick="insertFunction('MATCH')" title="MATCH">‚äú MATCH</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="insertFunction('CONCATENATE')" title="CONCATENATE">& CONCAT</button>
        <button class="toolbar-btn" onclick="insertFunction('LEFT')" title="LEFT">‚Üê LEFT</button>
        <button class="toolbar-btn" onclick="insertFunction('RIGHT')" title="RIGHT">‚Üí RIGHT</button>
        <button class="toolbar-btn" onclick="insertFunction('LEN')" title="LEN"># LEN</button>
      </div>
    </div>

    <!-- Data Toolbar -->
    <div class="toolbar" id="dataToolbar" style="display: none;">
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="sortData('asc')">‚Üë Sort A-Z</button>
        <button class="toolbar-btn" onclick="sortData('desc')">‚Üì Sort Z-A</button>
        <button class="toolbar-btn" onclick="toggleFilter()">üîΩ Filter</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="removeDuplicates()">üóë Remove Duplicates</button>
        <button class="toolbar-btn" onclick="textToColumns()">‚ãÆ Text to Columns</button>
        <button class="toolbar-btn" onclick="flashFill()">‚ö° Flash Fill</button>
        <button class="toolbar-btn" onclick="showDataValidation()">‚úì Data Validation</button>
        <button class="toolbar-btn" onclick="showFillSeries()">üìà Fill Series</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showPivotModal()">üìã Pivot Table</button>
        <button class="toolbar-btn" onclick="showChartModal()">üìä Chart</button>
        <button class="toolbar-btn" onclick="showSparklinesModal()">‚ú® Sparkline</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showGoalSeek()">üéØ Goal Seek</button>
        <button class="toolbar-btn" onclick="showFormatTable()">üìã Format as Table</button>
        <button class="toolbar-btn" onclick="showAdvCondFormat()">üé® Adv. Formatting</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showSubtotals()">Œ£ Subtotals</button>
        <button class="toolbar-btn" onclick="showSlicers()">üî≤ Slicers</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showScenarioManager()">üìä Scenarios</button>
        <button class="toolbar-btn" onclick="showDataTable()">üìã Data Table</button>
        <button class="toolbar-btn" onclick="showSolver()">üéØ Solver</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showSheetProtection()">üîí Protect Sheet</button>
        <button class="toolbar-btn" onclick="showFormulaAuditing()">üîç Audit Formulas</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showCascadingDropdowns()">üîó Cascading Lists</button>
      </div>
    </div>

    <!-- View Toolbar -->
    <div class="toolbar" id="viewToolbar" style="display: none;">
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="freezePane()" title="Freeze current row and column">‚ùÑ Freeze Panes</button>
        <button class="toolbar-btn" onclick="freezeTopRow()" title="Freeze Top Row">‚ùÑ Top Row</button>
        <button class="toolbar-btn" onclick="freezeFirstColumn()" title="Freeze First Column">‚ùÑ First Col</button>
        <button class="toolbar-btn" onclick="unfreezePane()" title="Unfreeze all panes">üîì Unfreeze</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="toggleSplitView()" id="splitViewBtn" title="Split View">‚äü Split View</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="toggleRowColumnHighlight()" id="rowColHighlightBtn" title="Highlight active row and column">üìç Row/Col Highlight</button>
        <button class="toolbar-btn" onclick="toggleMiniChartTooltips()" id="miniChartBtn" title="Show mini chart when hovering over numeric cells">üìä Mini Charts</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="hideSelectedRows()">üëÅ Hide Rows</button>
        <button class="toolbar-btn" onclick="showAllRows()">üëÅ Show All Rows</button>
        <button class="toolbar-btn" onclick="hideSelectedColumns()">üëÅ Hide Cols</button>
        <button class="toolbar-btn" onclick="showAllColumns()">üëÅ Show All Cols</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showCellBorders()">‚äû Cell Borders</button>
        <button class="toolbar-btn" onclick="addCellComment()">üí¨ Add Comment</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showNamedRanges()">üìõ Named Ranges</button>
        <button class="toolbar-btn" onclick="showGroupModal()">üìÅ Group</button>
        <button class="toolbar-btn" onclick="showPrintPreview()">üñ® Print Preview</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="setPrintArea()" title="Set Print Area">üìÑ Set Print Area</button>
        <button class="toolbar-btn" onclick="clearPrintArea()" title="Clear Print Area">üóë Clear Print Area</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showFormControls()">üéõ Form Controls</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="toggleDarkMode()" title="Dark Mode" id="darkModeBtn">üåô Dark Mode</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="toggleWatchWindow()" title="Watch Window">üëÅ Watch Window</button>
        <button class="toolbar-btn" onclick="addCellToWatch()" title="Add Cell to Watch">+ Add Watch</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showKeyboardShortcuts()" title="Keyboard Shortcuts (F1)">‚å® Shortcuts</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="showAccessibilityChecker()" title="Accessibility Checker">‚ôø Accessibility</button>
      </div>
      <div class="toolbar-group">
        <button class="toolbar-btn" onclick="toggleAutoSave()" title="Auto-Save" id="autoSaveBtn">üíæ Auto-Save: Off</button>
        <button class="toolbar-btn" onclick="showVersionHistory()" title="Version History">üìú Versions</button>
      </div>
    </div>

    <!-- Find Bar -->
    <div class="find-bar" id="findBar">
      <span>Find:</span>
      <input type="text" id="findInput" placeholder="Search in cells..." onkeyup="findInCells()">
      <span id="findCount" style="font-size: 0.85rem; color: #666;">0 found</span>
      <button class="toolbar-btn" onclick="findPrevCell()">‚óÄ</button>
      <button class="toolbar-btn" onclick="findNextCell()">‚ñ∂</button>
      <span style="margin-left: 1rem;">Replace:</span>
      <input type="text" id="replaceInput" placeholder="Replace with...">
      <button class="btn btn-secondary" style="padding: 0.3rem 0.6rem;" onclick="replaceOneCell()">Replace</button>
      <button class="btn btn-secondary" style="padding: 0.3rem 0.6rem;" onclick="replaceAllCells()">All</button>
      <button class="toolbar-btn" onclick="hideFindBar()">‚úï</button>
    </div>

    <!-- Formula Bar -->
    <div class="formula-bar" style="position: relative;">
      <input type="text" class="cell-ref" id="cellRef" value="A1" readonly>
      <span style="padding: 0 0.5rem; color: var(--secondary);">fx</span>
      <input type="text" class="formula-input" id="formulaInput" placeholder="Enter value or formula (e.g., =SUM(A1:A10))" onkeydown="handleFormulaInput(event)" oninput="handleFormulaAutocomplete(event)" autocomplete="off">
      <!-- Formula Autocomplete Dropdown -->
      <div class="formula-autocomplete" id="formulaAutocomplete"></div>
    </div>

    <!-- Spreadsheet -->
    <div class="spreadsheet-area" id="spreadsheetArea">
      <table class="spreadsheet-table" id="spreadsheet">
        <!-- Generated by JS -->
      </table>
    </div>

    <!-- Conditional Formatting Legend -->
    <div class="cf-legend" id="cfLegend" style="display: none;">
      <span style="font-weight: 500; margin-right: 0.5rem;">Conditional Formatting:</span>
      <div class="cf-legend-item"><div class="cf-legend-color" style="background: #34a853;"></div> High</div>
      <div class="cf-legend-item"><div class="cf-legend-color" style="background: #fbbc04;"></div> Medium</div>
      <div class="cf-legend-item"><div class="cf-legend-color" style="background: #ea4335;"></div> Low</div>
    </div>

    <!-- Sheet Tabs -->
    <div class="sheet-tabs" id="sheetTabs">
      <div class="sheet-tab active" data-sheet="0" onclick="switchSheet(0)">Sheet1</div>
      <div class="sheet-tab-add" onclick="addSheet()" title="Add Sheet">+</div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <span id="statusLeft">
        <span class="status-bar-item" onclick="toggleAutoSaveStatus()" title="Click to toggle auto-save">
          <span class="status-icon" id="autoSaveStatusIcon">üíæ</span>
          <span id="autoSaveStatusText">Auto-save On</span>
        </span>
        <span style="margin: 0 6px;">|</span>
        <span class="status-bar-item" onclick="showCalcModePopup()" title="Click to change calculation mode">
          <span class="status-icon">‚ö°</span>
          <span id="calcModeDisplay">Auto-Calculate</span>
        </span>
      </span>
      <span id="statusCenter">
        <span class="status-bar-item" onclick="goToCell()" title="Click to go to cell">
          <span class="status-icon">üìç</span>
          Selection: <span id="selectionInfo">A1</span>
        </span>
        <span style="margin: 0 6px;">|</span>
        <span class="status-bar-item" onclick="showSelectionStats()" title="Click for detailed statistics">
          <span class="status-icon">üìä</span>
          Cells: <span id="cellCount">1</span>
        </span>
      </span>
      <span id="statusRight">
        <span class="status-bar-item" title="Sum of selected cells">
          <span class="status-icon">Œ£</span>
          Sum: <span id="sumDisplay">0</span>
        </span>
        <span style="margin: 0 4px;">|</span>
        <span class="status-bar-item" title="Average of selected cells">
          <span class="status-icon">xÃÑ</span>
          Avg: <span id="avgDisplay">0</span>
        </span>
        <span style="margin: 0 4px;">|</span>
        <span class="status-bar-item" title="Count of selected cells">
          <span class="status-icon">#</span>
          Count: <span id="countDisplay">0</span>
        </span>
        <span style="margin: 0 6px;">|</span>
        <span class="status-bar-item" onclick="showZoomPopup()" title="Click to adjust zoom">
          <span class="status-icon">üîç</span>
          <span id="statusZoom">100%</span>
        </span>
      </span>
    </div>
  </div>

  <!-- Zoom Popup -->
  <div class="zoom-popup" id="zoomPopup">
    <div class="zoom-popup-header">
      <span>Zoom Level</span>
      <button class="zoom-popup-close" onclick="hideZoomPopup()">&times;</button>
    </div>
    <div class="zoom-slider-container">
      <span>50%</span>
      <input type="range" class="zoom-slider" id="zoomSlider" min="50" max="200" value="100" oninput="setZoomFromSlider(this.value)">
      <span>200%</span>
    </div>
    <div class="zoom-presets" id="zoomPresets">
      <button class="zoom-preset-btn" onclick="setZoomLevel(50)">50%</button>
      <button class="zoom-preset-btn" onclick="setZoomLevel(75)">75%</button>
      <button class="zoom-preset-btn active" onclick="setZoomLevel(100)">100%</button>
      <button class="zoom-preset-btn" onclick="setZoomLevel(125)">125%</button>
      <button class="zoom-preset-btn" onclick="setZoomLevel(150)">150%</button>
      <button class="zoom-preset-btn" onclick="setZoomLevel(200)">200%</button>
    </div>
  </div>

  <!-- Calculation Mode Popup -->
  <div class="calc-mode-popup" id="calcModePopup">
    <div class="calc-mode-popup-header">
      <span>‚ö° Calculation Mode</span>
      <button class="zoom-popup-close" onclick="hideCalcModePopup()">&times;</button>
    </div>
    <div class="calc-mode-option active" onclick="setCalcMode('auto')">
      <span>‚ö°</span>
      <span>Automatic</span>
    </div>
    <div class="calc-mode-option" onclick="setCalcMode('manual')">
      <span>‚úã</span>
      <span>Manual (F9 to recalculate)</span>
    </div>
  </div>

  <!-- Welcome Modal -->
  <div class="welcome-modal" id="welcomeModal">
    <div class="welcome-container">
      <div class="welcome-header">
        <h2>Welcome to NinjaCalc</h2>
        <p>Your powerful browser-based spreadsheet</p>
      </div>
      <div class="welcome-tips">
        <div class="welcome-tip">
          <div class="welcome-tip-icon">üîç</div>
          <div class="welcome-tip-content">
            <h4>Command Palette</h4>
            <p>Press <kbd>Ctrl</kbd> + <kbd>K</kbd> to search actions and insert formulas quickly.</p>
          </div>
        </div>
        <div class="welcome-tip">
          <div class="welcome-tip-icon">Œ£</div>
          <div class="welcome-tip-content">
            <h4>Formulas</h4>
            <p>Type <kbd>=</kbd> to start a formula. Supports SUM, AVERAGE, COUNT, IF, and more.</p>
          </div>
        </div>
        <div class="welcome-tip">
          <div class="welcome-tip-icon">üìÅ</div>
          <div class="welcome-tip-content">
            <h4>Import & Export</h4>
            <p>Drag & drop .xlsx or .csv files. Export to Excel, CSV, or PDF formats.</p>
          </div>
        </div>
        <div class="welcome-tip">
          <div class="welcome-tip-icon">üìä</div>
          <div class="welcome-tip-content">
            <h4>Charts</h4>
            <p>Select data and click Insert Chart to visualize your data instantly.</p>
          </div>
        </div>
      </div>
      <div class="welcome-footer">
        <label class="welcome-checkbox">
          <input type="checkbox" id="dontShowAgain">
          Don't show this again
        </label>
        <button class="welcome-btn" onclick="closeWelcome()">Get Started</button>
      </div>
    </div>
  </div>

  <!-- Drag & Drop Overlay -->
  <div class="drop-overlay" id="dropOverlay">
    <div class="drop-overlay-icon">üìä</div>
    <div class="drop-overlay-text">Drop file to open</div>
    <div class="drop-overlay-subtext">Supported: .xlsx, .xls, .csv</div>
  </div>

  <!-- Auto-save Indicator -->
  <div class="autosave-indicator" id="autosaveIndicator">
    <div class="autosave-spinner"></div>
    <span>Auto-saving...</span>
  </div>

  <!-- Global Search Spotlight -->
  <div class="spotlight-overlay" id="spotlightOverlay" onclick="if(event.target === this) hideSpotlight();">
    <div class="spotlight-container">
      <div class="spotlight-input-wrapper">
        <span class="spotlight-search-icon">üîç</span>
        <input type="text" class="spotlight-input" id="spotlightInput" placeholder="Search actions, functions, or cells..." oninput="renderSpotlight(this.value)" onkeydown="handleSpotlightKeydown(event)">
      </div>
      <div class="spotlight-results">
        <div class="spotlight-section-title">Actions</div>
        <div id="spotlightActions"></div>
        <div class="spotlight-section-title">Functions</div>
        <div id="spotlightFunctions"></div>
      </div>
      <div class="spotlight-footer">
        <span>‚Üë‚Üì Navigate</span>
        <span>‚Üµ Select</span>
        <span>Esc Close</span>
      </div>
    </div>
  </div>

  <!-- Floating Action Button -->
  <div class="fab-container" id="fabContainer">
    <div class="fab-menu" id="fabMenu">
      <div class="fab-item">
        <span class="fab-item-label">Insert Chart</span>
        <button class="fab-item-btn" onclick="insertChart(); toggleFab();" title="Insert Chart">üìä</button>
      </div>
      <div class="fab-item">
        <span class="fab-item-label">Add Formula</span>
        <button class="fab-item-btn" onclick="showFormulaBuilder(); toggleFab();" title="Formula Builder">fx</button>
      </div>
      <div class="fab-item">
        <span class="fab-item-label">Command Palette</span>
        <button class="fab-item-btn" onclick="showSpotlight(); toggleFab();" title="Search (Ctrl+K)">‚åò</button>
      </div>
      <div class="fab-item">
        <span class="fab-item-label">Save</span>
        <button class="fab-item-btn" onclick="saveSpreadsheet(); toggleFab();" title="Save (Ctrl+S)">üíæ</button>
      </div>
    </div>
    <button class="fab-main" id="fabMain" onclick="toggleFab()" title="Quick Actions">+</button>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="contextMenuAction('cut')">
      <span class="context-menu-item-icon">‚úÇÔ∏è</span>
      <span>Cut</span>
      <span class="context-menu-item-shortcut">Ctrl+X</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('copy')">
      <span class="context-menu-item-icon">üìã</span>
      <span>Copy</span>
      <span class="context-menu-item-shortcut">Ctrl+C</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('paste')">
      <span class="context-menu-item-icon">üìÑ</span>
      <span>Paste</span>
      <span class="context-menu-item-shortcut">Ctrl+V</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('pasteSpecial')">
      <span class="context-menu-item-icon">üìã</span>
      <span>Paste Special...</span>
      <span class="context-menu-item-shortcut">Ctrl+Shift+V</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuAction('insertRow')">
      <span class="context-menu-item-icon">‚ûï</span>
      <span>Insert Row</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('insertCol')">
      <span class="context-menu-item-icon">‚ûï</span>
      <span>Insert Column</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('deleteRow')">
      <span class="context-menu-item-icon">‚ûñ</span>
      <span>Delete Row</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('deleteCol')">
      <span class="context-menu-item-icon">‚ûñ</span>
      <span>Delete Column</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuAction('clearContents')">
      <span class="context-menu-item-icon">üóëÔ∏è</span>
      <span>Clear Contents</span>
      <span class="context-menu-item-shortcut">Delete</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('clearFormats')">
      <span class="context-menu-item-icon">üßπ</span>
      <span>Clear Formatting</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuAction('formatCells')">
      <span class="context-menu-item-icon">üé®</span>
      <span>Format Cells...</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('columnWidth')">
      <span class="context-menu-item-icon">‚ÜîÔ∏è</span>
      <span>Column Width...</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('rowHeight')">
      <span class="context-menu-item-icon">‚ÜïÔ∏è</span>
      <span>Row Height...</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuAction('addComment')">
      <span class="context-menu-item-icon">üí¨</span>
      <span>Add Comment</span>
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('addToWatch')">
      <span class="context-menu-item-icon">üëÅÔ∏è</span>
      <span>Add to Watch Window</span>
    </div>
  </div>

  <!-- Watch Window Panel -->
  <div class="watch-window" id="watchWindow">
    <div class="watch-window-header" id="watchWindowHeader">
      <h4>Watch Window</h4>
      <button class="watch-window-close" onclick="toggleWatchWindow()">&times;</button>
    </div>
    <div class="watch-window-body">
      <table class="watch-table" id="watchTable">
        <thead>
          <tr>
            <th style="width: 60px;">Cell</th>
            <th style="width: 100px;">Value</th>
            <th>Formula</th>
            <th style="width: 40px;"></th>
          </tr>
        </thead>
        <tbody id="watchTableBody">
        </tbody>
      </table>
      <div class="watch-empty" id="watchEmpty">No cells being watched.<br>Select a cell and click "Add Watch"</div>
    </div>
  </div>

  <!-- Quick Access Toolbar Customization Modal -->
  <div class="modal-overlay" id="qatModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>‚ö° Customize Quick Access Toolbar</h3>
        <button class="modal-close" onclick="hideQATCustomization()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--secondary); margin-bottom: 1rem;">Select commands to add to your Quick Access Toolbar:</p>
        <div class="qat-modal-items" id="qatCommandsList"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="resetQAT()">Reset to Default</button>
        <button class="btn btn-secondary" onclick="hideQATCustomization()">Cancel</button>
        <button class="btn btn-primary" onclick="saveQATCustomization()">Save</button>
      </div>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div class="modal-overlay" id="shortcutsModal">
    <div class="modal" style="max-width: 700px; max-height: 80vh;">
      <div class="modal-header">
        <h3>Keyboard Shortcuts</h3>
        <button class="modal-close" onclick="hideKeyboardShortcuts()">&times;</button>
      </div>
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div class="shortcuts-grid">
          <div class="shortcuts-section">
            <h4>Navigation</h4>
            <div class="shortcut-item"><kbd>Arrow Keys</kbd> <span>Move between cells</span></div>
            <div class="shortcut-item"><kbd>Tab</kbd> <span>Move right</span></div>
            <div class="shortcut-item"><kbd>Shift</kbd> + <kbd>Tab</kbd> <span>Move left</span></div>
            <div class="shortcut-item"><kbd>Enter</kbd> <span>Move down / Confirm</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>Home</kbd> <span>Go to cell A1</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>End</kbd> <span>Go to last cell</span></div>
          </div>
          <div class="shortcuts-section">
            <h4>Selection</h4>
            <div class="shortcut-item"><kbd>Shift</kbd> + <kbd>Arrow</kbd> <span>Extend selection</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>A</kbd> <span>Select all</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>Space</kbd> <span>Select column</span></div>
            <div class="shortcut-item"><kbd>Shift</kbd> + <kbd>Space</kbd> <span>Select row</span></div>
          </div>
          <div class="shortcuts-section">
            <h4>Editing</h4>
            <div class="shortcut-item"><kbd>F2</kbd> <span>Edit cell</span></div>
            <div class="shortcut-item"><kbd>Delete</kbd> <span>Clear cell</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>Z</kbd> <span>Undo</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>Y</kbd> <span>Redo</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>X</kbd> <span>Cut</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>C</kbd> <span>Copy</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>V</kbd> <span>Paste</span></div>
          </div>
          <div class="shortcuts-section">
            <h4>Formatting & Features</h4>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>B</kbd> <span>Bold</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>I</kbd> <span>Italic</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>U</kbd> <span>Underline</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>Q</kbd> <span>Quick Analysis</span></div>
            <div class="shortcut-item"><kbd>Ctrl</kbd> + <kbd>F</kbd> <span>Find</span></div>
            <div class="shortcut-item"><kbd>F1</kbd> <span>Show Shortcuts</span></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- XLSX file input -->
  <input type="file" id="xlsxImport" accept=".xlsx,.xls" style="display: none;" onchange="handleXlsxImport(event)">

  <!-- Chart Modal -->
  <div class="modal-overlay" id="chartModal">
    <div class="modal chart-modal">
      <div class="modal-header">
        <h3>Create Chart</h3>
        <button class="modal-close" onclick="hideChartModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Chart Type</label>
          <select class="form-control" id="chartType">
            <option value="bar">Bar Chart</option>
            <option value="line">Line Chart</option>
            <option value="pie">Pie Chart</option>
            <option value="doughnut">Doughnut Chart</option>
            <option value="scatter">Scatter Plot</option>
            <option value="area">Area Chart</option>
            <option value="radar">Radar Chart</option>
            <option value="polarArea">Polar Area Chart</option>
            <option value="bubble">Bubble Chart</option>
          </select>
        </div>
        <div class="form-group">
          <label>Data Range (e.g., A1:B10)</label>
          <input type="text" class="form-control" id="chartRange" placeholder="A1:B10">
        </div>
        <div class="form-group">
          <label>Chart Title</label>
          <input type="text" class="form-control" id="chartTitle" placeholder="My Chart">
        </div>
        <div class="form-group" id="trendlineGroup" style="display: none;">
          <label>Trendline</label>
          <select class="form-control" id="chartTrendline" onchange="updateTrendlineOptions()">
            <option value="none">None</option>
            <option value="linear">Linear</option>
            <option value="exponential">Exponential</option>
            <option value="polynomial">Polynomial</option>
            <option value="logarithmic">Logarithmic</option>
            <option value="power">Power</option>
            <option value="movingAverage">Moving Average</option>
          </select>
          <div id="trendlineOptions" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #f5f5f5; border-radius: 4px;">
            <div id="polynomialOrder" style="display: none;">
              <label style="font-size: 0.85rem;">Polynomial Order:</label>
              <input type="number" class="form-control" id="trendlineOrder" value="2" min="2" max="6" style="width: 80px;">
            </div>
            <div id="movingAvgPeriod" style="display: none;">
              <label style="font-size: 0.85rem;">Period:</label>
              <input type="number" class="form-control" id="trendlinePeriod" value="2" min="2" max="10" style="width: 80px;">
            </div>
            <div style="margin-top: 0.5rem;">
              <label style="font-size: 0.85rem;"><input type="checkbox" id="showTrendlineEquation"> Display Equation</label>
              <label style="font-size: 0.85rem; margin-left: 1rem;"><input type="checkbox" id="showTrendlineR2"> Display R¬≤ Value</label>
            </div>
            <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
              <label style="font-size: 0.85rem;">Line Color:</label>
              <input type="color" id="trendlineColor" value="#ff6384" style="width: 40px; height: 25px;">
            </div>
          </div>
        </div>
        <div id="chartPreview" style="height: 200px; margin-top: 1rem;"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideChartModal()">Cancel</button>
        <button class="btn btn-primary" onclick="previewChart()">Preview</button>
        <button class="btn btn-success" onclick="createChart()">Insert Chart</button>
      </div>
    </div>
  </div>

  <!-- Pivot Table Modal -->
  <div class="modal-overlay" id="pivotModal">
    <div class="modal pivot-modal">
      <div class="modal-header">
        <h3>Create Pivot Table</h3>
        <button class="modal-close" onclick="hidePivotModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 1rem;">
          <div>
            <div class="form-group">
              <label>Source Data Range</label>
              <input type="text" class="form-control" id="pivotRange" placeholder="A1:D20">
            </div>
            <div class="form-group">
              <label>Row Field (Column Letter)</label>
              <input type="text" class="form-control" id="pivotRow" placeholder="A">
            </div>
            <div class="form-group">
              <label>Value Field (Column Letter)</label>
              <input type="text" class="form-control" id="pivotValue" placeholder="B">
            </div>
            <div class="form-group">
              <label>Aggregation</label>
              <select class="form-control" id="pivotAgg">
                <option value="sum">Sum</option>
                <option value="count">Count</option>
                <option value="average">Average</option>
                <option value="max">Max</option>
                <option value="min">Min</option>
              </select>
            </div>
            <button class="btn btn-primary" onclick="generatePivot()" style="width: 100%;">Generate Pivot</button>
          </div>
          <div id="pivotPreview" style="overflow: auto; max-height: 400px; background: #f5f5f5; padding: 1rem; border-radius: 4px;">
            <p style="color: #666;">Pivot table preview will appear here...</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Macro Modal -->
  <div class="modal-overlay" id="macroModal">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h3>Macro Editor</h3>
        <button class="modal-close" onclick="hideMacroModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Macro Name</label>
          <input type="text" class="form-control" id="macroName" placeholder="myMacro">
        </div>
        <div class="form-group">
          <label>Macro Code (JavaScript)</label>
          <textarea class="form-control macro-editor" id="macroCode" rows="12" placeholder="// Example: Fill column A with numbers 1-10
for (let i = 1; i <= 10; i++) {
  setCellValue('A' + i, i);
}

// Available functions:
// getCellValue(ref) - Get value from cell (e.g., 'A1')
// setCellValue(ref, value) - Set cell value
// getRange(range) - Get array of values (e.g., 'A1:A10')
// setRange(range, values) - Set range of values"></textarea>
        </div>
        <div class="form-group">
          <label>Saved Macros</label>
          <select class="form-control" id="savedMacros" onchange="loadMacro()">
            <option value="">-- Select a macro --</option>
          </select>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideMacroModal()">Cancel</button>
        <button class="btn btn-secondary" onclick="saveMacro()">Save Macro</button>
        <button class="btn btn-success" onclick="runMacro()">‚ñ∂ Run Macro</button>
      </div>
    </div>
  </div>

  <!-- Conditional Formatting Modal -->
  <div class="modal-overlay" id="cfModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Conditional Formatting</h3>
        <button class="modal-close" onclick="hideCfModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Apply to Range</label>
          <input type="text" class="form-control" id="cfRange" placeholder="A1:A20">
        </div>
        <div class="form-group">
          <label>Format Style</label>
          <select class="form-control" id="cfStyle">
            <option value="colorScale">Color Scale (High/Medium/Low)</option>
            <option value="greaterThan">Greater Than Value</option>
            <option value="lessThan">Less Than Value</option>
            <option value="between">Between Values</option>
          </select>
        </div>
        <div class="form-group" id="cfValueGroup">
          <label>Value</label>
          <input type="number" class="form-control" id="cfValue" placeholder="100">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideCfModal()">Cancel</button>
        <button class="btn btn-primary" onclick="applyConditionalFormat()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Open Spreadsheets Modal -->
  <div class="modal-overlay" id="openModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3>Open Spreadsheet</h3>
        <button class="modal-close" onclick="hideOpenDialog()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="savedDocsList" style="max-height: 400px; overflow-y: auto;">
          <p style="color: var(--secondary);">No saved spreadsheets yet.</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideOpenDialog()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Save As Modal -->
  <div class="modal-overlay" id="saveAsModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Save Spreadsheet As</h3>
        <button class="modal-close" onclick="hideSaveAs()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Spreadsheet Name</label>
          <input type="text" class="form-control" id="saveAsName" placeholder="My Spreadsheet">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideSaveAs()">Cancel</button>
        <button class="btn btn-primary" onclick="confirmSaveAs()">Save</button>
      </div>
    </div>
  </div>

  <!-- Data Validation Modal -->
  <div class="modal-overlay" id="dataValidationModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Data Validation</h3>
        <button class="modal-close" onclick="hideDataValidation()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Apply to Cell</label>
          <input type="text" class="form-control" id="dvCell" placeholder="A1" readonly>
        </div>
        <div class="form-group">
          <label>Validation Type</label>
          <select class="form-control" id="dvType" onchange="updateDvOptions()">
            <option value="any">Any value</option>
            <option value="number">Whole number</option>
            <option value="decimal">Decimal</option>
            <option value="list">List</option>
            <option value="date">Date</option>
            <option value="textLength">Text length</option>
          </select>
        </div>
        <div class="form-group" id="dvRangeGroup" style="display: none;">
          <label>Condition</label>
          <div style="display: flex; gap: 0.5rem;">
            <select class="form-control" id="dvCondition" style="width: 50%;">
              <option value="between">Between</option>
              <option value="notBetween">Not between</option>
              <option value="equal">Equal to</option>
              <option value="notEqual">Not equal to</option>
              <option value="greater">Greater than</option>
              <option value="less">Less than</option>
            </select>
            <input type="text" class="form-control" id="dvMin" placeholder="Min" style="width: 25%;">
            <input type="text" class="form-control" id="dvMax" placeholder="Max" style="width: 25%;">
          </div>
        </div>
        <div class="form-group" id="dvListGroup" style="display: none;">
          <label>List Items (comma-separated)</label>
          <input type="text" class="form-control" id="dvList" placeholder="Option1, Option2, Option3">
        </div>
        <div class="form-group">
          <label>Error Message</label>
          <input type="text" class="form-control" id="dvErrorMsg" placeholder="Invalid value entered">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideDataValidation()">Cancel</button>
        <button class="btn btn-danger" onclick="clearDataValidation()">Clear</button>
        <button class="btn btn-primary" onclick="applyDataValidation()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Cell Borders Modal -->
  <div class="modal-overlay" id="bordersModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Cell Borders</h3>
        <button class="modal-close" onclick="hideCellBorders()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Border Style</label>
          <select class="form-control" id="borderStyle">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
            <option value="double">Double</option>
          </select>
        </div>
        <div class="form-group">
          <label>Border Width</label>
          <select class="form-control" id="borderWidth">
            <option value="1px">Thin</option>
            <option value="2px">Medium</option>
            <option value="3px">Thick</option>
          </select>
        </div>
        <div class="form-group">
          <label>Border Color</label>
          <input type="color" class="form-control" id="borderColor" value="#000000" style="height: 40px;">
        </div>
        <div class="form-group">
          <label>Apply To</label>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
            <button class="btn btn-secondary" onclick="applyBorder('all')">All</button>
            <button class="btn btn-secondary" onclick="applyBorder('outside')">Outside</button>
            <button class="btn btn-secondary" onclick="applyBorder('inside')">Inside</button>
            <button class="btn btn-secondary" onclick="applyBorder('top')">Top</button>
            <button class="btn btn-secondary" onclick="applyBorder('bottom')">Bottom</button>
            <button class="btn btn-secondary" onclick="applyBorder('left')">Left</button>
            <button class="btn btn-secondary" onclick="applyBorder('right')">Right</button>
            <button class="btn btn-secondary" onclick="applyBorder('none')">None</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideCellBorders()">Close</button>
      </div>
    </div>
  </div>

  <!-- Named Ranges Modal -->
  <div class="modal-overlay" id="namedRangesModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Named Ranges</h3>
        <button class="modal-close" onclick="hideNamedRanges()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Range Name</label>
          <input type="text" class="form-control" id="rangeName" placeholder="MyRange">
        </div>
        <div class="form-group">
          <label>Refers To</label>
          <input type="text" class="form-control" id="rangeRef" placeholder="A1:B10">
        </div>
        <button class="btn btn-primary" onclick="addNamedRange()" style="margin-bottom: 1rem;">Add Range</button>
        <div class="form-group">
          <label>Existing Named Ranges</label>
          <div id="namedRangesList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 0.5rem;">
            <p style="color: var(--secondary); font-size: 0.9rem;">No named ranges defined.</p>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideNamedRanges()">Close</button>
      </div>
    </div>
  </div>

  <!-- Print Preview Modal -->
  <div class="modal-overlay" id="printPreviewModal">
    <div class="modal" style="max-width: 900px; max-height: 90vh;">
      <div class="modal-header">
        <h3>Print Preview</h3>
        <button class="modal-close" onclick="hidePrintPreview()">&times;</button>
      </div>
      <div class="modal-body">
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
          <div class="form-group" style="flex: 1;">
            <label>Print Range</label>
            <select class="form-control" id="printRange" onchange="updatePrintPreview()">
              <option value="all">Entire Sheet</option>
              <option value="selection">Selected Range</option>
              <option value="custom">Custom Range</option>
            </select>
          </div>
          <div class="form-group" style="flex: 1;">
            <label>Custom Range</label>
            <input type="text" class="form-control" id="customPrintRange" placeholder="A1:H20" onchange="updatePrintPreview()">
          </div>
          <div class="form-group" style="flex: 1;">
            <label>Orientation</label>
            <select class="form-control" id="printOrientation" onchange="updatePrintPreview()">
              <option value="portrait">Portrait</option>
              <option value="landscape">Landscape</option>
            </select>
          </div>
        </div>
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
          <label><input type="checkbox" id="printGridlines" checked onchange="updatePrintPreview()"> Show Gridlines</label>
          <label><input type="checkbox" id="printHeaders" checked onchange="updatePrintPreview()"> Show Row/Column Headers</label>
        </div>
        <div style="background: #666; padding: 2rem; overflow: auto; max-height: 50vh;">
          <div id="printPreviewContent" style="background: white; margin: 0 auto; padding: 1rem; box-shadow: 0 4px 20px rgba(0,0,0,0.3);"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hidePrintPreview()">Cancel</button>
        <button class="btn btn-primary" onclick="window.print()">Print</button>
        <button class="btn btn-success" onclick="exportToPDF()">Export PDF</button>
      </div>
    </div>
  </div>

  <!-- Group/Outline Modal -->
  <div class="modal-overlay" id="groupModal">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Group Rows/Columns</h3>
        <button class="modal-close" onclick="hideGroupModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Group Type</label>
          <select class="form-control" id="groupType">
            <option value="rows">Rows</option>
            <option value="cols">Columns</option>
          </select>
        </div>
        <div class="form-group">
          <label>Start (row number or column letter)</label>
          <input type="text" class="form-control" id="groupStart" placeholder="2 or B">
        </div>
        <div class="form-group">
          <label>End (row number or column letter)</label>
          <input type="text" class="form-control" id="groupEnd" placeholder="5 or E">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideGroupModal()">Cancel</button>
        <button class="btn btn-primary" onclick="createGroup()">Create Group</button>
      </div>
    </div>
  </div>

  <!-- Accessibility Checker Modal -->
  <div class="modal-overlay" id="accessibilityModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3>‚ôø Accessibility Checker</h3>
        <button class="modal-close" onclick="hideAccessibilityChecker()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--secondary); margin-bottom: 1rem;">Check your spreadsheet for accessibility issues.</p>

        <div style="margin-bottom: 1rem;">
          <button class="btn btn-primary" onclick="runAccessibilityCheck()">Check Accessibility</button>
          <button class="btn btn-secondary" onclick="clearAccessibilityResults()">Clear</button>
        </div>

        <div id="accessibilityResults" style="max-height: 350px; overflow-y: auto;">
          <div id="accessibilityErrors" style="display: none; margin-bottom: 1rem;">
            <h4 style="color: #d93025; margin-bottom: 0.5rem;">‚ö† Errors</h4>
            <div id="accessibilityErrorList" style="border: 1px solid #fce8e6; border-radius: 4px; background: #fef7f7;"></div>
          </div>

          <div id="accessibilityWarnings" style="display: none; margin-bottom: 1rem;">
            <h4 style="color: #f9ab00; margin-bottom: 0.5rem;">‚ö° Warnings</h4>
            <div id="accessibilityWarningList" style="border: 1px solid #fef3e0; border-radius: 4px; background: #fffcf7;"></div>
          </div>

          <div id="accessibilityTips" style="display: none; margin-bottom: 1rem;">
            <h4 style="color: #1a73e8; margin-bottom: 0.5rem;">üí° Tips</h4>
            <div id="accessibilityTipList" style="border: 1px solid #e8f0fe; border-radius: 4px; background: #f8fbff;"></div>
          </div>

          <div id="accessibilitySuccess" style="display: none; text-align: center; padding: 2rem;">
            <div style="font-size: 48px; margin-bottom: 0.5rem;">‚úì</div>
            <h4 style="color: #34a853;">No accessibility issues found!</h4>
            <p style="color: var(--secondary);">Your spreadsheet is accessible.</p>
          </div>

          <div id="accessibilityEmpty" style="text-align: center; padding: 2rem; color: #666;">
            <div style="font-size: 48px; margin-bottom: 0.5rem;">‚ôø</div>
            <p>Click "Check Accessibility" to analyze your spreadsheet.</p>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideAccessibilityChecker()">Close</button>
      </div>
    </div>
  </div>

  <!-- Sparklines Modal -->
  <div class="modal-overlay" id="sparklinesModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Insert Sparkline</h3>
        <button class="modal-close" onclick="hideSparklinesModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Sparkline Type</label>
          <select class="form-control" id="sparklineType">
            <option value="line">Line</option>
            <option value="bar">Bar</option>
            <option value="column">Column</option>
            <option value="winloss">Win/Loss</option>
            <option value="area">Area</option>
          </select>
        </div>
        <div class="form-group">
          <label>Data Range (e.g., A1:A10)</label>
          <input type="text" class="form-control" id="sparklineRange" placeholder="A1:A10">
        </div>
        <div class="form-group">
          <label>Target Cell</label>
          <input type="text" class="form-control" id="sparklineTarget" placeholder="B1">
        </div>
        <div class="form-group">
          <label>Color</label>
          <input type="color" class="form-control" id="sparklineColor" value="#4285f4" style="height: 40px;">
        </div>
        <div id="sparklinePreview" style="height: 50px; border: 1px solid var(--border); margin-top: 0.5rem; display: flex; align-items: center; justify-content: center;"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideSparklinesModal()">Cancel</button>
        <button class="btn btn-primary" onclick="previewSparkline()">Preview</button>
        <button class="btn btn-success" onclick="insertSparkline()">Insert</button>
      </div>
    </div>
  </div>

  <!-- Goal Seek Modal -->
  <div class="modal-overlay" id="goalSeekModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Goal Seek</h3>
        <button class="modal-close" onclick="hideGoalSeek()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--secondary); margin-bottom: 1rem;">Find what value in a cell will produce a desired result in a formula cell.</p>
        <div class="form-group">
          <label>Set Cell (formula cell)</label>
          <input type="text" class="form-control" id="goalSetCell" placeholder="C1">
        </div>
        <div class="form-group">
          <label>To Value</label>
          <input type="number" class="form-control" id="goalValue" placeholder="100">
        </div>
        <div class="form-group">
          <label>By Changing Cell</label>
          <input type="text" class="form-control" id="goalChangeCell" placeholder="A1">
        </div>
        <div id="goalSeekResult" style="padding: 1rem; background: #f5f5f5; border-radius: 4px; display: none;"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideGoalSeek()">Cancel</button>
        <button class="btn btn-primary" onclick="runGoalSeek()">Solve</button>
      </div>
    </div>
  </div>

  <!-- Solver Modal -->
  <div class="modal-overlay" id="solverModal">
    <div class="modal" style="max-width: 550px;">
      <div class="modal-header">
        <h3>Solver</h3>
        <button class="modal-close" onclick="hideSolver()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Set Objective (target cell)</label>
          <input type="text" class="form-control" id="solverObjective" placeholder="e.g., C10">
        </div>
        <div class="form-group">
          <label>Goal</label>
          <div style="display: flex; gap: 1rem; margin-top: 0.5rem;">
            <label><input type="radio" name="solverGoal" value="max" checked> Maximize</label>
            <label><input type="radio" name="solverGoal" value="min"> Minimize</label>
            <label><input type="radio" name="solverGoal" value="value"> Value of:</label>
            <input type="number" class="form-control" id="solverTargetValue" placeholder="0" style="width: 80px;">
          </div>
        </div>
        <div class="form-group">
          <label>By Changing Variable Cells</label>
          <input type="text" class="form-control" id="solverChangeCells" placeholder="e.g., A1:A5 or A1,B1,C1">
        </div>
        <div class="form-group">
          <label>Subject to Constraints</label>
          <div id="solverConstraints" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
            <p style="color: #666; font-style: italic; margin: 0;">No constraints added</p>
          </div>
          <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
            <input type="text" class="form-control" id="solverConstraintCell" placeholder="Cell (e.g., B1)" style="width: 100px;">
            <select class="form-control" id="solverConstraintOp" style="width: 80px;">
              <option value="<=">&le;</option>
              <option value=">=">&ge;</option>
              <option value="=">=</option>
            </select>
            <input type="text" class="form-control" id="solverConstraintValue" placeholder="Value or Cell" style="width: 120px;">
            <button class="btn btn-secondary" onclick="addSolverConstraint()">Add</button>
          </div>
        </div>
        <div class="form-group">
          <label>Options</label>
          <div style="display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 0.5rem;">
            <label><input type="checkbox" id="solverNonNegative" checked> Non-negative variables</label>
            <label><input type="checkbox" id="solverInteger"> Integer constraints</label>
          </div>
          <div style="margin-top: 0.5rem;">
            <label>Max Iterations: </label>
            <input type="number" class="form-control" id="solverMaxIterations" value="100" min="10" max="1000" style="width: 100px; display: inline-block;">
          </div>
        </div>
        <div id="solverResult" style="padding: 1rem; background: #e8f5e9; border-radius: 4px; display: none; margin-top: 1rem;">
          <strong>Result:</strong>
          <div id="solverResultText"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="clearSolverConstraints()">Clear All</button>
        <button class="btn btn-secondary" onclick="hideSolver()">Cancel</button>
        <button class="btn btn-primary" onclick="runSolver()">Solve</button>
      </div>
    </div>
  </div>

  <!-- Format as Table Modal -->
  <div class="modal-overlay" id="formatTableModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Format as Table</h3>
        <button class="modal-close" onclick="hideFormatTable()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Table Range</label>
          <input type="text" class="form-control" id="tableRange" placeholder="A1:D10">
        </div>
        <div class="form-group">
          <label><input type="checkbox" id="tableHasHeaders" checked> My table has headers</label>
        </div>
        <div class="form-group">
          <label>Table Style</label>
          <div id="tableStyles" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;">
            <div class="table-style-option" onclick="selectTableStyle('blue')" style="height: 40px; background: linear-gradient(#4285f4 0%, #4285f4 30%, #c2deff 30%, #c2deff 50%, #4285f4 50%, #4285f4 80%, #c2deff 80%); border: 2px solid #4285f4; border-radius: 4px; cursor: pointer;"></div>
            <div class="table-style-option" onclick="selectTableStyle('green')" style="height: 40px; background: linear-gradient(#34a853 0%, #34a853 30%, #c6efce 30%, #c6efce 50%, #34a853 50%, #34a853 80%, #c6efce 80%); border: 2px solid transparent; border-radius: 4px; cursor: pointer;"></div>
            <div class="table-style-option" onclick="selectTableStyle('orange')" style="height: 40px; background: linear-gradient(#ff9800 0%, #ff9800 30%, #ffe0b2 30%, #ffe0b2 50%, #ff9800 50%, #ff9800 80%, #ffe0b2 80%); border: 2px solid transparent; border-radius: 4px; cursor: pointer;"></div>
            <div class="table-style-option" onclick="selectTableStyle('purple')" style="height: 40px; background: linear-gradient(#9c27b0 0%, #9c27b0 30%, #e1bee7 30%, #e1bee7 50%, #9c27b0 50%, #9c27b0 80%, #e1bee7 80%); border: 2px solid transparent; border-radius: 4px; cursor: pointer;"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideFormatTable()">Cancel</button>
        <button class="btn btn-primary" onclick="applyTableFormat()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Advanced Conditional Formatting Modal -->
  <div class="modal-overlay" id="advCondFormatModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3>Advanced Conditional Formatting</h3>
        <button class="modal-close" onclick="hideAdvCondFormat()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Apply to Range</label>
          <input type="text" class="form-control" id="advCondRange" placeholder="A1:A20">
        </div>
        <div class="form-group">
          <label>Format Type</label>
          <select class="form-control" id="advCondType" onchange="updateAdvCondOptions()">
            <option value="dataBar">Data Bars</option>
            <option value="colorScale">Color Scale</option>
            <option value="iconSet">Icon Set</option>
            <option value="topBottom">Top/Bottom Rules</option>
          </select>
        </div>
        <div id="advCondOptions">
          <!-- Dynamic options based on type -->
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideAdvCondFormat()">Cancel</button>
        <button class="btn btn-danger" onclick="clearAdvCondFormat()">Clear Formatting</button>
        <button class="btn btn-primary" onclick="applyAdvCondFormat()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Subtotals Modal -->
  <div class="modal-overlay" id="subtotalsModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>Subtotals</h3>
        <button class="modal-close" onclick="hideSubtotals()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Data Range</label>
          <input type="text" class="form-control" id="subtotalRange" placeholder="A1:D20">
        </div>
        <div class="form-group">
          <label>Group By Column</label>
          <select class="form-control" id="subtotalGroupBy">
            <option value="A">Column A</option>
            <option value="B">Column B</option>
            <option value="C">Column C</option>
            <option value="D">Column D</option>
            <option value="E">Column E</option>
          </select>
        </div>
        <div class="form-group">
          <label>Function</label>
          <select class="form-control" id="subtotalFunction">
            <option value="sum">SUM</option>
            <option value="count">COUNT</option>
            <option value="average">AVERAGE</option>
            <option value="max">MAX</option>
            <option value="min">MIN</option>
          </select>
        </div>
        <div class="form-group">
          <label>Apply To Column</label>
          <select class="form-control" id="subtotalApplyTo">
            <option value="B">Column B</option>
            <option value="C">Column C</option>
            <option value="D">Column D</option>
            <option value="E">Column E</option>
          </select>
        </div>
        <div class="form-group">
          <label style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="subtotalReplace" checked>
            Replace current subtotals
          </label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideSubtotals()">Cancel</button>
        <button class="btn btn-danger" onclick="removeSubtotals()">Remove All</button>
        <button class="btn btn-primary" onclick="applySubtotals()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Slicers Modal -->
  <div class="modal-overlay" id="slicersModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3>Insert Slicer</h3>
        <button class="modal-close" onclick="hideSlicers()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Data Range</label>
          <input type="text" class="form-control" id="slicerRange" placeholder="A1:D20">
        </div>
        <div class="form-group">
          <label>Slicer Column (filter by)</label>
          <select class="form-control" id="slicerColumn">
            <option value="A">Column A</option>
            <option value="B">Column B</option>
            <option value="C">Column C</option>
            <option value="D">Column D</option>
            <option value="E">Column E</option>
          </select>
        </div>
        <div class="form-group">
          <label>Slicer Title</label>
          <input type="text" class="form-control" id="slicerTitle" placeholder="Filter by Category">
        </div>
        <div class="form-group">
          <label>Style</label>
          <select class="form-control" id="slicerStyle">
            <option value="blue">Blue</option>
            <option value="green">Green</option>
            <option value="orange">Orange</option>
            <option value="gray">Gray</option>
          </select>
        </div>
        <div id="slicerPreview" style="margin-top: 1rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">
          <p style="color: #666; text-align: center; font-size: 0.9rem;">Enter a data range to preview slicer options</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideSlicers()">Cancel</button>
        <button class="btn btn-primary" onclick="insertSlicer()">Insert Slicer</button>
      </div>
    </div>
  </div>

  <!-- Slicer Container (displayed next to spreadsheet) -->
  <div id="slicerContainer" style="position: fixed; top: 200px; right: 20px; z-index: 100;"></div>

  <!-- Scenario Manager Modal -->
  <div class="modal-overlay" id="scenarioModal">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h3>Scenario Manager</h3>
        <button class="modal-close" onclick="hideScenarioManager()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--secondary); margin-bottom: 1rem;">Create and manage different scenarios by changing input cells.</p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
          <div>
            <div class="form-group">
              <label>Scenarios</label>
              <div id="scenarioList" style="height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 0.5rem;"></div>
            </div>
            <div style="display: flex; gap: 0.5rem;">
              <button class="btn btn-secondary" onclick="showAddScenario()">Add</button>
              <button class="btn btn-secondary" onclick="deleteScenario()">Delete</button>
              <button class="btn btn-primary" onclick="showScenario()">Show</button>
            </div>
          </div>
          <div>
            <div class="form-group">
              <label>Scenario Summary</label>
              <div id="scenarioSummary" style="padding: 1rem; background: #f5f5f5; border-radius: 4px; min-height: 100px;">
                <p style="color: #666;">Select a scenario to view details</p>
              </div>
            </div>
            <button class="btn btn-primary" onclick="createScenarioReport()" style="width: 100%; margin-top: 0.5rem;">Create Summary Report</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideScenarioManager()">Close</button>
      </div>
    </div>
  </div>

  <!-- Add Scenario Modal -->
  <div class="modal-overlay" id="addScenarioModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>Add Scenario</h3>
        <button class="modal-close" onclick="hideAddScenario()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Scenario Name</label>
          <input type="text" class="form-control" id="scenarioName" placeholder="e.g., Best Case">
        </div>
        <div class="form-group">
          <label>Changing Cells (comma separated)</label>
          <input type="text" class="form-control" id="scenarioCells" placeholder="e.g., A1, B2, C3">
        </div>
        <div class="form-group">
          <label>Values (comma separated)</label>
          <input type="text" class="form-control" id="scenarioValues" placeholder="e.g., 100, 200, 300">
        </div>
        <div class="form-group">
          <label>Comment (optional)</label>
          <textarea class="form-control" id="scenarioComment" rows="2" placeholder="Describe this scenario..."></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideAddScenario()">Cancel</button>
        <button class="btn btn-primary" onclick="saveScenario()">Save</button>
      </div>
    </div>
  </div>

  <!-- Data Table Modal -->
  <div class="modal-overlay" id="dataTableModal">
    <div class="modal" style="max-width: 550px;">
      <div class="modal-header">
        <h3>What-If Data Table</h3>
        <button class="modal-close" onclick="hideDataTable()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--secondary); margin-bottom: 1rem;">Create a one-way or two-way data table to see how changing values affect formulas.</p>
        <div class="form-group">
          <label>Table Type</label>
          <select class="form-control" id="dataTableType" onchange="updateDataTableOptions()">
            <option value="one-way-row">One-Way (Row Input)</option>
            <option value="one-way-col">One-Way (Column Input)</option>
            <option value="two-way">Two-Way</option>
          </select>
        </div>
        <div class="form-group">
          <label>Formula Cell</label>
          <input type="text" class="form-control" id="dataTableFormula" placeholder="e.g., D1 (cell containing formula)">
        </div>
        <div class="form-group" id="rowInputGroup">
          <label>Row Input Cell</label>
          <input type="text" class="form-control" id="dataTableRowInput" placeholder="e.g., A1">
        </div>
        <div class="form-group" id="colInputGroup">
          <label>Column Input Cell</label>
          <input type="text" class="form-control" id="dataTableColInput" placeholder="e.g., B1">
        </div>
        <div class="form-group">
          <label>Output Range</label>
          <input type="text" class="form-control" id="dataTableRange" placeholder="e.g., E2:H10">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideDataTable()">Cancel</button>
        <button class="btn btn-primary" onclick="generateDataTable()">Generate Table</button>
      </div>
    </div>
  </div>

  <!-- Sheet Protection Modal -->
  <div class="modal-overlay" id="sheetProtectionModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>Protect Sheet</h3>
        <button class="modal-close" onclick="hideSheetProtection()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Password (optional)</label>
          <input type="password" class="form-control" id="sheetPassword" placeholder="Enter password">
        </div>
        <div class="form-group">
          <label>Allow users to:</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-top: 0.5rem;">
            <label><input type="checkbox" id="protectSelectLocked" checked> Select locked cells</label>
            <label><input type="checkbox" id="protectSelectUnlocked" checked> Select unlocked cells</label>
            <label><input type="checkbox" id="protectFormat"> Format cells</label>
            <label><input type="checkbox" id="protectFormatCols"> Format columns</label>
            <label><input type="checkbox" id="protectFormatRows"> Format rows</label>
            <label><input type="checkbox" id="protectInsertRows"> Insert rows</label>
            <label><input type="checkbox" id="protectInsertCols"> Insert columns</label>
            <label><input type="checkbox" id="protectDeleteRows"> Delete rows</label>
            <label><input type="checkbox" id="protectDeleteCols"> Delete columns</label>
            <label><input type="checkbox" id="protectSort"> Sort</label>
          </div>
        </div>
        <div class="form-group">
          <label>Unprotected Range (optional)</label>
          <input type="text" class="form-control" id="unprotectedRange" placeholder="e.g., A1:B10 (cells users can edit)">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideSheetProtection()">Cancel</button>
        <button class="btn btn-danger" onclick="unprotectSheet()">Unprotect</button>
        <button class="btn btn-primary" onclick="protectSheet()">Protect</button>
      </div>
    </div>
  </div>

  <!-- Formula Auditing Modal -->
  <div class="modal-overlay" id="formulaAuditingModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3>Formula Auditing</h3>
        <button class="modal-close" onclick="hideFormulaAuditing()">&times;</button>
      </div>
      <div class="modal-body">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <button class="btn btn-secondary" onclick="tracePrecedents()">‚Üê Trace Precedents</button>
          <button class="btn btn-secondary" onclick="traceDependents()">‚Üí Trace Dependents</button>
          <button class="btn btn-secondary" onclick="clearTraceArrows()">‚úï Clear Arrows</button>
          <button class="btn btn-secondary" onclick="showFormulas()">fx Show Formulas</button>
          <button class="btn btn-secondary" onclick="evaluateFormula()">= Evaluate Formula</button>
          <button class="btn btn-secondary" onclick="checkErrors()">‚ö† Error Checking</button>
        </div>
        <div class="form-group">
          <label>Formula Analysis</label>
          <div id="formulaAnalysis" style="padding: 1rem; background: #f5f5f5; border-radius: 4px; min-height: 150px; max-height: 300px; overflow-y: auto;">
            <p style="color: #666;">Select a cell with a formula to analyze</p>
          </div>
        </div>
        <div class="form-group">
          <label>Watch Window</label>
          <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
            <input type="text" class="form-control" id="watchCell" placeholder="Cell to watch (e.g., A1)" style="flex: 1;">
            <button class="btn btn-secondary" onclick="addWatch()">Add Watch</button>
          </div>
          <div id="watchList" style="max-height: 100px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; padding: 0.5rem;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideFormulaAuditing()">Close</button>
      </div>
    </div>
  </div>

  <!-- Form Controls Modal -->
  <div class="modal-overlay" id="formControlsModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3>Insert Form Control</h3>
        <button class="modal-close" onclick="hideFormControls()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Control Type</label>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 1rem;">
            <button class="btn btn-secondary form-ctrl-type active" onclick="selectFormControlType('button')" data-type="button">üîò Button</button>
            <button class="btn btn-secondary form-ctrl-type" onclick="selectFormControlType('checkbox')" data-type="checkbox">‚òë Checkbox</button>
            <button class="btn btn-secondary form-ctrl-type" onclick="selectFormControlType('dropdown')" data-type="dropdown">‚ñº Dropdown</button>
            <button class="btn btn-secondary form-ctrl-type" onclick="selectFormControlType('spinner')" data-type="spinner">üî¢ Spinner</button>
            <button class="btn btn-secondary form-ctrl-type" onclick="selectFormControlType('slider')" data-type="slider">‚îÄ‚óã‚îÄ Slider</button>
            <button class="btn btn-secondary form-ctrl-type" onclick="selectFormControlType('radio')" data-type="radio">‚óâ Radio</button>
          </div>
        </div>
        <div class="form-group">
          <label>Label/Caption</label>
          <input type="text" class="form-control" id="formCtrlLabel" placeholder="Button text or label">
        </div>
        <div class="form-group">
          <label>Cell Link (stores the control's value)</label>
          <input type="text" class="form-control" id="formCtrlCellLink" placeholder="e.g., D1">
        </div>
        <div class="form-group" id="formCtrlRangeGroup" style="display: none;">
          <label>Input Range (for dropdown/radio)</label>
          <input type="text" class="form-control" id="formCtrlInputRange" placeholder="e.g., A1:A5">
        </div>
        <div class="form-group" id="formCtrlMinMaxGroup" style="display: none;">
          <label>Min/Max Values (for spinner/slider)</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
            <input type="number" class="form-control" id="formCtrlMin" placeholder="Min" value="0">
            <input type="number" class="form-control" id="formCtrlMax" placeholder="Max" value="100">
            <input type="number" class="form-control" id="formCtrlStep" placeholder="Step" value="1">
          </div>
        </div>
        <div class="form-group">
          <label>Position</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
            <input type="text" class="form-control" id="formCtrlPosition" placeholder="Cell (e.g., E2)" value="">
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideFormControls()">Cancel</button>
        <button class="btn btn-primary" onclick="insertFormControl()">Insert Control</button>
      </div>
    </div>
  </div>

  <!-- Cascading Dropdowns Modal -->
  <div class="modal-overlay" id="cascadingDropdownsModal">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h3>Cascading/Dependent Dropdowns</h3>
        <button class="modal-close" onclick="hideCascadingDropdowns()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: #666; margin-bottom: 1rem;">Create linked dropdowns where the second list depends on the first selection.</p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
          <div>
            <h4 style="margin-bottom: 0.5rem;">Primary Dropdown</h4>
            <div class="form-group">
              <label>Cell Location</label>
              <input type="text" class="form-control" id="cascadePrimaryCell" placeholder="e.g., A1">
            </div>
            <div class="form-group">
              <label>List Items (comma-separated)</label>
              <input type="text" class="form-control" id="cascadePrimaryItems" placeholder="e.g., Fruits, Vegetables, Meats">
            </div>
          </div>

          <div>
            <h4 style="margin-bottom: 0.5rem;">Dependent Dropdown</h4>
            <div class="form-group">
              <label>Cell Location</label>
              <input type="text" class="form-control" id="cascadeDependentCell" placeholder="e.g., B1">
            </div>
          </div>
        </div>

        <div style="margin-top: 1rem;">
          <h4 style="margin-bottom: 0.5rem;">Define Dependent Lists</h4>
          <p style="color: #666; font-size: 0.85rem; margin-bottom: 0.5rem;">For each primary option, define what items appear in the dependent dropdown.</p>
          <div id="cascadeDefinitions" style="max-height: 200px; overflow-y: auto;">
            <!-- Dynamically populated -->
          </div>
        </div>

        <div style="margin-top: 1rem; padding: 1rem; background: #f5f5f5; border-radius: 8px;">
          <h4 style="margin-bottom: 0.5rem;">Existing Cascading Lists</h4>
          <div id="existingCascadingLists" style="font-size: 0.9rem;">
            <span style="color: #999;">No cascading lists defined yet</span>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="previewCascadingDropdowns()">Preview</button>
        <button class="btn btn-primary" onclick="applyCascadingDropdowns()">Apply</button>
        <button class="btn btn-secondary" onclick="hideCascadingDropdowns()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Quick Analysis Modal -->
  <div class="modal-overlay" id="quickAnalysisModal">
    <div class="modal" style="max-width: 550px;">
      <div class="modal-header">
        <h3>Quick Analysis</h3>
        <button class="modal-close" onclick="hideQuickAnalysis()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="quick-analysis-tabs" style="display: flex; border-bottom: 1px solid #ddd; margin-bottom: 1rem;">
          <button class="qa-tab active" onclick="switchQATab('formatting')" data-tab="formatting">Formatting</button>
          <button class="qa-tab" onclick="switchQATab('charts')" data-tab="charts">Charts</button>
          <button class="qa-tab" onclick="switchQATab('totals')" data-tab="totals">Totals</button>
          <button class="qa-tab" onclick="switchQATab('tables')" data-tab="tables">Tables</button>
          <button class="qa-tab" onclick="switchQATab('sparklines')" data-tab="sparklines">Sparklines</button>
        </div>

        <div id="qaContent">
          <!-- Formatting tab content -->
          <div class="qa-panel" id="qa-formatting">
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
              <button class="qa-option" onclick="applyQuickFormat('data-bars')" title="Data Bars">
                <div style="height: 30px; background: linear-gradient(90deg, #5b9bd5 70%, transparent 70%);"></div>
                <span>Data Bars</span>
              </button>
              <button class="qa-option" onclick="applyQuickFormat('color-scale')" title="Color Scale">
                <div style="height: 30px; background: linear-gradient(90deg, #f8696b, #ffeb84, #63be7b);"></div>
                <span>Color Scale</span>
              </button>
              <button class="qa-option" onclick="applyQuickFormat('icon-set')" title="Icon Sets">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center; gap: 4px;">‚¨ÜÔ∏è ‚û°Ô∏è ‚¨áÔ∏è</div>
                <span>Icon Set</span>
              </button>
              <button class="qa-option" onclick="applyQuickFormat('greater-than')" title="Greater Than">
                <div style="height: 30px; background: #ffc7ce; display: flex; align-items: center; justify-content: center;">&gt; X</div>
                <span>Greater</span>
              </button>
              <button class="qa-option" onclick="applyQuickFormat('top-10')" title="Top 10%">
                <div style="height: 30px; background: #c6efce; display: flex; align-items: center; justify-content: center;">Top 10</div>
                <span>Top 10%</span>
              </button>
            </div>
          </div>

          <!-- Charts tab content -->
          <div class="qa-panel" id="qa-charts" style="display: none;">
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
              <button class="qa-option" onclick="insertQuickChart('bar')" title="Bar Chart">
                <div style="height: 30px; display: flex; align-items: flex-end; justify-content: center; gap: 2px;">
                  <div style="width: 8px; height: 20px; background: #5b9bd5;"></div>
                  <div style="width: 8px; height: 25px; background: #5b9bd5;"></div>
                  <div style="width: 8px; height: 15px; background: #5b9bd5;"></div>
                </div>
                <span>Bar</span>
              </button>
              <button class="qa-option" onclick="insertQuickChart('line')" title="Line Chart">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">üìà</div>
                <span>Line</span>
              </button>
              <button class="qa-option" onclick="insertQuickChart('pie')" title="Pie Chart">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">ü•ß</div>
                <span>Pie</span>
              </button>
              <button class="qa-option" onclick="insertQuickChart('scatter')" title="Scatter">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">‚ö¨</div>
                <span>Scatter</span>
              </button>
              <button class="qa-option" onclick="insertQuickChart('area')" title="Area">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">‚ñ≤</div>
                <span>Area</span>
              </button>
            </div>
          </div>

          <!-- Totals tab content -->
          <div class="qa-panel" id="qa-totals" style="display: none;">
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem;">
              <button class="qa-option" onclick="insertQuickTotal('sum')" title="Sum">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold;">Œ£</div>
                <span>Sum</span>
              </button>
              <button class="qa-option" onclick="insertQuickTotal('average')" title="Average">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">xÃÑ</div>
                <span>Average</span>
              </button>
              <button class="qa-option" onclick="insertQuickTotal('count')" title="Count">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">#</div>
                <span>Count</span>
              </button>
              <button class="qa-option" onclick="insertQuickTotal('max')" title="Max">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">‚Üë</div>
                <span>Max</span>
              </button>
              <button class="qa-option" onclick="insertQuickTotal('min')" title="Min">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">‚Üì</div>
                <span>Min</span>
              </button>
            </div>
          </div>

          <!-- Tables tab content -->
          <div class="qa-panel" id="qa-tables" style="display: none;">
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
              <button class="qa-option" onclick="insertQuickTable('table')" title="Table">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">‚äû</div>
                <span>Table</span>
              </button>
              <button class="qa-option" onclick="insertQuickTable('pivot')" title="Pivot Table">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">üìã</div>
                <span>Pivot</span>
              </button>
              <button class="qa-option" onclick="insertQuickTable('slicer')" title="Slicer">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">üî≤</div>
                <span>Slicer</span>
              </button>
            </div>
          </div>

          <!-- Sparklines tab content -->
          <div class="qa-panel" id="qa-sparklines" style="display: none;">
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
              <button class="qa-option" onclick="insertQuickSparkline('line')" title="Line Sparkline">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center;">„Ä∞Ô∏è</div>
                <span>Line</span>
              </button>
              <button class="qa-option" onclick="insertQuickSparkline('column')" title="Column Sparkline">
                <div style="height: 30px; display: flex; align-items: flex-end; justify-content: center; gap: 1px;">
                  <div style="width: 4px; height: 12px; background: #5b9bd5;"></div>
                  <div style="width: 4px; height: 18px; background: #5b9bd5;"></div>
                  <div style="width: 4px; height: 8px; background: #5b9bd5;"></div>
                  <div style="width: 4px; height: 22px; background: #5b9bd5;"></div>
                </div>
                <span>Column</span>
              </button>
              <button class="qa-option" onclick="insertQuickSparkline('winloss')" title="Win/Loss">
                <div style="height: 30px; display: flex; align-items: center; justify-content: center; gap: 1px;">
                  <div style="width: 4px; height: 10px; background: #63be7b;"></div>
                  <div style="width: 4px; height: 10px; background: #f8696b; margin-top: 10px;"></div>
                  <div style="width: 4px; height: 10px; background: #63be7b;"></div>
                </div>
                <span>Win/Loss</span>
              </button>
            </div>
          </div>
        </div>

        <div style="margin-top: 1rem; padding: 0.75rem; background: #e8f0fe; border-radius: 4px; font-size: 0.85rem;">
          <strong>Selection:</strong> <span id="qaSelectionInfo">Select cells to analyze</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Paste Special Modal -->
  <div class="modal-overlay" id="pasteSpecialModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Paste Special</h3>
        <button class="modal-close" onclick="hidePasteSpecial()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Paste:</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
            <label><input type="radio" name="pasteType" value="all" checked> All</label>
            <label><input type="radio" name="pasteType" value="values"> Values only</label>
            <label><input type="radio" name="pasteType" value="formulas"> Formulas only</label>
            <label><input type="radio" name="pasteType" value="formats"> Formats only</label>
            <label><input type="radio" name="pasteType" value="comments"> Comments only</label>
            <label><input type="radio" name="pasteType" value="validation"> Validation only</label>
          </div>
        </div>
        <div class="form-group">
          <label>Operation:</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
            <label><input type="radio" name="pasteOp" value="none" checked> None</label>
            <label><input type="radio" name="pasteOp" value="add"> Add</label>
            <label><input type="radio" name="pasteOp" value="subtract"> Subtract</label>
            <label><input type="radio" name="pasteOp" value="multiply"> Multiply</label>
            <label><input type="radio" name="pasteOp" value="divide"> Divide</label>
          </div>
        </div>
        <div class="form-group">
          <label><input type="checkbox" id="pasteTranspose"> Transpose</label>
          <label style="margin-left: 1rem;"><input type="checkbox" id="pasteSkipBlanks"> Skip blanks</label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hidePasteSpecial()">Cancel</button>
        <button class="btn btn-primary" onclick="executePasteSpecial()">OK</button>
      </div>
    </div>
  </div>

  <!-- Insert Hyperlink Modal -->
  <div class="modal-overlay" id="hyperlinkModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Insert Hyperlink</h3>
        <button class="modal-close" onclick="hideInsertHyperlink()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Link to:</label>
          <select class="form-control" id="hyperlinkType" onchange="updateHyperlinkOptions()">
            <option value="url">Web Page or File</option>
            <option value="cell">Place in This Document</option>
            <option value="email">Email Address</option>
          </select>
        </div>
        <div class="form-group" id="hyperlinkUrlGroup">
          <label>Address:</label>
          <input type="text" class="form-control" id="hyperlinkUrl" placeholder="https://example.com">
        </div>
        <div class="form-group" id="hyperlinkCellGroup" style="display: none;">
          <label>Cell Reference:</label>
          <input type="text" class="form-control" id="hyperlinkCell" placeholder="e.g., A1 or Sheet2!B5">
        </div>
        <div class="form-group" id="hyperlinkEmailGroup" style="display: none;">
          <label>Email Address:</label>
          <input type="email" class="form-control" id="hyperlinkEmail" placeholder="email@example.com">
          <label style="margin-top: 0.5rem;">Subject:</label>
          <input type="text" class="form-control" id="hyperlinkSubject" placeholder="Optional subject">
        </div>
        <div class="form-group">
          <label>Text to Display:</label>
          <input type="text" class="form-control" id="hyperlinkText" placeholder="Click here">
        </div>
        <div class="form-group">
          <label>ScreenTip:</label>
          <input type="text" class="form-control" id="hyperlinkTooltip" placeholder="Optional tooltip text">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="removeHyperlink()">Remove Link</button>
        <button class="btn btn-secondary" onclick="hideInsertHyperlink()">Cancel</button>
        <button class="btn btn-primary" onclick="insertHyperlink()">OK</button>
      </div>
    </div>
  </div>

  <!-- Text to Columns Modal -->
  <div class="modal-overlay" id="textToColumnsModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>Text to Columns</h3>
        <button class="modal-close" onclick="hideTextToColumns()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--secondary); margin-bottom: 1rem;">Split text in selected cells into multiple columns based on a delimiter.</p>
        <div class="form-group">
          <label>Delimiter Type:</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-top: 0.5rem;">
            <label><input type="radio" name="ttcDelimiter" value="comma" checked> Comma</label>
            <label><input type="radio" name="ttcDelimiter" value="tab"> Tab</label>
            <label><input type="radio" name="ttcDelimiter" value="semicolon"> Semicolon</label>
            <label><input type="radio" name="ttcDelimiter" value="space"> Space</label>
            <label><input type="radio" name="ttcDelimiter" value="pipe"> Pipe (|)</label>
            <label><input type="radio" name="ttcDelimiter" value="custom"> Custom</label>
          </div>
        </div>
        <div class="form-group" id="customDelimiterGroup" style="display: none;">
          <label>Custom Delimiter:</label>
          <input type="text" class="form-control" id="customDelimiter" maxlength="5" placeholder="Enter delimiter">
        </div>
        <div class="form-group">
          <label><input type="checkbox" id="ttcTrimSpaces" checked> Trim whitespace from results</label>
        </div>
        <div class="form-group">
          <label>Preview (first row):</label>
          <div id="ttcPreview" style="padding: 0.5rem; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 0.85rem; min-height: 30px;">
            Select cells to preview
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideTextToColumns()">Cancel</button>
        <button class="btn btn-primary" onclick="executeTextToColumns()">Convert</button>
      </div>
    </div>
  </div>

  <!-- Fill Series Modal -->
  <div class="modal-overlay" id="fillSeriesModal">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header">
        <h3>üìà Fill Series</h3>
        <button class="modal-close" onclick="hideFillSeries()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Series Type:</label>
          <select class="form-control" id="seriesType" onchange="updateSeriesOptions()">
            <option value="linear">Linear (1, 2, 3, ...)</option>
            <option value="growth">Growth (1, 2, 4, 8, ...)</option>
            <option value="date">Date Series</option>
            <option value="autofill">AutoFill (Pattern Detection)</option>
          </select>
        </div>
        <div id="linearOptions">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div class="form-group">
              <label>Step Value:</label>
              <input type="number" class="form-control" id="seriesStep" value="1">
            </div>
            <div class="form-group">
              <label>Stop Value (optional):</label>
              <input type="number" class="form-control" id="seriesStop" placeholder="Auto">
            </div>
          </div>
        </div>
        <div id="dateOptions" style="display: none;">
          <div class="form-group">
            <label>Date Unit:</label>
            <select class="form-control" id="dateUnit">
              <option value="day">Day</option>
              <option value="weekday">Weekday (skip weekends)</option>
              <option value="week">Week</option>
              <option value="month">Month</option>
              <option value="year">Year</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Direction:</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
            <label><input type="radio" name="fillDirection" value="down" checked> Down</label>
            <label><input type="radio" name="fillDirection" value="right"> Right</label>
          </div>
        </div>
        <div class="form-group">
          <label>Number of Cells to Fill:</label>
          <input type="number" class="form-control" id="fillCount" value="10" min="1" max="100">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideFillSeries()">Cancel</button>
        <button class="btn btn-primary" onclick="executeFillSeries()">Fill</button>
      </div>
    </div>
  </div>

  <!-- Go To Cell Modal -->
  <div class="modal-overlay" id="goToCellModal">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>‚åñ Go To Cell</h3>
        <button class="modal-close" onclick="hideGoToCell()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Cell Reference:</label>
          <input type="text" class="form-control" id="goToCellRef" placeholder="e.g., A1, B10, Z100" autofocus style="font-size: 16px; text-transform: uppercase;">
          <small style="color: #666;">Enter a cell reference like A1, B10, or AA50</small>
        </div>
        <div class="form-group">
          <label>Or go to Named Range:</label>
          <select class="form-control" id="goToNamedRange" onchange="selectNamedRangeForGoTo()">
            <option value="">-- Select Named Range --</option>
          </select>
        </div>
        <div class="form-group">
          <label>Recent Locations:</label>
          <div id="recentLocations" style="max-height: 120px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem;">
            <div style="color: #999; font-size: 12px;">No recent locations</div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideGoToCell()">Cancel</button>
        <button class="btn btn-primary" onclick="goToCell()">Go</button>
      </div>
    </div>
  </div>

  <!-- Stock Images Modal -->
  <div class="modal-overlay" id="stockImagesModal">
    <div class="modal" style="max-width: 800px; max-height: 90vh;">
      <div class="modal-header">
        <h3>üåê Stock Images</h3>
        <button class="modal-close" onclick="hideStockImages()">&times;</button>
      </div>
      <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
        <div class="form-group">
          <label>Search for images:</label>
          <div style="display: flex; gap: 0.5rem;">
            <input type="text" class="form-control" id="stockImageSearch" placeholder="e.g., business, technology, nature..." style="flex: 1;" onkeypress="if(event.key==='Enter') searchStockImages()">
            <button class="btn btn-primary" onclick="searchStockImages()">Search</button>
          </div>
        </div>
        <div class="form-group">
          <label>Quick Categories:</label>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('business')">Business</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('finance')">Finance</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('technology')">Technology</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('data')">Data</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('office')">Office</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('charts')">Charts</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('teamwork')">Teamwork</button>
            <button class="btn btn-secondary" style="font-size: 12px;" onclick="searchStockCategory('nature')">Nature</button>
          </div>
        </div>
        <div id="stockImageResults" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-top: 1rem;">
          <div style="grid-column: span 4; text-align: center; color: #666; padding: 2rem;">
            Search for images above to get started
          </div>
        </div>
        <div id="stockImagePreview" style="display: none; margin-top: 1rem; padding: 1rem; background: #f5f5f5; border-radius: 8px;">
          <h4 style="margin: 0 0 0.5rem 0;">Preview</h4>
          <div style="display: flex; gap: 1rem; align-items: flex-start;">
            <img id="stockPreviewImg" src="" style="max-width: 300px; max-height: 200px; border-radius: 4px;">
            <div style="flex: 1;">
              <div class="form-group" style="margin-bottom: 0.5rem;">
                <label>Size:</label>
                <select class="form-control" id="stockImageSize" style="width: auto;">
                  <option value="small">Small (200px)</option>
                  <option value="medium" selected>Medium (400px)</option>
                  <option value="large">Large (600px)</option>
                </select>
              </div>
              <div class="form-group" style="margin-bottom: 0.5rem;">
                <label>Insert as:</label>
                <select class="form-control" id="stockImageInsertType" style="width: auto;">
                  <option value="cell">Image in Cell</option>
                  <option value="float">Floating Image</option>
                </select>
              </div>
              <button class="btn btn-success" onclick="insertStockImage()">Insert Image</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- QR Code Generator Modal -->
  <div class="modal-overlay" id="qrCodeModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>‚ñ£ QR Code Generator</h3>
        <button class="modal-close" onclick="hideQRCodeGenerator()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label style="font-weight: 600;">Content Type</label>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
            <button class="btn btn-secondary qr-type-btn active" onclick="selectQRType('url')" data-type="url">üîó URL</button>
            <button class="btn btn-secondary qr-type-btn" onclick="selectQRType('text')" data-type="text">üìù Text</button>
            <button class="btn btn-secondary qr-type-btn" onclick="selectQRType('email')" data-type="email">üìß Email</button>
            <button class="btn btn-secondary qr-type-btn" onclick="selectQRType('phone')" data-type="phone">üìû Phone</button>
            <button class="btn btn-secondary qr-type-btn" onclick="selectQRType('cell')" data-type="cell">üìä Cell Value</button>
          </div>
        </div>

        <div id="qrUrlPanel" class="qr-input-panel">
          <div class="form-group">
            <label>URL:</label>
            <input type="url" class="form-control" id="qrUrl" placeholder="https://example.com" oninput="generateQRPreview()">
          </div>
        </div>

        <div id="qrTextPanel" class="qr-input-panel" style="display: none;">
          <div class="form-group">
            <label>Text Content:</label>
            <textarea class="form-control" id="qrText" rows="3" placeholder="Enter any text..." oninput="generateQRPreview()"></textarea>
          </div>
        </div>

        <div id="qrEmailPanel" class="qr-input-panel" style="display: none;">
          <div class="form-group">
            <label>Email Address:</label>
            <input type="email" class="form-control" id="qrEmail" placeholder="email@example.com" oninput="generateQRPreview()">
          </div>
        </div>

        <div id="qrPhonePanel" class="qr-input-panel" style="display: none;">
          <div class="form-group">
            <label>Phone Number:</label>
            <input type="tel" class="form-control" id="qrPhone" placeholder="+1234567890" oninput="generateQRPreview()">
          </div>
        </div>

        <div id="qrCellPanel" class="qr-input-panel" style="display: none;">
          <div class="form-group">
            <label>Generate QR from selected cell value</label>
            <p style="color: #666; font-size: 0.9rem;">Select a cell first, then the QR code will use that cell's content.</p>
            <div id="qrCellValue" style="padding: 0.5rem; background: #f5f5f5; border-radius: 4px; margin-top: 0.5rem;">
              <span style="color: #999;">No cell selected</span>
            </div>
          </div>
        </div>

        <div class="form-group" style="margin-top: 1rem;">
          <label style="font-weight: 600;">QR Code Size:</label>
          <select class="form-control" id="qrSize" onchange="generateQRPreview()" style="width: auto;">
            <option value="100">Small (100px)</option>
            <option value="150" selected>Medium (150px)</option>
            <option value="200">Large (200px)</option>
          </select>
        </div>

        <div style="margin-top: 1rem; text-align: center;">
          <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Preview:</label>
          <div id="qrPreview" style="display: inline-block; padding: 1rem; background: white; border: 1px solid #ddd; border-radius: 8px; min-height: 150px; min-width: 150px;">
            <span style="color: #999;">Enter content to generate QR code</span>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideQRCodeGenerator()">Cancel</button>
        <button class="btn btn-primary" onclick="insertQRCode()">Insert QR Code</button>
      </div>
    </div>
  </div>

  <!-- Version History Modal -->
  <div class="modal-overlay" id="versionHistoryModal">
    <div class="modal" style="max-width: 600px; max-height: 80vh;">
      <div class="modal-header">
        <h3>üìú Version History</h3>
        <button class="modal-close" onclick="hideVersionHistory()">&times;</button>
      </div>
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border);">
          <div>
            <strong>Auto-Save:</strong>
            <span id="autoSaveStatus" style="margin-left: 0.5rem; color: #d93025;">Disabled</span>
          </div>
          <label style="font-size: 0.9rem;">
            <input type="checkbox" id="autoSaveCheckbox" onchange="toggleAutoSaveFromModal()"> Enable
          </label>
        </div>
        <div style="margin-bottom: 1rem;">
          <label>Interval:</label>
          <select class="form-control" id="autoSaveInterval" style="width: auto; display: inline-block; margin-left: 0.5rem;" onchange="updateAutoSaveInterval()">
            <option value="30000">30 sec</option>
            <option value="60000" selected>1 min</option>
            <option value="120000">2 min</option>
            <option value="300000">5 min</option>
          </select>
          <button class="btn btn-secondary" onclick="createManualVersion()" style="margin-left: 1rem;">üì∏ Save Now</button>
        </div>
        <h4 style="margin-bottom: 0.5rem;">Saved Versions</h4>
        <div id="versionList" style="border: 1px solid var(--border); border-radius: 8px; overflow: hidden;">
          <div style="padding: 1rem; text-align: center; color: #666;">No versions saved yet</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="clearVersionHistory()">üóë Clear All</button>
        <button class="btn btn-primary" onclick="hideVersionHistory()">Close</button>
      </div>
    </div>
  </div>

  <!-- Recent Spreadsheets Modal -->
  <div class="modal-overlay" id="recentSpreadsheetsModal">
    <div class="modal" style="max-width: 650px; max-height: 80vh;">
      <div class="modal-header">
        <h3>üìÇ Recent Spreadsheets</h3>
        <button class="modal-close" onclick="hideRecentSpreadsheets()">&times;</button>
      </div>
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
          <input type="text" class="form-control" id="recentSearchInput" placeholder="Search spreadsheets..." style="flex: 1;" oninput="filterRecentSpreadsheets()">
        </div>
        <div id="recentSpreadsheetsList" style="border: 1px solid var(--border); border-radius: 8px; overflow: hidden;">
          <div style="padding: 2rem; text-align: center; color: #666;">No recent spreadsheets</div>
        </div>
        <div style="margin-top: 1rem; display: flex; justify-content: space-between;">
          <span id="recentSpreadCount" style="color: #666; font-size: 0.9rem;">0 spreadsheets</span>
          <button class="btn btn-secondary" onclick="clearRecentSpreadsheets()">üóë Clear</button>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideRecentSpreadsheets()">Close</button>
      </div>
    </div>
  </div>

  <!-- Find & Replace Modal -->
  <div class="modal-overlay" id="findReplaceModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3>üîç Find & Replace</h3>
        <button class="modal-close" onclick="hideFindReplace()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Find:</label>
          <input type="text" class="form-control" id="findInput" placeholder="Text to find..." onkeyup="if(event.key==='Enter')findInCells()">
        </div>
        <div class="form-group">
          <label>Replace with:</label>
          <input type="text" class="form-control" id="replaceInput" placeholder="Replace with...">
        </div>
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
          <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
            <input type="checkbox" id="findMatchCase"> Match case
          </label>
          <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
            <input type="checkbox" id="findWholeCell"> Match entire cell
          </label>
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
          <label style="display: flex; align-items: center; gap: 0.5rem;">
            Search in:
            <select class="form-control" id="findScope" style="width: auto;">
              <option value="all">All Cells</option>
              <option value="selection">Selection Only</option>
              <option value="values">Values Only</option>
              <option value="formulas">Formulas Only</option>
            </select>
          </label>
        </div>
        <div id="findResults" style="padding: 0.75rem; background: #f5f5f5; border-radius: 4px; margin-bottom: 1rem; min-height: 40px;">
          <span style="color: #666;">Enter text to search</span>
        </div>
        <div id="findMatchList" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; display: none;">
        </div>
      </div>
      <div class="modal-footer" style="flex-wrap: wrap; gap: 0.5rem;">
        <button class="btn btn-secondary" onclick="findInCells()">üîç Find All</button>
        <button class="btn btn-secondary" onclick="findNextCell()">Find Next</button>
        <button class="btn btn-secondary" onclick="findPrevCell()">Find Previous</button>
        <button class="btn btn-primary" onclick="replaceInCell()">Replace</button>
        <button class="btn btn-primary" onclick="replaceAllInCells()">Replace All</button>
      </div>
    </div>
  </div>

  <!-- Hidden file input for import -->
  <input type="file" id="fileImport" accept=".njcalc,.json" style="display: none;" onchange="handleFileImport(event)">

  <!-- Formula Builder Modal -->
  <div class="modal-overlay" id="formulaBuilderModal">
    <div class="modal" style="max-width: 700px; max-height: 85vh;">
      <div class="modal-header">
        <h3>ùëìùë• Insert Function</h3>
        <button class="modal-close" onclick="hideFormulaBuilder()">&times;</button>
      </div>
      <div class="modal-body" style="display: flex; gap: 1rem; height: 450px;">
        <!-- Left Panel - Categories and Functions -->
        <div style="flex: 1; display: flex; flex-direction: column; gap: 0.5rem;">
          <div>
            <label style="font-weight: 500;">Search for a function:</label>
            <input type="text" class="form-control" id="functionSearch" placeholder="Type to search..." oninput="filterFunctions()">
          </div>
          <div>
            <label style="font-weight: 500;">Or select a category:</label>
            <select class="form-control" id="functionCategory" onchange="filterFunctionsByCategory()">
              <option value="all">All Functions</option>
              <option value="math">Math & Trig</option>
              <option value="statistical">Statistical</option>
              <option value="text">Text</option>
              <option value="logical">Logical</option>
              <option value="lookup">Lookup & Reference</option>
              <option value="date">Date & Time</option>
              <option value="financial">Financial</option>
              <option value="info">Information</option>
            </select>
          </div>
          <div style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
            <label style="font-weight: 500;">Select a function:</label>
            <div id="functionList" style="flex: 1; overflow-y: auto; border: 1px solid var(--border); border-radius: 4px; background: white;"></div>
          </div>
        </div>
        <!-- Right Panel - Function Details -->
        <div style="flex: 1; display: flex; flex-direction: column; gap: 0.5rem;">
          <div id="functionDetails" style="flex: 1; padding: 1rem; border: 1px solid var(--border); border-radius: 4px; background: #f9f9f9; overflow-y: auto;">
            <p style="color: #666; text-align: center; margin-top: 2rem;">Select a function to see its description and syntax</p>
          </div>
          <div id="functionArguments" style="display: none;">
            <label style="font-weight: 500;">Function Arguments:</label>
            <div id="argInputs" style="max-height: 150px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="hideFormulaBuilder()">Cancel</button>
        <button class="btn btn-primary" onclick="insertBuiltFormula()" id="insertFormulaBtn" disabled>Insert Function</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <!-- Error Tooltip -->
  <div class="error-tooltip" id="errorTooltip">
    <div class="error-tooltip-header">
      <div class="error-tooltip-icon">‚ö†</div>
      <span id="errorTooltipTitle">#ERROR!</span>
    </div>
    <div class="error-tooltip-desc" id="errorTooltipDesc">Error description</div>
    <div class="error-tooltip-fix" id="errorTooltipFix"><strong>Tip:</strong> How to fix</div>
  </div>

  <!-- Mini Chart Tooltip -->
  <div class="mini-chart-tooltip" id="miniChartTooltip">
    <div class="mini-chart-tooltip-header">
      <span id="miniChartCell">A1</span>
      <span id="miniChartRange">Row Data</span>
    </div>
    <div class="mini-chart-tooltip-value" id="miniChartValue">100</div>
    <div class="mini-chart-tooltip-chart" id="miniChartBars"></div>
    <div class="mini-chart-tooltip-stats" id="miniChartStats"></div>
  </div>

  <!-- Cell Note Tooltip -->
  <div class="cell-note-tooltip" id="cellNoteTooltip">
    <div class="cell-note-tooltip-header">
      <span>üìù</span>
      <span id="cellNoteCell">A1</span>
    </div>
    <div class="cell-note-tooltip-content" id="cellNoteContent"></div>
    <div class="cell-note-tooltip-footer" id="cellNoteFooter"></div>
  </div>

  <!-- Quick Formula Bar -->
  <div class="quick-formula-bar" id="quickFormulaBar">
    <button class="quick-formula-btn" onclick="quickFormula('SUM')" title="Sum selected cells">
      <span class="quick-formula-btn-icon">Œ£</span> SUM
    </button>
    <button class="quick-formula-btn" onclick="quickFormula('AVERAGE')" title="Average of selected cells">
      <span class="quick-formula-btn-icon">xÃÑ</span> AVG
    </button>
    <button class="quick-formula-btn" onclick="quickFormula('COUNT')" title="Count selected cells">
      <span class="quick-formula-btn-icon">#</span> COUNT
    </button>
    <button class="quick-formula-btn" onclick="quickFormula('MIN')" title="Minimum value">
      <span class="quick-formula-btn-icon">‚Üì</span> MIN
    </button>
    <button class="quick-formula-btn" onclick="quickFormula('MAX')" title="Maximum value">
      <span class="quick-formula-btn-icon">‚Üë</span> MAX
    </button>
    <div class="quick-formula-divider"></div>
    <button class="quick-formula-btn primary" onclick="showFormulaPalette()" title="More formulas (F2)">
      <span class="quick-formula-btn-icon">fx</span> More
    </button>
    <div class="quick-formula-divider"></div>
    <div class="quick-formula-result" id="quickFormulaResult" title="Live result">-</div>
  </div>

  <!-- Formula Palette -->
  <div class="formula-palette" id="formulaPalette">
    <div class="formula-palette-header">
      <h3>üìä Formula Library</h3>
      <button class="formula-palette-close" onclick="hideFormulaPalette()">&times;</button>
    </div>
    <div class="formula-palette-search">
      <input type="text" id="formulaSearchInput" placeholder="Search formulas..." oninput="filterFormulas(this.value)">
    </div>
    <div class="formula-palette-body" id="formulaPaletteBody">
      <!-- Math & Trig -->
      <div class="formula-category" data-category="math">
        <div class="formula-category-title">Math & Trig</div>
        <div class="formula-list">
          <div class="formula-item" onclick="insertFormula('SUM')">
            <span class="formula-item-name">SUM</span>
            <span class="formula-item-desc">Add numbers</span>
          </div>
          <div class="formula-item" onclick="insertFormula('AVERAGE')">
            <span class="formula-item-name">AVERAGE</span>
            <span class="formula-item-desc">Calculate mean</span>
          </div>
          <div class="formula-item" onclick="insertFormula('ROUND')">
            <span class="formula-item-name">ROUND</span>
            <span class="formula-item-desc">Round number</span>
          </div>
          <div class="formula-item" onclick="insertFormula('ABS')">
            <span class="formula-item-name">ABS</span>
            <span class="formula-item-desc">Absolute value</span>
          </div>
          <div class="formula-item" onclick="insertFormula('SQRT')">
            <span class="formula-item-name">SQRT</span>
            <span class="formula-item-desc">Square root</span>
          </div>
          <div class="formula-item" onclick="insertFormula('POWER')">
            <span class="formula-item-name">POWER</span>
            <span class="formula-item-desc">Raise to power</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MOD')">
            <span class="formula-item-name">MOD</span>
            <span class="formula-item-desc">Remainder</span>
          </div>
          <div class="formula-item" onclick="insertFormula('CEILING')">
            <span class="formula-item-name">CEILING</span>
            <span class="formula-item-desc">Round up</span>
          </div>
          <div class="formula-item" onclick="insertFormula('FLOOR')">
            <span class="formula-item-name">FLOOR</span>
            <span class="formula-item-desc">Round down</span>
          </div>
        </div>
      </div>
      <!-- Statistical -->
      <div class="formula-category" data-category="stats">
        <div class="formula-category-title">Statistical</div>
        <div class="formula-list">
          <div class="formula-item" onclick="insertFormula('COUNT')">
            <span class="formula-item-name">COUNT</span>
            <span class="formula-item-desc">Count numbers</span>
          </div>
          <div class="formula-item" onclick="insertFormula('COUNTA')">
            <span class="formula-item-name">COUNTA</span>
            <span class="formula-item-desc">Count non-empty</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MIN')">
            <span class="formula-item-name">MIN</span>
            <span class="formula-item-desc">Minimum value</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MAX')">
            <span class="formula-item-name">MAX</span>
            <span class="formula-item-desc">Maximum value</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MEDIAN')">
            <span class="formula-item-name">MEDIAN</span>
            <span class="formula-item-desc">Middle value</span>
          </div>
          <div class="formula-item" onclick="insertFormula('STDEV')">
            <span class="formula-item-name">STDEV</span>
            <span class="formula-item-desc">Std deviation</span>
          </div>
        </div>
      </div>
      <!-- Logical -->
      <div class="formula-category" data-category="logic">
        <div class="formula-category-title">Logical</div>
        <div class="formula-list">
          <div class="formula-item" onclick="insertFormula('IF')">
            <span class="formula-item-name">IF</span>
            <span class="formula-item-desc">Conditional</span>
          </div>
          <div class="formula-item" onclick="insertFormula('AND')">
            <span class="formula-item-name">AND</span>
            <span class="formula-item-desc">All conditions true</span>
          </div>
          <div class="formula-item" onclick="insertFormula('OR')">
            <span class="formula-item-name">OR</span>
            <span class="formula-item-desc">Any condition true</span>
          </div>
          <div class="formula-item" onclick="insertFormula('NOT')">
            <span class="formula-item-name">NOT</span>
            <span class="formula-item-desc">Reverse logic</span>
          </div>
          <div class="formula-item" onclick="insertFormula('IFERROR')">
            <span class="formula-item-name">IFERROR</span>
            <span class="formula-item-desc">Handle errors</span>
          </div>
        </div>
      </div>
      <!-- Text -->
      <div class="formula-category" data-category="text">
        <div class="formula-category-title">Text</div>
        <div class="formula-list">
          <div class="formula-item" onclick="insertFormula('CONCAT')">
            <span class="formula-item-name">CONCAT</span>
            <span class="formula-item-desc">Join text</span>
          </div>
          <div class="formula-item" onclick="insertFormula('LEFT')">
            <span class="formula-item-name">LEFT</span>
            <span class="formula-item-desc">Left characters</span>
          </div>
          <div class="formula-item" onclick="insertFormula('RIGHT')">
            <span class="formula-item-name">RIGHT</span>
            <span class="formula-item-desc">Right characters</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MID')">
            <span class="formula-item-name">MID</span>
            <span class="formula-item-desc">Extract text</span>
          </div>
          <div class="formula-item" onclick="insertFormula('LEN')">
            <span class="formula-item-name">LEN</span>
            <span class="formula-item-desc">Text length</span>
          </div>
          <div class="formula-item" onclick="insertFormula('UPPER')">
            <span class="formula-item-name">UPPER</span>
            <span class="formula-item-desc">Uppercase</span>
          </div>
          <div class="formula-item" onclick="insertFormula('LOWER')">
            <span class="formula-item-name">LOWER</span>
            <span class="formula-item-desc">Lowercase</span>
          </div>
          <div class="formula-item" onclick="insertFormula('TRIM')">
            <span class="formula-item-name">TRIM</span>
            <span class="formula-item-desc">Remove spaces</span>
          </div>
        </div>
      </div>
      <!-- Lookup -->
      <div class="formula-category" data-category="lookup">
        <div class="formula-category-title">Lookup & Reference</div>
        <div class="formula-list">
          <div class="formula-item" onclick="insertFormula('VLOOKUP')">
            <span class="formula-item-name">VLOOKUP</span>
            <span class="formula-item-desc">Vertical lookup</span>
          </div>
          <div class="formula-item" onclick="insertFormula('HLOOKUP')">
            <span class="formula-item-name">HLOOKUP</span>
            <span class="formula-item-desc">Horizontal lookup</span>
          </div>
          <div class="formula-item" onclick="insertFormula('INDEX')">
            <span class="formula-item-name">INDEX</span>
            <span class="formula-item-desc">Get value at index</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MATCH')">
            <span class="formula-item-name">MATCH</span>
            <span class="formula-item-desc">Find position</span>
          </div>
        </div>
      </div>
      <!-- Date & Time -->
      <div class="formula-category" data-category="date">
        <div class="formula-category-title">Date & Time</div>
        <div class="formula-list">
          <div class="formula-item" onclick="insertFormula('TODAY')">
            <span class="formula-item-name">TODAY</span>
            <span class="formula-item-desc">Current date</span>
          </div>
          <div class="formula-item" onclick="insertFormula('NOW')">
            <span class="formula-item-name">NOW</span>
            <span class="formula-item-desc">Current datetime</span>
          </div>
          <div class="formula-item" onclick="insertFormula('DATE')">
            <span class="formula-item-name">DATE</span>
            <span class="formula-item-desc">Create date</span>
          </div>
          <div class="formula-item" onclick="insertFormula('YEAR')">
            <span class="formula-item-name">YEAR</span>
            <span class="formula-item-desc">Extract year</span>
          </div>
          <div class="formula-item" onclick="insertFormula('MONTH')">
            <span class="formula-item-name">MONTH</span>
            <span class="formula-item-desc">Extract month</span>
          </div>
          <div class="formula-item" onclick="insertFormula('DAY')">
            <span class="formula-item-name">DAY</span>
            <span class="formula-item-desc">Extract day</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Formula Helper Popup -->
  <div class="formula-helper-popup" id="formulaHelperPopup">
    <div class="formula-helper-title">
      <span id="formulaHelperIcon">fx</span>
      <span id="formulaHelperName">SUM</span>
    </div>
    <div class="formula-helper-syntax" id="formulaHelperSyntax">=SUM(number1, number2, ...)</div>
    <div class="formula-helper-desc" id="formulaHelperDesc">Adds all the numbers in a range of cells.</div>
    <div class="formula-helper-example">
      <div class="formula-helper-example-title">Example:</div>
      <div class="formula-helper-example-code" id="formulaHelperExample">=SUM(A1:A10)</div>
    </div>
  </div>

  <script>
    // Spreadsheet configuration
    const ROWS = 100;
    const COLS = 26;
    const data = {};
    const formulas = {};
    const formatting = {};
    let selectedCell = null;
    let selectedRange = [];
    let filterActive = false;
    let macros = JSON.parse(localStorage.getItem('ninjaCalcMacros') || '{}');
    let currentDocId = null;
    const STORAGE_KEY = 'ninjacalc_spreadsheets';

    // New features state
    let frozenRow = 0;
    let frozenCol = 0;
    let hiddenRows = new Set();
    let hiddenCols = new Set();
    let cellComments = {};
    let dataValidation = {};
    let namedRanges = {};

    // Undo/Redo state
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO = 50;

    // File Menu
    function toggleFileMenu() {
      const menu = document.getElementById('fileMenu');
      menu.classList.toggle('show');
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.dropdown')) {
        document.getElementById('fileMenu')?.classList.remove('show');
      }
    });

    // Get/Save documents
    function getSavedDocs() {
      const docs = localStorage.getItem(STORAGE_KEY);
      return docs ? JSON.parse(docs) : {};
    }

    function saveDocs(docs) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(docs));
    }

    // Undo/Redo functionality
    function saveUndoState() {
      const state = {
        data: JSON.parse(JSON.stringify(data)),
        formulas: JSON.parse(JSON.stringify(formulas)),
        formatting: JSON.parse(JSON.stringify(formatting))
      };
      undoStack.push(JSON.stringify(state));
      if (undoStack.length > MAX_UNDO) {
        undoStack.shift();
      }
      redoStack = []; // Clear redo stack on new action
      updateUndoRedoButtons();
    }

    function undo() {
      if (undoStack.length === 0) {
        showToast('Nothing to undo', 'warning');
        return;
      }

      // Save current state to redo stack
      const currentState = {
        data: JSON.parse(JSON.stringify(data)),
        formulas: JSON.parse(JSON.stringify(formulas)),
        formatting: JSON.parse(JSON.stringify(formatting))
      };
      redoStack.push(JSON.stringify(currentState));

      // Restore previous state
      const state = JSON.parse(undoStack.pop());

      // Clear and restore data
      for (const key in data) delete data[key];
      for (const key in formulas) delete formulas[key];
      for (const key in formatting) delete formatting[key];

      Object.assign(data, state.data);
      Object.assign(formulas, state.formulas);
      Object.assign(formatting, state.formatting);

      // Update display
      refreshAllCells();
      updateUndoRedoButtons();
      showToast('Undo', 'info');
    }

    function redo() {
      if (redoStack.length === 0) {
        showToast('Nothing to redo', 'warning');
        return;
      }

      // Save current state to undo stack
      const currentState = {
        data: JSON.parse(JSON.stringify(data)),
        formulas: JSON.parse(JSON.stringify(formulas)),
        formatting: JSON.parse(JSON.stringify(formatting))
      };
      undoStack.push(JSON.stringify(currentState));

      // Restore redo state
      const state = JSON.parse(redoStack.pop());

      // Clear and restore data
      for (const key in data) delete data[key];
      for (const key in formulas) delete formulas[key];
      for (const key in formatting) delete formatting[key];

      Object.assign(data, state.data);
      Object.assign(formulas, state.formulas);
      Object.assign(formatting, state.formatting);

      // Update display
      refreshAllCells();
      updateUndoRedoButtons();
      showToast('Redo', 'info');
    }

    function updateUndoRedoButtons() {
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');
      if (undoBtn) undoBtn.style.opacity = undoStack.length === 0 ? '0.5' : '1';
      if (redoBtn) redoBtn.style.opacity = redoStack.length === 0 ? '0.5' : '1';
    }

    function refreshAllCells() {
      for (let r = 1; r <= ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const ref = String.fromCharCode(65 + c) + r;
          const cell = document.getElementById(ref);
          if (cell) {
            cell.value = data[ref] || '';
            if (formatting[ref]) {
              applyFormattingToCell(ref);
            } else {
              cell.style.cssText = '';
            }
          }
        }
      }
      recalculateAll();
    }

    // New Spreadsheet
    function newSpreadsheet() {
      if (Object.keys(data).length > 0 && !confirm('Create new spreadsheet? Unsaved changes will be lost.')) return;
      toggleFileMenu();

      // Clear all data
      for (const key in data) delete data[key];
      for (const key in formulas) delete formulas[key];

      // Re-initialize
      initSpreadsheet();
      document.getElementById('fileName').value = 'Untitled Spreadsheet';
      currentDocId = null;
      showToast('New spreadsheet created', 'success');
    }

    // Open Dialog
    function showOpenDialog() {
      toggleFileMenu();
      const docs = getSavedDocs();
      const list = document.getElementById('savedDocsList');

      if (Object.keys(docs).length === 0) {
        list.innerHTML = '<p style="color: var(--secondary); text-align: center; padding: 2rem;">No saved spreadsheets yet.<br>Save a spreadsheet first!</p>';
      } else {
        list.innerHTML = Object.entries(docs).map(([id, doc]) => `
          <div style="display: flex; align-items: center; padding: 0.75rem; border: 1px solid var(--border); border-radius: 4px; margin-bottom: 0.5rem; cursor: pointer; transition: all 0.2s;"
               onmouseover="this.style.background='var(--light)'"
               onmouseout="this.style.background='white'"
               onclick="loadSpreadsheet('${id}')">
            <div style="flex: 1;">
              <div style="font-weight: 500;">${doc.name}</div>
              <div style="font-size: 0.8rem; color: var(--secondary);">
                Last modified: ${new Date(doc.modified).toLocaleString()}
              </div>
            </div>
            <button class="btn btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;"
                    onclick="event.stopPropagation(); deleteSpreadsheet('${id}')">üóë</button>
          </div>
        `).join('');
      }

      document.getElementById('openModal').classList.add('active');
    }

    function hideOpenDialog() {
      document.getElementById('openModal').classList.remove('active');
    }

    // Load Spreadsheet
    function loadSpreadsheet(id) {
      const docs = getSavedDocs();
      const doc = docs[id];
      if (doc) {
        // Clear existing data
        for (const key in data) delete data[key];
        for (const key in formulas) delete formulas[key];

        // Load saved data
        Object.assign(data, doc.data || {});
        Object.assign(formulas, doc.formulas || {});

        // Render cells
        for (const ref in data) {
          const cell = document.getElementById(ref);
          if (cell) {
            cell.value = data[ref];
            if (formulas[ref]) cell.classList.add('formula');
          }
        }

        document.getElementById('fileName').value = doc.name;
        currentDocId = id;
        hideOpenDialog();
        showToast('Spreadsheet loaded', 'success');
      }
    }

    // Delete Spreadsheet
    function deleteSpreadsheet(id) {
      if (!confirm('Delete this spreadsheet permanently?')) return;
      const docs = getSavedDocs();
      delete docs[id];
      saveDocs(docs);
      showOpenDialog();
      showToast('Spreadsheet deleted', 'success');
    }

    // Save Spreadsheet
    function saveSpreadsheet() {
      toggleFileMenu();
      if (!currentDocId) {
        saveSpreadsheetAs();
        return;
      }

      const docs = getSavedDocs();
      const name = document.getElementById('fileName').value;
      docs[currentDocId] = {
        name: name,
        data: { ...data },
        formulas: { ...formulas },
        modified: Date.now()
      };
      saveDocs(docs);
      addToRecentFiles(currentDocId, name);
      showToast('Spreadsheet saved', 'success');
    }

    // Save As
    function saveSpreadsheetAs() {
      const menu = document.getElementById('fileMenu');
      if (menu.classList.contains('show')) toggleFileMenu();
      document.getElementById('saveAsName').value = document.getElementById('fileName').value;
      document.getElementById('saveAsModal').classList.add('active');
    }

    function hideSaveAs() {
      document.getElementById('saveAsModal').classList.remove('active');
    }

    function confirmSaveAs() {
      const name = document.getElementById('saveAsName').value.trim() || 'Untitled Spreadsheet';
      const docs = getSavedDocs();
      const id = 'sheet_' + Date.now();

      docs[id] = {
        name: name,
        data: { ...data },
        formulas: { ...formulas },
        modified: Date.now()
      };

      saveDocs(docs);
      currentDocId = id;
      document.getElementById('fileName').value = name;
      addToRecentFiles(id, name);
      hideSaveAs();
      showToast('Spreadsheet saved as "' + name + '"', 'success');
    }

    // Export to file
    function exportToFile() {
      toggleFileMenu();
      const name = document.getElementById('fileName').value.trim() || 'spreadsheet';
      const fileData = {
        name: name,
        data: { ...data },
        formulas: { ...formulas },
        created: Date.now(),
        app: 'NinjaCalc'
      };

      const blob = new Blob([JSON.stringify(fileData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name + '.njcalc';
      a.click();
      URL.revokeObjectURL(url);
      showToast('Spreadsheet exported', 'success');
    }

    // Import from file
    function importFromFile() {
      toggleFileMenu();
      document.getElementById('fileImport').click();
    }

    function handleFileImport(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const fileData = JSON.parse(e.target.result);
          if (fileData.data) {
            // Clear existing
            for (const key in data) delete data[key];
            for (const key in formulas) delete formulas[key];

            // Load imported data
            Object.assign(data, fileData.data || {});
            Object.assign(formulas, fileData.formulas || {});

            // Render
            for (const ref in data) {
              const cell = document.getElementById(ref);
              if (cell) {
                cell.value = data[ref];
                if (formulas[ref]) cell.classList.add('formula');
              }
            }

            document.getElementById('fileName').value = fileData.name || 'Imported Spreadsheet';
            currentDocId = null;
            showToast('Spreadsheet imported successfully', 'success');
          } else {
            throw new Error('Invalid format');
          }
        } catch (err) {
          showToast('Error importing file: Invalid format', 'error');
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    // Initialize spreadsheet
    function initSpreadsheet() {
      const table = document.getElementById('spreadsheet');
      let html = '<thead><tr><th class="corner"></th>';

      // Column headers
      for (let c = 0; c < COLS; c++) {
        html += `<th>${String.fromCharCode(65 + c)}</th>`;
      }
      html += '</tr></thead><tbody>';

      // Rows
      for (let r = 1; r <= ROWS; r++) {
        html += `<tr><td class="row-header">${r}</td>`;
        for (let c = 0; c < COLS; c++) {
          const ref = String.fromCharCode(65 + c) + r;
          html += `<td><input type="text" class="cell" id="${ref}"
            onclick="selectCell('${ref}')"
            onfocus="selectCell('${ref}')"
            onblur="updateCell('${ref}')"
            onkeydown="handleCellKeydown(event, '${ref}')"
            ondblclick="editCell('${ref}')"></td>`;
        }
        html += '</tr>';
      }
      html += '</tbody>';
      table.innerHTML = html;

      // Load sample data
      loadSampleData();
      updateMacroList();
    }

    function loadSampleData() {
      // Sample sales data
      const sampleData = [
        ['Product', 'Q1', 'Q2', 'Q3', 'Q4'],
        ['Laptops', 15000, 18000, 22000, 25000],
        ['Phones', 25000, 28000, 32000, 35000],
        ['Tablets', 8000, 9500, 11000, 12000],
        ['Accessories', 5000, 6000, 7500, 8500],
        ['Software', 12000, 14000, 16000, 19000]
      ];

      sampleData.forEach((row, r) => {
        row.forEach((value, c) => {
          const ref = String.fromCharCode(65 + c) + (r + 1);
          setCellValue(ref, value);
        });
      });

      // Add formula example
      setCellValue('F1', 'Total');
      for (let i = 2; i <= 6; i++) {
        setCellValue('F' + i, `=SUM(B${i}:E${i})`);
      }
    }

    // Cell operations
    function selectCell(ref) {
      if (selectedCell) {
        document.getElementById(selectedCell).classList.remove('selected');
      }
      selectedCell = ref;
      document.getElementById(ref).classList.add('selected');
      document.getElementById('cellRef').value = ref;

      const formula = formulas[ref];
      const value = data[ref];
      document.getElementById('formulaInput').value = formula || value || '';

      updateStatusBar();
    }

    function editCell(ref) {
      const cell = document.getElementById(ref);
      const formula = formulas[ref];
      if (formula) {
        cell.value = formula;
      }
    }

    function updateCell(ref) {
      const cell = document.getElementById(ref);
      const value = cell.value.trim();

      // Save state for undo before making changes
      saveUndoState();

      if (value.startsWith('=')) {
        formulas[ref] = value;
        cell.classList.add('formula');
        const result = evaluateFormula(value.substring(1), ref);
        data[ref] = result;
        cell.value = result;
      } else {
        delete formulas[ref];
        cell.classList.remove('formula');
        data[ref] = isNaN(value) ? value : parseFloat(value) || value;
      }

      // Recalculate dependent cells
      recalculateAll();
      updateStatusBar();
    }

    function setCellValue(ref, value) {
      const cell = document.getElementById(ref);
      if (!cell) return;

      if (typeof value === 'string' && value.startsWith('=')) {
        formulas[ref] = value;
        cell.classList.add('formula');
        const result = evaluateFormula(value.substring(1), ref);
        data[ref] = result;
        cell.value = result;
      } else {
        delete formulas[ref];
        cell.classList.remove('formula');
        data[ref] = value;
        cell.value = value;
      }
    }

    function getCellValue(ref) {
      return data[ref] !== undefined ? data[ref] : '';
    }

    // Formula evaluation
    function evaluateFormula(formula, currentRef) {
      try {
        // Replace cell references with values
        let expr = formula.toUpperCase();

        // Handle functions
        expr = expr.replace(/SUM\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end);
          return values.reduce((a, b) => a + (parseFloat(b) || 0), 0);
        });

        expr = expr.replace(/AVERAGE\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '');
          return values.length ? values.reduce((a, b) => a + parseFloat(b), 0) / values.length : 0;
        });

        expr = expr.replace(/COUNT\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          return getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').length;
        });

        expr = expr.replace(/MAX\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          return values.length ? Math.max(...values) : 0;
        });

        expr = expr.replace(/MIN\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          return values.length ? Math.min(...values) : 0;
        });

        expr = expr.replace(/IF\(([^,]+),([^,]+),([^)]+)\)/gi, (_, cond, trueVal, falseVal) => {
          const evalCond = evaluateExpression(cond);
          return evalCond ? evaluateExpression(trueVal) : evaluateExpression(falseVal);
        });

        expr = expr.replace(/VLOOKUP\(([^,]+),([A-Z]+\d+):([A-Z]+\d+),(\d+),?\w*\)/gi, (_, lookup, start, end, col) => {
          const lookupVal = evaluateExpression(lookup);
          const range = getRangeAsMatrix(start, end);
          for (const row of range) {
            if (row[0] == lookupVal) {
              return row[parseInt(col) - 1] || '#N/A';
            }
          }
          return '#N/A';
        });

        expr = expr.replace(/CONCATENATE\(([^)]+)\)/gi, (_, args) => {
          return args.split(',').map(a => evaluateExpression(a.trim())).join('');
        });

        expr = expr.replace(/LEN\(([^)]+)\)/gi, (_, arg) => {
          return String(evaluateExpression(arg)).length;
        });

        expr = expr.replace(/LEFT\(([^,]+),(\d+)\)/gi, (_, text, num) => {
          return String(evaluateExpression(text)).substring(0, parseInt(num));
        });

        expr = expr.replace(/RIGHT\(([^,]+),(\d+)\)/gi, (_, text, num) => {
          const str = String(evaluateExpression(text));
          return str.substring(str.length - parseInt(num));
        });

        // ==================== FINANCIAL FUNCTIONS ====================
        // PMT(rate, nper, pv, [fv], [type])
        expr = expr.replace(/PMT\(([^,]+),([^,]+),([^,)]+)(?:,([^,)]+))?(?:,([^)]+))?\)/gi, (_, rate, nper, pv, fv, type) => {
          const r = parseFloat(evaluateExpression(rate));
          const n = parseFloat(evaluateExpression(nper));
          const p = parseFloat(evaluateExpression(pv));
          const f = fv ? parseFloat(evaluateExpression(fv)) : 0;
          const t = type ? parseFloat(evaluateExpression(type)) : 0;
          if (r === 0) return -(p + f) / n;
          const pmt = (r * (p * Math.pow(1 + r, n) + f)) / ((1 + r * t) * (Math.pow(1 + r, n) - 1));
          return -pmt;
        });

        // FV(rate, nper, pmt, [pv], [type])
        expr = expr.replace(/FV\(([^,]+),([^,]+),([^,)]+)(?:,([^,)]+))?(?:,([^)]+))?\)/gi, (_, rate, nper, pmt, pv, type) => {
          const r = parseFloat(evaluateExpression(rate));
          const n = parseFloat(evaluateExpression(nper));
          const payment = parseFloat(evaluateExpression(pmt));
          const p = pv ? parseFloat(evaluateExpression(pv)) : 0;
          const t = type ? parseFloat(evaluateExpression(type)) : 0;
          if (r === 0) return -(p + payment * n);
          return -(p * Math.pow(1 + r, n) + payment * ((Math.pow(1 + r, n) - 1) / r) * (1 + r * t));
        });

        // PV(rate, nper, pmt, [fv], [type])
        expr = expr.replace(/PV\(([^,]+),([^,]+),([^,)]+)(?:,([^,)]+))?(?:,([^)]+))?\)/gi, (_, rate, nper, pmt, fv, type) => {
          const r = parseFloat(evaluateExpression(rate));
          const n = parseFloat(evaluateExpression(nper));
          const payment = parseFloat(evaluateExpression(pmt));
          const f = fv ? parseFloat(evaluateExpression(fv)) : 0;
          const t = type ? parseFloat(evaluateExpression(type)) : 0;
          if (r === 0) return -payment * n - f;
          return -(payment * ((1 - Math.pow(1 + r, -n)) / r) * (1 + r * t) + f * Math.pow(1 + r, -n));
        });

        // NPV(rate, values...)
        expr = expr.replace(/NPV\(([^,]+),([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, rate, start, end) => {
          const r = parseFloat(evaluateExpression(rate));
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          return values.reduce((acc, val, i) => acc + val / Math.pow(1 + r, i + 1), 0);
        });

        // IRR approximation (Newton's method)
        expr = expr.replace(/IRR\(([A-Z]+\d+):([A-Z]+\d+)(?:,([^)]+))?\)/gi, (_, start, end, guess) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          let rate = guess ? parseFloat(evaluateExpression(guess)) : 0.1;
          for (let i = 0; i < 100; i++) {
            let npv = 0, dnpv = 0;
            values.forEach((cf, t) => {
              npv += cf / Math.pow(1 + rate, t);
              dnpv -= t * cf / Math.pow(1 + rate, t + 1);
            });
            const newRate = rate - npv / dnpv;
            if (Math.abs(newRate - rate) < 0.0000001) return newRate;
            rate = newRate;
          }
          return rate;
        });

        // RATE approximation
        expr = expr.replace(/RATE\(([^,]+),([^,]+),([^,)]+)(?:,([^,)]+))?\)/gi, (_, nper, pmt, pv, fv) => {
          const n = parseFloat(evaluateExpression(nper));
          const payment = parseFloat(evaluateExpression(pmt));
          const p = parseFloat(evaluateExpression(pv));
          const f = fv ? parseFloat(evaluateExpression(fv)) : 0;
          let rate = 0.1;
          for (let i = 0; i < 100; i++) {
            const y = p * Math.pow(1 + rate, n) + payment * ((Math.pow(1 + rate, n) - 1) / rate) + f;
            const dy = n * p * Math.pow(1 + rate, n - 1) + payment * ((n * Math.pow(1 + rate, n - 1) * rate - Math.pow(1 + rate, n) + 1) / (rate * rate));
            const newRate = rate - y / dy;
            if (Math.abs(newRate - rate) < 0.0000001) return newRate;
            rate = newRate;
          }
          return rate;
        });

        // ==================== DATE/TIME FUNCTIONS ====================
        expr = expr.replace(/TODAY\(\)/gi, () => {
          return Math.floor((Date.now() - new Date('1899-12-30').getTime()) / 86400000);
        });

        expr = expr.replace(/NOW\(\)/gi, () => {
          return (Date.now() - new Date('1899-12-30').getTime()) / 86400000;
        });

        expr = expr.replace(/DATE\(([^,]+),([^,]+),([^)]+)\)/gi, (_, y, m, d) => {
          const date = new Date(evaluateExpression(y), evaluateExpression(m) - 1, evaluateExpression(d));
          return Math.floor((date.getTime() - new Date('1899-12-30').getTime()) / 86400000);
        });

        expr = expr.replace(/YEAR\(([^)]+)\)/gi, (_, serial) => {
          const days = parseFloat(evaluateExpression(serial));
          const date = new Date(new Date('1899-12-30').getTime() + days * 86400000);
          return date.getFullYear();
        });

        expr = expr.replace(/MONTH\(([^)]+)\)/gi, (_, serial) => {
          const days = parseFloat(evaluateExpression(serial));
          const date = new Date(new Date('1899-12-30').getTime() + days * 86400000);
          return date.getMonth() + 1;
        });

        expr = expr.replace(/DAY\(([^)]+)\)/gi, (_, serial) => {
          const days = parseFloat(evaluateExpression(serial));
          const date = new Date(new Date('1899-12-30').getTime() + days * 86400000);
          return date.getDate();
        });

        expr = expr.replace(/WEEKDAY\(([^)]+)\)/gi, (_, serial) => {
          const days = parseFloat(evaluateExpression(serial));
          const date = new Date(new Date('1899-12-30').getTime() + days * 86400000);
          return date.getDay() + 1;
        });

        expr = expr.replace(/DATEDIF\(([^,]+),([^,]+),([^)]+)\)/gi, (_, start, end, unit) => {
          const d1 = parseFloat(evaluateExpression(start));
          const d2 = parseFloat(evaluateExpression(end));
          const diff = d2 - d1;
          const u = String(evaluateExpression(unit)).toUpperCase().replace(/"/g, '');
          if (u === 'D') return Math.floor(diff);
          if (u === 'M') return Math.floor(diff / 30);
          if (u === 'Y') return Math.floor(diff / 365);
          return diff;
        });

        expr = expr.replace(/EDATE\(([^,]+),([^)]+)\)/gi, (_, start, months) => {
          const days = parseFloat(evaluateExpression(start));
          const m = parseFloat(evaluateExpression(months));
          const date = new Date(new Date('1899-12-30').getTime() + days * 86400000);
          date.setMonth(date.getMonth() + m);
          return Math.floor((date.getTime() - new Date('1899-12-30').getTime()) / 86400000);
        });

        // ==================== STATISTICAL FUNCTIONS ====================
        expr = expr.replace(/STDEV\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          if (values.length < 2) return '#DIV/0!';
          const mean = values.reduce((a, b) => a + b, 0) / values.length;
          const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (values.length - 1);
          return Math.sqrt(variance);
        });

        expr = expr.replace(/VAR\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          if (values.length < 2) return '#DIV/0!';
          const mean = values.reduce((a, b) => a + b, 0) / values.length;
          return values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (values.length - 1);
        });

        expr = expr.replace(/MEDIAN\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number).sort((a, b) => a - b);
          if (values.length === 0) return 0;
          const mid = Math.floor(values.length / 2);
          return values.length % 2 ? values[mid] : (values[mid - 1] + values[mid]) / 2;
        });

        expr = expr.replace(/MODE\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number);
          const counts = {};
          values.forEach(v => counts[v] = (counts[v] || 0) + 1);
          let mode = values[0], maxCount = 0;
          for (const [val, count] of Object.entries(counts)) {
            if (count > maxCount) { maxCount = count; mode = parseFloat(val); }
          }
          return mode;
        });

        expr = expr.replace(/PERCENTILE\(([A-Z]+\d+):([A-Z]+\d+),([^)]+)\)/gi, (_, start, end, k) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number).sort((a, b) => a - b);
          const p = parseFloat(evaluateExpression(k));
          const n = values.length;
          const index = p * (n - 1);
          const lower = Math.floor(index);
          const upper = Math.ceil(index);
          if (lower === upper) return values[lower];
          return values[lower] + (values[upper] - values[lower]) * (index - lower);
        });

        expr = expr.replace(/QUARTILE\(([A-Z]+\d+):([A-Z]+\d+),([^)]+)\)/gi, (_, start, end, q) => {
          const values = getRangeValues(start, end).filter(v => !isNaN(v) && v !== '').map(Number).sort((a, b) => a - b);
          const quartile = parseFloat(evaluateExpression(q));
          const p = quartile * 0.25;
          const n = values.length;
          const index = p * (n - 1);
          const lower = Math.floor(index);
          const upper = Math.ceil(index);
          if (lower === upper) return values[lower];
          return values[lower] + (values[upper] - values[lower]) * (index - lower);
        });

        // ==================== MATH FUNCTIONS ====================
        expr = expr.replace(/ROUND\(([^,]+),([^)]+)\)/gi, (_, num, digits) => {
          const n = parseFloat(evaluateExpression(num));
          const d = parseInt(evaluateExpression(digits));
          return Math.round(n * Math.pow(10, d)) / Math.pow(10, d);
        });

        expr = expr.replace(/ROUNDUP\(([^,]+),([^)]+)\)/gi, (_, num, digits) => {
          const n = parseFloat(evaluateExpression(num));
          const d = parseInt(evaluateExpression(digits));
          return Math.ceil(n * Math.pow(10, d)) / Math.pow(10, d);
        });

        expr = expr.replace(/ROUNDDOWN\(([^,]+),([^)]+)\)/gi, (_, num, digits) => {
          const n = parseFloat(evaluateExpression(num));
          const d = parseInt(evaluateExpression(digits));
          return Math.floor(n * Math.pow(10, d)) / Math.pow(10, d);
        });

        expr = expr.replace(/ABS\(([^)]+)\)/gi, (_, num) => Math.abs(parseFloat(evaluateExpression(num))));

        expr = expr.replace(/SQRT\(([^)]+)\)/gi, (_, num) => Math.sqrt(parseFloat(evaluateExpression(num))));

        expr = expr.replace(/POWER\(([^,]+),([^)]+)\)/gi, (_, base, exp) => {
          return Math.pow(parseFloat(evaluateExpression(base)), parseFloat(evaluateExpression(exp)));
        });

        expr = expr.replace(/MOD\(([^,]+),([^)]+)\)/gi, (_, num, div) => {
          return parseFloat(evaluateExpression(num)) % parseFloat(evaluateExpression(div));
        });

        expr = expr.replace(/INT\(([^)]+)\)/gi, (_, num) => Math.floor(parseFloat(evaluateExpression(num))));

        expr = expr.replace(/RAND\(\)/gi, () => Math.random());

        expr = expr.replace(/RANDBETWEEN\(([^,]+),([^)]+)\)/gi, (_, low, high) => {
          const l = parseInt(evaluateExpression(low));
          const h = parseInt(evaluateExpression(high));
          return Math.floor(Math.random() * (h - l + 1)) + l;
        });

        // ==================== TEXT FUNCTIONS ====================
        expr = expr.replace(/UPPER\(([^)]+)\)/gi, (_, text) => {
          return String(evaluateExpression(text)).toUpperCase();
        });

        expr = expr.replace(/LOWER\(([^)]+)\)/gi, (_, text) => {
          return String(evaluateExpression(text)).toLowerCase();
        });

        expr = expr.replace(/PROPER\(([^)]+)\)/gi, (_, text) => {
          return String(evaluateExpression(text)).replace(/\w\S*/g, t => t.charAt(0).toUpperCase() + t.substr(1).toLowerCase());
        });

        expr = expr.replace(/TRIM\(([^)]+)\)/gi, (_, text) => {
          return String(evaluateExpression(text)).trim();
        });

        expr = expr.replace(/MID\(([^,]+),([^,]+),([^)]+)\)/gi, (_, text, start, len) => {
          return String(evaluateExpression(text)).substr(parseInt(evaluateExpression(start)) - 1, parseInt(evaluateExpression(len)));
        });

        expr = expr.replace(/SUBSTITUTE\(([^,]+),([^,]+),([^)]+)\)/gi, (_, text, old, newText) => {
          return String(evaluateExpression(text)).replace(new RegExp(evaluateExpression(old), 'g'), evaluateExpression(newText));
        });

        // ==================== LOGICAL FUNCTIONS ====================
        expr = expr.replace(/AND\(([^)]+)\)/gi, (_, args) => {
          const vals = args.split(',').map(a => evaluateExpression(a.trim()));
          return vals.every(v => v) ? 1 : 0;
        });

        expr = expr.replace(/OR\(([^)]+)\)/gi, (_, args) => {
          const vals = args.split(',').map(a => evaluateExpression(a.trim()));
          return vals.some(v => v) ? 1 : 0;
        });

        expr = expr.replace(/NOT\(([^)]+)\)/gi, (_, arg) => {
          return evaluateExpression(arg) ? 0 : 1;
        });

        expr = expr.replace(/IFERROR\(([^,]+),([^)]+)\)/gi, (_, value, errorVal) => {
          try {
            const result = evaluateExpression(value);
            if (String(result).includes('#')) return evaluateExpression(errorVal);
            return result;
          } catch {
            return evaluateExpression(errorVal);
          }
        });

        // ==================== MODERN LOOKUP FUNCTIONS ====================
        // XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])
        expr = expr.replace(/XLOOKUP\(([^,]+),([A-Z]+\d+):([A-Z]+\d+),([A-Z]+\d+):([A-Z]+\d+)(?:,([^,)]+))?(?:,([^,)]+))?(?:,([^)]+))?\)/gi,
          (_, lookupVal, lookStart, lookEnd, retStart, retEnd, notFound, matchMode, searchMode) => {
            const lookup = evaluateExpression(lookupVal);
            const lookupRange = getRangeValues(lookStart, lookEnd);
            const returnRange = getRangeValues(retStart, retEnd);
            const notFoundVal = notFound ? evaluateExpression(notFound) : '#N/A';
            const mode = matchMode ? parseInt(evaluateExpression(matchMode)) : 0; // 0=exact, -1=exact or next smaller, 1=exact or next larger
            const search = searchMode ? parseInt(evaluateExpression(searchMode)) : 1; // 1=first to last, -1=last to first

            let foundIndex = -1;

            if (mode === 0) {
              // Exact match
              foundIndex = search === 1 ? lookupRange.findIndex(v => v == lookup) : lookupRange.findLastIndex(v => v == lookup);
            } else if (mode === -1) {
              // Exact match or next smaller
              let bestIndex = -1, bestVal = -Infinity;
              lookupRange.forEach((v, i) => {
                const numV = parseFloat(v);
                if (!isNaN(numV) && numV <= lookup && numV > bestVal) {
                  bestVal = numV;
                  bestIndex = i;
                }
              });
              foundIndex = bestIndex;
            } else if (mode === 1) {
              // Exact match or next larger
              let bestIndex = -1, bestVal = Infinity;
              lookupRange.forEach((v, i) => {
                const numV = parseFloat(v);
                if (!isNaN(numV) && numV >= lookup && numV < bestVal) {
                  bestVal = numV;
                  bestIndex = i;
                }
              });
              foundIndex = bestIndex;
            } else if (mode === 2) {
              // Wildcard match
              const pattern = new RegExp('^' + String(lookup).replace(/\*/g, '.*').replace(/\?/g, '.') + '$', 'i');
              foundIndex = lookupRange.findIndex(v => pattern.test(String(v)));
            }

            if (foundIndex >= 0 && foundIndex < returnRange.length) {
              return returnRange[foundIndex];
            }
            return notFoundVal;
        });

        // XMATCH(lookup_value, lookup_array, [match_mode], [search_mode])
        expr = expr.replace(/XMATCH\(([^,]+),([A-Z]+\d+):([A-Z]+\d+)(?:,([^,)]+))?(?:,([^)]+))?\)/gi,
          (_, lookupVal, start, end, matchMode, searchMode) => {
            const lookup = evaluateExpression(lookupVal);
            const lookupRange = getRangeValues(start, end);
            const mode = matchMode ? parseInt(evaluateExpression(matchMode)) : 0;
            const search = searchMode ? parseInt(evaluateExpression(searchMode)) : 1;

            if (mode === 0) {
              const idx = search === 1 ? lookupRange.findIndex(v => v == lookup) : lookupRange.findLastIndex(v => v == lookup);
              return idx >= 0 ? idx + 1 : '#N/A';
            } else if (mode === -1) {
              let bestIndex = -1, bestVal = -Infinity;
              lookupRange.forEach((v, i) => {
                const numV = parseFloat(v);
                if (!isNaN(numV) && numV <= lookup && numV > bestVal) {
                  bestVal = numV;
                  bestIndex = i;
                }
              });
              return bestIndex >= 0 ? bestIndex + 1 : '#N/A';
            } else if (mode === 1) {
              let bestIndex = -1, bestVal = Infinity;
              lookupRange.forEach((v, i) => {
                const numV = parseFloat(v);
                if (!isNaN(numV) && numV >= lookup && numV < bestVal) {
                  bestVal = numV;
                  bestIndex = i;
                }
              });
              return bestIndex >= 0 ? bestIndex + 1 : '#N/A';
            }
            return '#N/A';
        });

        // HLOOKUP(lookup_value, table_array, row_index, [range_lookup])
        expr = expr.replace(/HLOOKUP\(([^,]+),([A-Z]+\d+):([A-Z]+\d+),(\d+),?\w*\)/gi, (_, lookup, start, end, row) => {
          const lookupVal = evaluateExpression(lookup);
          const matrix = getRangeAsMatrix(start, end);
          if (matrix.length === 0) return '#N/A';
          const colIndex = matrix[0].findIndex(v => v == lookupVal);
          if (colIndex < 0) return '#N/A';
          const rowIndex = parseInt(row) - 1;
          if (rowIndex < 0 || rowIndex >= matrix.length) return '#REF!';
          return matrix[rowIndex][colIndex] || '#N/A';
        });

        // INDEX(array, row_num, [column_num])
        expr = expr.replace(/INDEX\(([A-Z]+\d+):([A-Z]+\d+),(\d+)(?:,(\d+))?\)/gi, (_, start, end, row, col) => {
          const matrix = getRangeAsMatrix(start, end);
          const r = parseInt(row) - 1;
          const c = col ? parseInt(col) - 1 : 0;
          if (r < 0 || r >= matrix.length) return '#REF!';
          if (c < 0 || c >= matrix[0].length) return '#REF!';
          return matrix[r][c] || '';
        });

        // MATCH(lookup_value, lookup_array, [match_type])
        expr = expr.replace(/MATCH\(([^,]+),([A-Z]+\d+):([A-Z]+\d+)(?:,([^)]+))?\)/gi, (_, lookup, start, end, matchType) => {
          const lookupVal = evaluateExpression(lookup);
          const range = getRangeValues(start, end);
          const type = matchType ? parseInt(evaluateExpression(matchType)) : 1;

          if (type === 0) {
            const idx = range.findIndex(v => v == lookupVal);
            return idx >= 0 ? idx + 1 : '#N/A';
          } else if (type === 1) {
            // Find largest value <= lookup (assumes sorted ascending)
            let bestIdx = -1;
            for (let i = 0; i < range.length; i++) {
              if (parseFloat(range[i]) <= lookupVal) bestIdx = i;
            }
            return bestIdx >= 0 ? bestIdx + 1 : '#N/A';
          } else if (type === -1) {
            // Find smallest value >= lookup (assumes sorted descending)
            let bestIdx = -1;
            for (let i = 0; i < range.length; i++) {
              if (parseFloat(range[i]) >= lookupVal) bestIdx = i;
            }
            return bestIdx >= 0 ? bestIdx + 1 : '#N/A';
          }
          return '#N/A';
        });

        // ==================== ARRAY FUNCTIONS ====================
        // FILTER - returns filtered values as comma-separated (simplified for single-cell display)
        expr = expr.replace(/FILTER\(([A-Z]+\d+):([A-Z]+\d+),([A-Z]+\d+):([A-Z]+\d+)(?:,([^)]+))?\)/gi,
          (_, dataStart, dataEnd, critStart, critEnd, ifEmpty) => {
            const dataRange = getRangeValues(dataStart, dataEnd);
            const criteriaRange = getRangeValues(critStart, critEnd);
            const emptyVal = ifEmpty ? evaluateExpression(ifEmpty) : '#CALC!';

            const filtered = dataRange.filter((_, i) => {
              const crit = criteriaRange[i];
              return crit && crit !== 0 && crit !== '' && crit !== 'FALSE' && crit !== false;
            });

            return filtered.length > 0 ? filtered.join(', ') : emptyVal;
        });

        // SORT - returns sorted values as comma-separated
        expr = expr.replace(/SORT\(([A-Z]+\d+):([A-Z]+\d+)(?:,([^,)]+))?(?:,([^)]+))?\)/gi,
          (_, start, end, sortIndex, sortOrder) => {
            const values = getRangeValues(start, end).filter(v => v !== '');
            const order = sortOrder ? parseInt(evaluateExpression(sortOrder)) : 1; // 1=ascending, -1=descending

            const sorted = [...values].sort((a, b) => {
              const numA = parseFloat(a), numB = parseFloat(b);
              if (!isNaN(numA) && !isNaN(numB)) {
                return order === 1 ? numA - numB : numB - numA;
              }
              return order === 1 ? String(a).localeCompare(String(b)) : String(b).localeCompare(String(a));
            });

            return sorted.join(', ');
        });

        // SORTBY - sort by another range
        expr = expr.replace(/SORTBY\(([A-Z]+\d+):([A-Z]+\d+),([A-Z]+\d+):([A-Z]+\d+)(?:,([^)]+))?\)/gi,
          (_, dataStart, dataEnd, sortStart, sortEnd, sortOrder) => {
            const dataRange = getRangeValues(dataStart, dataEnd);
            const sortRange = getRangeValues(sortStart, sortEnd);
            const order = sortOrder ? parseInt(evaluateExpression(sortOrder)) : 1;

            const pairs = dataRange.map((val, i) => ({ val, sort: sortRange[i] || '' }));
            pairs.sort((a, b) => {
              const numA = parseFloat(a.sort), numB = parseFloat(b.sort);
              if (!isNaN(numA) && !isNaN(numB)) {
                return order === 1 ? numA - numB : numB - numA;
              }
              return order === 1 ? String(a.sort).localeCompare(String(b.sort)) : String(b.sort).localeCompare(String(a.sort));
            });

            return pairs.filter(p => p.val !== '').map(p => p.val).join(', ');
        });

        // UNIQUE - returns unique values
        expr = expr.replace(/UNIQUE\(([A-Z]+\d+):([A-Z]+\d+)(?:,([^,)]+))?(?:,([^)]+))?\)/gi,
          (_, start, end, byCol, exactlyOnce) => {
            const values = getRangeValues(start, end).filter(v => v !== '');
            const once = exactlyOnce ? parseInt(evaluateExpression(exactlyOnce)) : 0;

            if (once) {
              // Return only values that appear exactly once
              const counts = {};
              values.forEach(v => counts[v] = (counts[v] || 0) + 1);
              return values.filter(v => counts[v] === 1).join(', ');
            }

            return [...new Set(values)].join(', ');
        });

        // SEQUENCE(rows, [columns], [start], [step])
        expr = expr.replace(/SEQUENCE\(([^,)]+)(?:,([^,)]+))?(?:,([^,)]+))?(?:,([^)]+))?\)/gi,
          (_, rows, cols, start, step) => {
            const r = parseInt(evaluateExpression(rows)) || 1;
            const c = cols ? parseInt(evaluateExpression(cols)) : 1;
            const s = start ? parseFloat(evaluateExpression(start)) : 1;
            const st = step ? parseFloat(evaluateExpression(step)) : 1;

            const result = [];
            let current = s;
            for (let i = 0; i < r * c; i++) {
              result.push(current);
              current += st;
            }
            return result.join(', ');
        });

        // RANDARRAY(rows, [columns], [min], [max], [integer])
        expr = expr.replace(/RANDARRAY\(([^,)]+)(?:,([^,)]+))?(?:,([^,)]+))?(?:,([^,)]+))?(?:,([^)]+))?\)/gi,
          (_, rows, cols, min, max, integer) => {
            const r = parseInt(evaluateExpression(rows)) || 1;
            const c = cols ? parseInt(evaluateExpression(cols)) : 1;
            const minVal = min ? parseFloat(evaluateExpression(min)) : 0;
            const maxVal = max ? parseFloat(evaluateExpression(max)) : 1;
            const isInt = integer ? Boolean(evaluateExpression(integer)) : false;

            const result = [];
            for (let i = 0; i < r * c; i++) {
              let val = Math.random() * (maxVal - minVal) + minVal;
              if (isInt) val = Math.floor(val);
              result.push(Math.round(val * 100) / 100);
            }
            return result.join(', ');
        });

        // ==================== ADDITIONAL TEXT FUNCTIONS ====================
        // TEXTJOIN(delimiter, ignore_empty, range)
        expr = expr.replace(/TEXTJOIN\(([^,]+),([^,]+),([A-Z]+\d+):([A-Z]+\d+)\)/gi,
          (_, delim, ignoreEmpty, start, end) => {
            const delimiter = String(evaluateExpression(delim)).replace(/"/g, '');
            const ignore = Boolean(evaluateExpression(ignoreEmpty));
            let values = getRangeValues(start, end);
            if (ignore) values = values.filter(v => v !== '');
            return values.join(delimiter);
        });

        // CONCAT - concatenate range
        expr = expr.replace(/CONCAT\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (_, start, end) => {
          return getRangeValues(start, end).join('');
        });

        // TEXTSPLIT (simplified - split by delimiter)
        expr = expr.replace(/TEXTSPLIT\(([^,]+),([^)]+)\)/gi, (_, text, delim) => {
          const str = String(evaluateExpression(text)).replace(/"/g, '');
          const delimiter = String(evaluateExpression(delim)).replace(/"/g, '');
          return str.split(delimiter).join(', ');
        });

        // ==================== AGGREGATE FUNCTIONS ====================
        // SUMIF(range, criteria, [sum_range])
        expr = expr.replace(/SUMIF\(([A-Z]+\d+):([A-Z]+\d+),([^,)]+)(?:,([A-Z]+\d+):([A-Z]+\d+))?\)/gi,
          (_, critStart, critEnd, criteria, sumStart, sumEnd) => {
            const critRange = getRangeValues(critStart, critEnd);
            const sumRange = sumStart ? getRangeValues(sumStart, sumEnd) : critRange;
            const crit = String(evaluateExpression(criteria)).replace(/"/g, '');

            let sum = 0;
            critRange.forEach((val, i) => {
              if (matchesCriteria(val, crit)) {
                sum += parseFloat(sumRange[i]) || 0;
              }
            });
            return sum;
        });

        // COUNTIF(range, criteria)
        expr = expr.replace(/COUNTIF\(([A-Z]+\d+):([A-Z]+\d+),([^)]+)\)/gi, (_, start, end, criteria) => {
          const range = getRangeValues(start, end);
          const crit = String(evaluateExpression(criteria)).replace(/"/g, '');
          return range.filter(val => matchesCriteria(val, crit)).length;
        });

        // AVERAGEIF(range, criteria, [average_range])
        expr = expr.replace(/AVERAGEIF\(([A-Z]+\d+):([A-Z]+\d+),([^,)]+)(?:,([A-Z]+\d+):([A-Z]+\d+))?\)/gi,
          (_, critStart, critEnd, criteria, avgStart, avgEnd) => {
            const critRange = getRangeValues(critStart, critEnd);
            const avgRange = avgStart ? getRangeValues(avgStart, avgEnd) : critRange;
            const crit = String(evaluateExpression(criteria)).replace(/"/g, '');

            const values = [];
            critRange.forEach((val, i) => {
              if (matchesCriteria(val, crit)) {
                const num = parseFloat(avgRange[i]);
                if (!isNaN(num)) values.push(num);
              }
            });
            return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : '#DIV/0!';
        });

        // MAXIFS(max_range, criteria_range1, criteria1, ...)
        expr = expr.replace(/MAXIFS\(([A-Z]+\d+):([A-Z]+\d+),([A-Z]+\d+):([A-Z]+\d+),([^)]+)\)/gi,
          (_, maxStart, maxEnd, critStart, critEnd, criteria) => {
            const maxRange = getRangeValues(maxStart, maxEnd);
            const critRange = getRangeValues(critStart, critEnd);
            const crit = String(evaluateExpression(criteria)).replace(/"/g, '');

            const values = [];
            critRange.forEach((val, i) => {
              if (matchesCriteria(val, crit)) {
                const num = parseFloat(maxRange[i]);
                if (!isNaN(num)) values.push(num);
              }
            });
            return values.length > 0 ? Math.max(...values) : 0;
        });

        // MINIFS(min_range, criteria_range1, criteria1, ...)
        expr = expr.replace(/MINIFS\(([A-Z]+\d+):([A-Z]+\d+),([A-Z]+\d+):([A-Z]+\d+),([^)]+)\)/gi,
          (_, minStart, minEnd, critStart, critEnd, criteria) => {
            const minRange = getRangeValues(minStart, minEnd);
            const critRange = getRangeValues(critStart, critEnd);
            const crit = String(evaluateExpression(criteria)).replace(/"/g, '');

            const values = [];
            critRange.forEach((val, i) => {
              if (matchesCriteria(val, crit)) {
                const num = parseFloat(minRange[i]);
                if (!isNaN(num)) values.push(num);
              }
            });
            return values.length > 0 ? Math.min(...values) : 0;
        });

        // Replace remaining cell references
        expr = expr.replace(/([A-Z]+)(\d+)/g, (_, col, row) => {
          const ref = col + row;
          const val = data[ref];
          if (val === undefined || val === '') return 0;
          return isNaN(val) ? `"${val}"` : val;
        });

        // Evaluate the expression
        const result = evaluateExpression(expr);
        return typeof result === 'number' ? Math.round(result * 100) / 100 : result;
      } catch (e) {
        console.error('Formula error:', e);
        return '#ERROR!';
      }
    }

    function evaluateExpression(expr) {
      // Handle cell references first
      expr = String(expr).replace(/([A-Z]+)(\d+)/g, (_, col, row) => {
        const ref = col + row;
        const val = data[ref];
        if (val === undefined || val === '') return 0;
        return isNaN(val) ? `"${val}"` : val;
      });

      // Safe evaluation
      try {
        return Function('"use strict"; return (' + expr + ')')();
      } catch {
        return expr.replace(/"/g, '');
      }
    }

    function getRangeValues(start, end) {
      const values = [];
      const startCol = start.charCodeAt(0);
      const startRow = parseInt(start.substring(1));
      const endCol = end.charCodeAt(0);
      const endRow = parseInt(end.substring(1));

      for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
          const ref = String.fromCharCode(c) + r;
          values.push(data[ref] !== undefined ? data[ref] : '');
        }
      }
      return values;
    }

    function getRangeAsMatrix(start, end) {
      const matrix = [];
      const startCol = start.charCodeAt(0);
      const startRow = parseInt(start.substring(1));
      const endCol = end.charCodeAt(0);
      const endRow = parseInt(end.substring(1));

      for (let r = startRow; r <= endRow; r++) {
        const row = [];
        for (let c = startCol; c <= endCol; c++) {
          const ref = String.fromCharCode(c) + r;
          row.push(data[ref] !== undefined ? data[ref] : '');
        }
        matrix.push(row);
      }
      return matrix;
    }

    // Helper function for criteria matching (supports >, <, >=, <=, <>, wildcards)
    function matchesCriteria(value, criteria) {
      const crit = String(criteria).trim();

      // Comparison operators
      if (crit.startsWith('>=')) {
        return parseFloat(value) >= parseFloat(crit.substring(2));
      } else if (crit.startsWith('<=')) {
        return parseFloat(value) <= parseFloat(crit.substring(2));
      } else if (crit.startsWith('<>')) {
        return value != crit.substring(2);
      } else if (crit.startsWith('>')) {
        return parseFloat(value) > parseFloat(crit.substring(1));
      } else if (crit.startsWith('<')) {
        return parseFloat(value) < parseFloat(crit.substring(1));
      } else if (crit.startsWith('=')) {
        return value == crit.substring(1);
      }

      // Wildcard support (* and ?)
      if (crit.includes('*') || crit.includes('?')) {
        const pattern = new RegExp('^' + crit.replace(/\*/g, '.*').replace(/\?/g, '.') + '$', 'i');
        return pattern.test(String(value));
      }

      // Exact match (case-insensitive for text)
      if (isNaN(value) && isNaN(crit)) {
        return String(value).toLowerCase() === String(crit).toLowerCase();
      }

      return value == crit;
    }

    function recalculateAll() {
      for (const ref in formulas) {
        const result = evaluateFormula(formulas[ref].substring(1), ref);
        data[ref] = result;
        document.getElementById(ref).value = result;
      }
    }

    // Keyboard navigation
    function handleCellKeydown(event, ref) {
      const col = ref.charCodeAt(0);
      const row = parseInt(ref.substring(1));

      if (event.key === 'Enter') {
        event.preventDefault();
        updateCell(ref);
        const nextRef = String.fromCharCode(col) + (row + 1);
        if (document.getElementById(nextRef)) selectCell(nextRef);
      } else if (event.key === 'Tab') {
        event.preventDefault();
        updateCell(ref);
        const nextRef = String.fromCharCode(col + 1) + row;
        if (document.getElementById(nextRef)) selectCell(nextRef);
      } else if (event.key === 'ArrowDown' && !event.target.value) {
        event.preventDefault();
        const nextRef = String.fromCharCode(col) + (row + 1);
        if (document.getElementById(nextRef)) selectCell(nextRef);
      } else if (event.key === 'ArrowUp' && !event.target.value) {
        event.preventDefault();
        const nextRef = String.fromCharCode(col) + (row - 1);
        if (document.getElementById(nextRef)) selectCell(nextRef);
      } else if (event.key === 'ArrowLeft' && !event.target.value) {
        event.preventDefault();
        const nextRef = String.fromCharCode(col - 1) + row;
        if (document.getElementById(nextRef)) selectCell(nextRef);
      } else if (event.key === 'ArrowRight' && !event.target.value) {
        event.preventDefault();
        const nextRef = String.fromCharCode(col + 1) + row;
        if (document.getElementById(nextRef)) selectCell(nextRef);
      }
    }

    function handleFormulaInput(event) {
      if (event.key === 'Enter' && selectedCell) {
        const value = document.getElementById('formulaInput').value;
        setCellValue(selectedCell, value);
        recalculateAll();
        document.getElementById(selectedCell).focus();
      }
    }

    // Formatting
    function formatCell(style) {
      if (!selectedCell) return;
      const cell = document.getElementById(selectedCell);

      if (style === 'bold') {
        cell.style.fontWeight = cell.style.fontWeight === 'bold' ? 'normal' : 'bold';
      } else if (style === 'italic') {
        cell.style.fontStyle = cell.style.fontStyle === 'italic' ? 'normal' : 'italic';
      } else if (style === 'underline') {
        cell.style.textDecoration = cell.style.textDecoration === 'underline' ? 'none' : 'underline';
      }
    }

    function applyCellColor(type, color) {
      if (!selectedCell) return;
      const cell = document.getElementById(selectedCell);
      if (type === 'color') {
        cell.style.color = color;
      } else {
        cell.style.backgroundColor = color;
      }
    }

    // ==================== FORMAT PAINTER ====================
    let formatPainterActive = false;
    let copiedCellFormat = null;

    function toggleFormatPainter() {
      const btn = document.getElementById('formatPainterBtn');
      const table = document.querySelector('.spreadsheet-table');

      if (formatPainterActive) {
        // Deactivate
        formatPainterActive = false;
        copiedCellFormat = null;
        btn.classList.remove('active');
        table.classList.remove('format-painter-cursor');
        showToast('Format Painter deactivated', 'info');
        return;
      }

      // Copy format from selected cell
      if (!selectedCell) {
        showToast('Select a cell to copy its format', 'warning');
        return;
      }

      const cell = document.getElementById(selectedCell);
      if (!cell) return;

      // Copy computed styles
      const computed = window.getComputedStyle(cell);
      copiedCellFormat = {
        fontWeight: computed.fontWeight,
        fontStyle: computed.fontStyle,
        textDecoration: computed.textDecoration,
        color: computed.color,
        backgroundColor: computed.backgroundColor,
        textAlign: computed.textAlign,
        fontSize: computed.fontSize,
        fontFamily: computed.fontFamily
      };

      formatPainterActive = true;
      btn.classList.add('active');
      table.classList.add('format-painter-cursor');
      showToast('Format copied! Click on cells to apply', 'success');
    }

    // Handle click to apply format
    document.addEventListener('click', function(e) {
      if (!formatPainterActive || !copiedCellFormat) return;

      const cell = e.target.closest('td[id]');
      if (!cell || !cell.id.match(/^[A-Z]+\d+$/)) return;

      // Apply copied format
      cell.style.fontWeight = copiedCellFormat.fontWeight;
      cell.style.fontStyle = copiedCellFormat.fontStyle;
      cell.style.textDecoration = copiedCellFormat.textDecoration;
      cell.style.color = copiedCellFormat.color;
      if (copiedCellFormat.backgroundColor !== 'rgba(0, 0, 0, 0)' && copiedCellFormat.backgroundColor !== 'rgb(255, 255, 255)') {
        cell.style.backgroundColor = copiedCellFormat.backgroundColor;
      }
      cell.style.textAlign = copiedCellFormat.textAlign;

      // Store formatting in cellStyles
      cellStyles[cell.id] = cellStyles[cell.id] || {};
      cellStyles[cell.id].fontWeight = copiedCellFormat.fontWeight;
      cellStyles[cell.id].fontStyle = copiedCellFormat.fontStyle;
      cellStyles[cell.id].textDecoration = copiedCellFormat.textDecoration;
      cellStyles[cell.id].color = copiedCellFormat.color;
      cellStyles[cell.id].backgroundColor = copiedCellFormat.backgroundColor;
      cellStyles[cell.id].textAlign = copiedCellFormat.textAlign;

      // Deactivate after single use
      formatPainterActive = false;
      copiedCellFormat = null;
      document.getElementById('formatPainterBtn').classList.remove('active');
      document.querySelector('.spreadsheet-table').classList.remove('format-painter-cursor');

      showToast('Format applied!', 'success');
    }, true);

    // ESC to cancel format painter
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && formatPainterActive) {
        formatPainterActive = false;
        copiedCellFormat = null;
        document.getElementById('formatPainterBtn').classList.remove('active');
        document.querySelector('.spreadsheet-table').classList.remove('format-painter-cursor');
        showToast('Format Painter cancelled', 'info');
      }
    });

    function formatNumber(format) {
      if (!selectedCell) return;
      const cell = document.getElementById(selectedCell);
      let value = parseFloat(data[selectedCell]);

      if (isNaN(value)) return;

      if (format === 'currency') {
        cell.value = '$' + value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      } else if (format === 'percent') {
        cell.value = (value * 100).toFixed(1) + '%';
      } else if (format === 'decimal') {
        cell.value = value.toFixed(2);
      }
    }

    // Conditional Formatting
    function showConditionalFormat() {
      document.getElementById('cfModal').classList.add('active');
      if (selectedCell) {
        document.getElementById('cfRange').value = selectedCell;
      }
    }

    function hideCfModal() {
      document.getElementById('cfModal').classList.remove('active');
    }

    function applyConditionalFormat() {
      const range = document.getElementById('cfRange').value;
      const style = document.getElementById('cfStyle').value;
      const value = parseFloat(document.getElementById('cfValue').value);

      if (!range) {
        showToast('Please enter a range', 'warning');
        return;
      }

      const parts = range.split(':');
      const start = parts[0];
      const end = parts[1] || parts[0];

      const startCol = start.charCodeAt(0);
      const startRow = parseInt(start.substring(1));
      const endCol = end.charCodeAt(0);
      const endRow = parseInt(end.substring(1));

      const values = [];
      for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
          const ref = String.fromCharCode(c) + r;
          const cellVal = parseFloat(data[ref]);
          if (!isNaN(cellVal)) values.push(cellVal);
        }
      }

      const min = Math.min(...values);
      const max = Math.max(...values);
      const range2 = max - min;

      for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
          const ref = String.fromCharCode(c) + r;
          const cell = document.getElementById(ref);
          const cellVal = parseFloat(data[ref]);

          cell.classList.remove('cf-high', 'cf-medium', 'cf-low');

          if (isNaN(cellVal)) continue;

          if (style === 'colorScale') {
            const percent = (cellVal - min) / range2;
            if (percent >= 0.66) cell.classList.add('cf-high');
            else if (percent >= 0.33) cell.classList.add('cf-medium');
            else cell.classList.add('cf-low');
          } else if (style === 'greaterThan' && cellVal > value) {
            cell.classList.add('cf-high');
          } else if (style === 'lessThan' && cellVal < value) {
            cell.classList.add('cf-low');
          }
        }
      }

      document.getElementById('cfLegend').style.display = 'flex';
      hideCfModal();
      showToast('Conditional formatting applied', 'success');
    }

    // Sorting and Filtering
    function sortData(order) {
      if (!selectedCell) return;
      const col = selectedCell.charAt(0);

      // Get all data in the column
      const rows = [];
      for (let r = 2; r <= ROWS; r++) {
        const ref = col + r;
        if (data[ref] !== undefined && data[ref] !== '') {
          rows.push({ row: r, value: data[ref] });
        }
      }

      rows.sort((a, b) => {
        const aVal = isNaN(a.value) ? a.value : parseFloat(a.value);
        const bVal = isNaN(b.value) ? b.value : parseFloat(b.value);
        if (order === 'asc') return aVal > bVal ? 1 : -1;
        return aVal < bVal ? 1 : -1;
      });

      // Update all columns based on sorted order
      const originalData = {};
      for (let c = 65; c < 65 + COLS; c++) {
        for (let r = 2; r <= ROWS; r++) {
          const ref = String.fromCharCode(c) + r;
          originalData[ref] = data[ref];
        }
      }

      rows.forEach((item, index) => {
        const newRow = index + 2;
        for (let c = 65; c < 65 + COLS; c++) {
          const oldRef = String.fromCharCode(c) + item.row;
          const newRef = String.fromCharCode(c) + newRow;
          setCellValue(newRef, originalData[oldRef] || '');
        }
      });

      showToast('Data sorted', 'success');
    }

    function toggleFilter() {
      filterActive = !filterActive;
      showToast(filterActive ? 'Filter enabled' : 'Filter disabled', 'info');
    }

    // Insert/Delete rows and columns
    function insertRow() {
      if (!selectedCell) return;
      const row = parseInt(selectedCell.substring(1));

      // Shift data down
      for (let r = ROWS; r > row; r--) {
        for (let c = 65; c < 65 + COLS; c++) {
          const ref = String.fromCharCode(c) + r;
          const prevRef = String.fromCharCode(c) + (r - 1);
          setCellValue(ref, data[prevRef] || '');
        }
      }

      // Clear the new row
      for (let c = 65; c < 65 + COLS; c++) {
        setCellValue(String.fromCharCode(c) + row, '');
      }

      showToast('Row inserted', 'success');
    }

    function insertColumn() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const colChar = selectedCell.charAt(0);
      const colIndex = colChar.charCodeAt(0) - 65;

      if (colIndex >= COLS - 1) {
        showToast('Cannot insert column at end', 'error');
        return;
      }

      // Shift data right starting from the last column
      for (let c = COLS - 1; c > colIndex; c--) {
        for (let r = 1; r <= ROWS; r++) {
          const fromRef = String.fromCharCode(64 + c) + r;
          const toRef = String.fromCharCode(65 + c) + r;

          // Move data
          data[toRef] = data[fromRef] || '';
          formulas[toRef] = formulas[fromRef] || '';
          if (formatting[fromRef]) formatting[toRef] = {...formatting[fromRef]};

          // Update cell display
          const cell = document.getElementById(toRef);
          if (cell) {
            cell.value = data[toRef];
            if (formatting[toRef]) applyFormattingToCell(toRef);
          }
        }
      }

      // Clear the inserted column
      for (let r = 1; r <= ROWS; r++) {
        const ref = colChar + r;
        data[ref] = '';
        formulas[ref] = '';
        delete formatting[ref];
        const cell = document.getElementById(ref);
        if (cell) {
          cell.value = '';
          cell.style.cssText = '';
        }
      }

      recalculateAll();
      showToast(`Column ${colChar} inserted`, 'success');
    }

    function deleteRow() {
      if (!selectedCell) return;
      const row = parseInt(selectedCell.substring(1));

      // Shift data up
      for (let r = row; r < ROWS; r++) {
        for (let c = 65; c < 65 + COLS; c++) {
          const ref = String.fromCharCode(c) + r;
          const nextRef = String.fromCharCode(c) + (r + 1);
          data[ref] = data[nextRef] || '';
          formulas[ref] = formulas[nextRef] || '';
          if (formatting[nextRef]) {
            formatting[ref] = {...formatting[nextRef]};
          } else {
            delete formatting[ref];
          }

          const cell = document.getElementById(ref);
          if (cell) {
            cell.value = data[ref];
            if (formatting[ref]) {
              applyFormattingToCell(ref);
            } else {
              cell.style.cssText = '';
            }
          }
        }
      }

      // Clear last row
      for (let c = 65; c < 65 + COLS; c++) {
        const ref = String.fromCharCode(c) + ROWS;
        data[ref] = '';
        formulas[ref] = '';
        delete formatting[ref];
        const cell = document.getElementById(ref);
        if (cell) {
          cell.value = '';
          cell.style.cssText = '';
        }
      }

      recalculateAll();
      showToast('Row deleted', 'success');
    }

    function deleteColumn() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const colChar = selectedCell.charAt(0);
      const colIndex = colChar.charCodeAt(0) - 65;

      // Shift data left
      for (let c = colIndex; c < COLS - 1; c++) {
        for (let r = 1; r <= ROWS; r++) {
          const toRef = String.fromCharCode(65 + c) + r;
          const fromRef = String.fromCharCode(66 + c) + r;

          // Move data
          data[toRef] = data[fromRef] || '';
          formulas[toRef] = formulas[fromRef] || '';
          if (formatting[fromRef]) {
            formatting[toRef] = {...formatting[fromRef]};
          } else {
            delete formatting[toRef];
          }

          // Update cell display
          const cell = document.getElementById(toRef);
          if (cell) {
            cell.value = data[toRef];
            if (formatting[toRef]) {
              applyFormattingToCell(toRef);
            } else {
              cell.style.cssText = '';
            }
          }
        }
      }

      // Clear last column
      for (let r = 1; r <= ROWS; r++) {
        const ref = String.fromCharCode(64 + COLS) + r;
        data[ref] = '';
        formulas[ref] = '';
        delete formatting[ref];
        const cell = document.getElementById(ref);
        if (cell) {
          cell.value = '';
          cell.style.cssText = '';
        }
      }

      recalculateAll();
      showToast(`Column ${colChar} deleted`, 'success');
    }

    // Hidden rows and columns tracking (uses hiddenRows and hiddenCols from state above)

    function hideRow() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const row = parseInt(selectedCell.match(/\d+/)[0]);
      hiddenRows.add(row);

      // Hide the row in the table
      const rowElement = document.querySelector(`tr:nth-child(${row + 1})`);
      if (rowElement) {
        rowElement.style.display = 'none';
      }

      showToast(`Row ${row} hidden`, 'success');
    }

    function hideColumn() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const colChar = selectedCell.charAt(0);
      const colIndex = colChar.charCodeAt(0) - 65;
      hiddenCols.add(colChar);

      // Hide column header and all cells in that column
      const headerCell = document.querySelector(`th:nth-child(${colIndex + 2})`);
      if (headerCell) {
        headerCell.style.display = 'none';
      }

      // Hide all cells in the column
      for (let r = 1; r <= ROWS; r++) {
        const cell = document.getElementById(colChar + r);
        if (cell) {
          cell.parentElement.style.display = 'none';
        }
      }

      showToast(`Column ${colChar} hidden`, 'success');
    }

    function showAllRowsCols() {
      // Show all hidden rows
      hiddenRows.forEach(row => {
        const rowElement = document.querySelector(`tr:nth-child(${row + 1})`);
        if (rowElement) {
          rowElement.style.display = '';
        }
      });
      hiddenRows.clear();

      // Show all hidden columns
      hiddenCols.forEach(colChar => {
        const colIndex = colChar.charCodeAt(0) - 65;
        const headerCell = document.querySelector(`th:nth-child(${colIndex + 2})`);
        if (headerCell) {
          headerCell.style.display = '';
        }

        for (let r = 1; r <= ROWS; r++) {
          const cell = document.getElementById(colChar + r);
          if (cell) {
            cell.parentElement.style.display = '';
          }
        }
      });
      hiddenCols.clear();

      showToast('All rows and columns visible', 'success');
    }

    function autoFitColumnWidth() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const colChar = selectedCell.charAt(0);
      let maxWidth = 60; // Minimum width

      // Find the max content width in this column
      for (let r = 1; r <= ROWS; r++) {
        const ref = colChar + r;
        const cellData = data[ref] || '';
        // Estimate width based on character count (rough approximation)
        const estimatedWidth = Math.max(60, cellData.toString().length * 9 + 20);
        maxWidth = Math.max(maxWidth, Math.min(estimatedWidth, 300)); // Cap at 300px
      }

      // Apply width to all cells in the column
      for (let r = 1; r <= ROWS; r++) {
        const cell = document.getElementById(colChar + r);
        if (cell) {
          cell.style.width = maxWidth + 'px';
        }
      }

      // Also set header width
      const colIndex = colChar.charCodeAt(0) - 65;
      const headerCell = document.querySelector(`th:nth-child(${colIndex + 2})`);
      if (headerCell) {
        headerCell.style.width = maxWidth + 'px';
      }

      showToast(`Column ${colChar} auto-fitted to ${maxWidth}px`, 'success');
    }

    function selectEntireRow() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const row = parseInt(selectedCell.match(/\d+/)[0]);
      selectedRange = [];

      // Select all cells in the row
      for (let c = 0; c < COLS; c++) {
        const ref = String.fromCharCode(65 + c) + row;
        selectedRange.push(ref);

        const cell = document.getElementById(ref);
        if (cell) {
          cell.classList.add('selected');
        }
      }

      // Update selection info
      document.getElementById('selectionInfo').textContent = `Row ${row}`;
      document.getElementById('cellCount').textContent = COLS;

      // Calculate stats for the row
      updateSelectionStats();
      showToast(`Selected entire row ${row}`, 'success');
    }

    function selectEntireColumn() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      const colChar = selectedCell.charAt(0);
      selectedRange = [];

      // Select all cells in the column
      for (let r = 1; r <= ROWS; r++) {
        const ref = colChar + r;
        selectedRange.push(ref);

        const cell = document.getElementById(ref);
        if (cell) {
          cell.classList.add('selected');
        }
      }

      // Update selection info
      document.getElementById('selectionInfo').textContent = `Column ${colChar}`;
      document.getElementById('cellCount').textContent = ROWS;

      // Calculate stats for the column
      updateSelectionStats();
      showToast(`Selected entire column ${colChar}`, 'success');
    }

    function updateSelectionStats() {
      let sum = 0;
      let count = 0;
      let numericCount = 0;

      selectedRange.forEach(ref => {
        const val = data[ref];
        if (val !== undefined && val !== '') {
          count++;
          const num = parseFloat(val);
          if (!isNaN(num)) {
            sum += num;
            numericCount++;
          }
        }
      });

      document.getElementById('sumDisplay').textContent = Math.round(sum * 100) / 100;
      document.getElementById('avgDisplay').textContent = numericCount > 0 ? Math.round((sum / numericCount) * 100) / 100 : 0;
      document.getElementById('countDisplay').textContent = count;
    }

    // Go To Cell functionality
    let recentGoToLocations = [];

    function showGoToCell() {
      const modal = document.getElementById('goToCellModal');
      const input = document.getElementById('goToCellRef');
      const namedRangeSelect = document.getElementById('goToNamedRange');

      // Populate named ranges dropdown
      namedRangeSelect.innerHTML = '<option value="">-- Select Named Range --</option>';
      for (const name in namedRanges) {
        const opt = document.createElement('option');
        opt.value = namedRanges[name];
        opt.textContent = `${name} (${namedRanges[name]})`;
        namedRangeSelect.appendChild(opt);
      }

      // Populate recent locations
      renderRecentLocations();

      modal.classList.add('show');
      input.value = '';
      input.focus();

      // Handle Enter key
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          goToCell();
        } else if (e.key === 'Escape') {
          hideGoToCell();
        }
      };
    }

    function hideGoToCell() {
      document.getElementById('goToCellModal').classList.remove('show');
    }

    function renderRecentLocations() {
      const container = document.getElementById('recentLocations');

      if (recentGoToLocations.length === 0) {
        container.innerHTML = '<div style="color: #999; font-size: 12px;">No recent locations</div>';
        return;
      }

      container.innerHTML = recentGoToLocations.map(loc =>
        `<div style="padding: 4px 8px; cursor: pointer; border-radius: 3px; margin-bottom: 2px;"
              onmouseover="this.style.background='#e8f0fe'"
              onmouseout="this.style.background='transparent'"
              onclick="goToCellDirect('${loc}')">${loc}</div>`
      ).join('');
    }

    function selectNamedRangeForGoTo() {
      const select = document.getElementById('goToNamedRange');
      const input = document.getElementById('goToCellRef');
      if (select.value) {
        input.value = select.value.split(':')[0]; // Use start of range
      }
    }

    function goToCell() {
      const input = document.getElementById('goToCellRef');
      const ref = input.value.trim().toUpperCase();

      if (!ref) {
        showToast('Please enter a cell reference', 'error');
        return;
      }

      goToCellDirect(ref);
    }

    function goToCellDirect(ref) {
      // Parse cell reference (supports A1, AA1, etc.)
      const match = ref.match(/^([A-Z]+)(\d+)$/);

      if (!match) {
        showToast('Invalid cell reference. Use format like A1, B10, AA50', 'error');
        return;
      }

      const colStr = match[1];
      const row = parseInt(match[2]);

      // Convert column letters to number
      let col = 0;
      for (let i = 0; i < colStr.length; i++) {
        col = col * 26 + (colStr.charCodeAt(i) - 64);
      }

      // Validate bounds
      if (row < 1 || row > ROWS) {
        showToast(`Row must be between 1 and ${ROWS}`, 'error');
        return;
      }

      if (col < 1 || col > COLS) {
        showToast(`Column must be between A and ${String.fromCharCode(64 + COLS)}`, 'error');
        return;
      }

      // Find the cell
      const cellRef = colStr + row;
      const cell = document.getElementById(cellRef);

      if (cell) {
        // Clear previous selection
        document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));

        // Select and scroll to cell
        cell.classList.add('selected');
        cell.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
        cell.focus();

        selectedCell = cellRef;
        selectedRange = [cellRef];

        // Update formula bar
        document.getElementById('formulaInput').value = data[cellRef] || formulas[cellRef] || '';
        document.getElementById('selectionInfo').textContent = cellRef;

        // Add to recent locations (keep unique, max 10)
        recentGoToLocations = recentGoToLocations.filter(loc => loc !== cellRef);
        recentGoToLocations.unshift(cellRef);
        if (recentGoToLocations.length > 10) {
          recentGoToLocations.pop();
        }

        hideGoToCell();
        showToast(`Navigated to ${cellRef}`, 'success');
      } else {
        showToast('Cell not found', 'error');
      }
    }

    function mergeCells() {
      showToast('Select a range to merge', 'info');
    }

    // Functions insertion
    function insertFunction(func) {
      const formulaInput = document.getElementById('formulaInput');
      let template = '';

      switch (func) {
        case 'SUM': template = '=SUM(A1:A10)'; break;
        case 'AVERAGE': template = '=AVERAGE(A1:A10)'; break;
        case 'COUNT': template = '=COUNT(A1:A10)'; break;
        case 'MAX': template = '=MAX(A1:A10)'; break;
        case 'MIN': template = '=MIN(A1:A10)'; break;
        case 'IF': template = '=IF(A1>10,"Yes","No")'; break;
        case 'VLOOKUP': template = '=VLOOKUP(A1,A1:D10,2)'; break;
        case 'HLOOKUP': template = '=HLOOKUP(A1,A1:D10,2)'; break;
        case 'INDEX': template = '=INDEX(A1:D10,2,3)'; break;
        case 'MATCH': template = '=MATCH(A1,A1:A10,0)'; break;
        case 'CONCATENATE': template = '=CONCATENATE(A1,B1)'; break;
        case 'LEFT': template = '=LEFT(A1,5)'; break;
        case 'RIGHT': template = '=RIGHT(A1,5)'; break;
        case 'LEN': template = '=LEN(A1)'; break;
      }

      formulaInput.value = template;
      formulaInput.focus();
      formulaInput.select();
    }

    // AutoSum functions - automatically detect range and insert formula
    function autoSum() {
      autoFunction('SUM');
    }

    function autoAverage() {
      autoFunction('AVERAGE');
    }

    function autoCount() {
      autoFunction('COUNT');
    }

    function autoFunction(funcName) {
      // If we have a selection, use it
      if (selectedRange && selectedRange.length > 1) {
        const rangeStr = `${selectedRange[0]}:${selectedRange[selectedRange.length - 1]}`;
        // Find cell below selection to put result
        const lastCell = selectedRange[selectedRange.length - 1];
        const col = lastCell.match(/[A-Z]+/)[0];
        const row = parseInt(lastCell.match(/\d+/)[0]) + 1;
        const resultCell = col + row;

        formulas[resultCell] = `=${funcName}(${rangeStr})`;
        recalculateAll();
        renderSpreadsheet();
        showToast(`${funcName} inserted at ${resultCell}`, 'success');
        return;
      }

      // If we have a current cell, try to detect range above or to the left
      if (currentCell) {
        const col = currentCell.match(/[A-Z]+/)[0];
        const row = parseInt(currentCell.match(/\d+/)[0]);

        // Check cells above
        let startRow = row - 1;
        while (startRow > 0) {
          const checkCell = col + startRow;
          const val = data[checkCell];
          if (val === undefined || val === '' || isNaN(parseFloat(val))) {
            break;
          }
          startRow--;
        }
        startRow++; // Go back to last valid cell

        if (startRow < row) {
          const rangeStr = `${col}${startRow}:${col}${row - 1}`;
          formulas[currentCell] = `=${funcName}(${rangeStr})`;
          recalculateAll();
          renderSpreadsheet();
          showToast(`${funcName}(${rangeStr}) inserted`, 'success');
          return;
        }

        // Check cells to the left
        let startCol = col.charCodeAt(0) - 1;
        while (startCol >= 65) { // 'A' = 65
          const checkCell = String.fromCharCode(startCol) + row;
          const val = data[checkCell];
          if (val === undefined || val === '' || isNaN(parseFloat(val))) {
            break;
          }
          startCol--;
        }
        startCol++; // Go back to last valid cell

        if (startCol < col.charCodeAt(0)) {
          const rangeStr = `${String.fromCharCode(startCol)}${row}:${String.fromCharCode(col.charCodeAt(0) - 1)}${row}`;
          formulas[currentCell] = `=${funcName}(${rangeStr})`;
          recalculateAll();
          renderSpreadsheet();
          showToast(`${funcName}(${rangeStr}) inserted`, 'success');
          return;
        }
      }

      showToast('Select cells with numbers or position below/right of data', 'info');
    }

    // Charts
    let chartInstance = null;

    function showChartModal() {
      document.getElementById('chartModal').classList.add('active');
      updateTrendlineVisibility();
      // Add listener for chart type changes
      document.getElementById('chartType').addEventListener('change', updateTrendlineVisibility);
    }

    function updateTrendlineVisibility() {
      const type = document.getElementById('chartType').value;
      const trendlineGroup = document.getElementById('trendlineGroup');
      // Trendlines only make sense for line, scatter, bar charts
      const supportsTrendline = ['line', 'scatter', 'bar', 'area'].includes(type);
      trendlineGroup.style.display = supportsTrendline ? 'block' : 'none';
    }

    function updateTrendlineOptions() {
      const trendlineType = document.getElementById('chartTrendline').value;
      const optionsDiv = document.getElementById('trendlineOptions');
      const polynomialDiv = document.getElementById('polynomialOrder');
      const movingAvgDiv = document.getElementById('movingAvgPeriod');

      optionsDiv.style.display = trendlineType !== 'none' ? 'block' : 'none';
      polynomialDiv.style.display = trendlineType === 'polynomial' ? 'block' : 'none';
      movingAvgDiv.style.display = trendlineType === 'movingAverage' ? 'block' : 'none';
    }

    function hideChartModal() {
      document.getElementById('chartModal').classList.remove('active');
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
    }

    function previewChart() {
      const range = document.getElementById('chartRange').value;
      const type = document.getElementById('chartType').value;
      const title = document.getElementById('chartTitle').value || 'Chart';

      if (!range) {
        showToast('Please enter a data range', 'warning');
        return;
      }

      const parts = range.split(':');
      const matrix = getRangeAsMatrix(parts[0], parts[1]);

      const colors = [
        '#4285f4', '#34a853', '#fbbc04', '#ea4335', '#9c27b0',
        '#ff9800', '#00bcd4', '#8bc34a', '#e91e63', '#3f51b5'
      ];

      let chartConfig;

      // Handle scatter and bubble charts differently
      if (type === 'scatter' || type === 'bubble') {
        const datasets = [];
        // For scatter: X values in col 1, Y values in col 2
        // For bubble: X in col 1, Y in col 2, R (radius) in col 3
        const dataPoints = matrix.slice(1).map((row, idx) => {
          const point = {
            x: parseFloat(row[0]) || 0,
            y: parseFloat(row[1]) || 0
          };
          if (type === 'bubble') {
            point.r = parseFloat(row[2]) || 5;
          }
          return point;
        });

        datasets.push({
          label: matrix[0][1] || 'Data Series',
          data: dataPoints,
          backgroundColor: colors[0] + '80',
          borderColor: colors[0],
          borderWidth: 1
        });

        chartConfig = {
          type: type,
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: title } },
            scales: {
              x: { title: { display: true, text: matrix[0][0] || 'X' } },
              y: { title: { display: true, text: matrix[0][1] || 'Y' } }
            }
          }
        };
      } else if (type === 'area') {
        // Area chart is a line chart with fill
        const labels = matrix.slice(1).map(row => row[0]);
        const datasets = [];

        for (let c = 1; c < matrix[0].length; c++) {
          datasets.push({
            label: matrix[0][c] || `Series ${c}`,
            data: matrix.slice(1).map(row => parseFloat(row[c]) || 0),
            backgroundColor: colors[(c - 1) % colors.length] + '40',
            borderColor: colors[(c - 1) % colors.length],
            fill: true,
            tension: 0.4
          });
        }

        chartConfig = {
          type: 'line',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: title } }
          }
        };
      } else {
        // Standard charts (bar, line, pie, doughnut, radar, polarArea)
        const labels = matrix.slice(1).map(row => row[0]);
        const datasets = [];

        for (let c = 1; c < matrix[0].length; c++) {
          const dataset = {
            label: matrix[0][c] || `Series ${c}`,
            data: matrix.slice(1).map(row => parseFloat(row[c]) || 0)
          };

          // Different color handling for different chart types
          if (type === 'pie' || type === 'doughnut' || type === 'polarArea') {
            dataset.backgroundColor = labels.map((_, i) => colors[i % colors.length]);
          } else if (type === 'radar') {
            dataset.backgroundColor = colors[(c - 1) % colors.length] + '40';
            dataset.borderColor = colors[(c - 1) % colors.length];
            dataset.pointBackgroundColor = colors[(c - 1) % colors.length];
          } else {
            dataset.backgroundColor = colors[(c - 1) % colors.length];
            dataset.borderColor = colors[(c - 1) % colors.length];
          }

          datasets.push(dataset);
        }

        chartConfig = {
          type: type,
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: title } }
          }
        };

        // Add trendline if applicable
        const trendlineType = document.getElementById('chartTrendline')?.value;
        if (trendlineType && trendlineType !== 'none' && datasets.length > 0 && (type === 'line' || type === 'bar' || type === 'area')) {
          const yData = datasets[0].data;
          const xData = yData.map((_, i) => i + 1);
          const options = {
            order: parseInt(document.getElementById('trendlineOrder')?.value) || 2,
            period: parseInt(document.getElementById('trendlinePeriod')?.value) || 2
          };

          const trendline = calculateTrendline(xData, yData, trendlineType, options);
          if (trendline) {
            const trendlineColor = document.getElementById('trendlineColor')?.value || '#ff6384';
            const showEquation = document.getElementById('showTrendlineEquation')?.checked;
            const showR2 = document.getElementById('showTrendlineR2')?.checked;

            let trendlineLabel = 'Trendline';
            if (showEquation) trendlineLabel += `: ${trendline.equation}`;
            if (showR2 && trendline.r2 !== null) trendlineLabel += ` (R¬≤ = ${trendline.r2.toFixed(4)})`;

            chartConfig.data.datasets.push({
              label: trendlineLabel,
              data: trendline.data,
              type: 'line',
              borderColor: trendlineColor,
              backgroundColor: 'transparent',
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            });
          }
        }
      }

      const preview = document.getElementById('chartPreview');
      preview.innerHTML = '<canvas id="previewCanvas"></canvas>';

      if (chartInstance) chartInstance.destroy();

      chartInstance = new Chart(document.getElementById('previewCanvas'), chartConfig);
    }

    function createChart() {
      previewChart();
      showToast('Chart created! (View in preview)', 'success');
    }

    // Trendline calculations
    function calculateTrendline(xData, yData, type, options = {}) {
      const n = xData.length;
      if (n < 2) return null;

      let trendlineData = [];
      let equation = '';
      let r2 = 0;

      // Calculate means
      const meanX = xData.reduce((a, b) => a + b, 0) / n;
      const meanY = yData.reduce((a, b) => a + b, 0) / n;

      switch (type) {
        case 'linear': {
          // y = mx + b
          let sumXY = 0, sumX2 = 0;
          for (let i = 0; i < n; i++) {
            sumXY += (xData[i] - meanX) * (yData[i] - meanY);
            sumX2 += (xData[i] - meanX) ** 2;
          }
          const m = sumX2 !== 0 ? sumXY / sumX2 : 0;
          const b = meanY - m * meanX;

          trendlineData = xData.map(x => m * x + b);
          equation = `y = ${m.toFixed(4)}x ${b >= 0 ? '+' : ''} ${b.toFixed(4)}`;
          r2 = calculateR2(yData, trendlineData);
          break;
        }

        case 'exponential': {
          // y = a * e^(bx)
          const lnY = yData.map(y => y > 0 ? Math.log(y) : 0);
          let sumXlnY = 0, sumX2 = 0;
          const meanLnY = lnY.reduce((a, b) => a + b, 0) / n;

          for (let i = 0; i < n; i++) {
            sumXlnY += (xData[i] - meanX) * (lnY[i] - meanLnY);
            sumX2 += (xData[i] - meanX) ** 2;
          }
          const bExp = sumX2 !== 0 ? sumXlnY / sumX2 : 0;
          const aExp = Math.exp(meanLnY - bExp * meanX);

          trendlineData = xData.map(x => aExp * Math.exp(bExp * x));
          equation = `y = ${aExp.toFixed(4)}e^(${bExp.toFixed(4)}x)`;
          r2 = calculateR2(yData, trendlineData);
          break;
        }

        case 'polynomial': {
          const order = options.order || 2;
          const coeffs = polynomialRegression(xData, yData, order);
          trendlineData = xData.map(x => {
            let val = 0;
            for (let i = 0; i <= order; i++) {
              val += coeffs[i] * Math.pow(x, i);
            }
            return val;
          });
          equation = 'y = ' + coeffs.map((c, i) => {
            if (i === 0) return c.toFixed(4);
            return `${c >= 0 ? '+' : ''}${c.toFixed(4)}x${i > 1 ? '^' + i : ''}`;
          }).reverse().join(' ');
          r2 = calculateR2(yData, trendlineData);
          break;
        }

        case 'logarithmic': {
          // y = a * ln(x) + b
          const lnX = xData.map(x => x > 0 ? Math.log(x) : 0);
          const meanLnX = lnX.reduce((a, b) => a + b, 0) / n;
          let sumLnXY = 0, sumLnX2 = 0;

          for (let i = 0; i < n; i++) {
            sumLnXY += (lnX[i] - meanLnX) * (yData[i] - meanY);
            sumLnX2 += (lnX[i] - meanLnX) ** 2;
          }
          const aLog = sumLnX2 !== 0 ? sumLnXY / sumLnX2 : 0;
          const bLog = meanY - aLog * meanLnX;

          trendlineData = xData.map(x => x > 0 ? aLog * Math.log(x) + bLog : 0);
          equation = `y = ${aLog.toFixed(4)}ln(x) ${bLog >= 0 ? '+' : ''} ${bLog.toFixed(4)}`;
          r2 = calculateR2(yData, trendlineData);
          break;
        }

        case 'power': {
          // y = a * x^b
          const lnX = xData.map(x => x > 0 ? Math.log(x) : 0);
          const lnY = yData.map(y => y > 0 ? Math.log(y) : 0);
          const meanLnX = lnX.reduce((a, b) => a + b, 0) / n;
          const meanLnY = lnY.reduce((a, b) => a + b, 0) / n;

          let sumLnXLnY = 0, sumLnX2 = 0;
          for (let i = 0; i < n; i++) {
            sumLnXLnY += (lnX[i] - meanLnX) * (lnY[i] - meanLnY);
            sumLnX2 += (lnX[i] - meanLnX) ** 2;
          }
          const bPow = sumLnX2 !== 0 ? sumLnXLnY / sumLnX2 : 0;
          const aPow = Math.exp(meanLnY - bPow * meanLnX);

          trendlineData = xData.map(x => x > 0 ? aPow * Math.pow(x, bPow) : 0);
          equation = `y = ${aPow.toFixed(4)}x^${bPow.toFixed(4)}`;
          r2 = calculateR2(yData, trendlineData);
          break;
        }

        case 'movingAverage': {
          const period = options.period || 2;
          trendlineData = [];
          for (let i = 0; i < n; i++) {
            if (i < period - 1) {
              trendlineData.push(null);
            } else {
              let sum = 0;
              for (let j = 0; j < period; j++) {
                sum += yData[i - j];
              }
              trendlineData.push(sum / period);
            }
          }
          equation = `${period}-period Moving Average`;
          r2 = null; // R¬≤ not applicable for moving average
          break;
        }
      }

      return { data: trendlineData, equation, r2 };
    }

    function polynomialRegression(xData, yData, order) {
      const n = xData.length;
      // Build matrix for least squares
      const matrix = [];
      const vector = [];

      for (let i = 0; i <= order; i++) {
        matrix[i] = [];
        vector[i] = 0;
        for (let j = 0; j <= order; j++) {
          matrix[i][j] = 0;
          for (let k = 0; k < n; k++) {
            matrix[i][j] += Math.pow(xData[k], i + j);
          }
        }
        for (let k = 0; k < n; k++) {
          vector[i] += yData[k] * Math.pow(xData[k], i);
        }
      }

      // Solve using Gaussian elimination
      return gaussianElimination(matrix, vector);
    }

    function gaussianElimination(matrix, vector) {
      const n = matrix.length;
      const aug = matrix.map((row, i) => [...row, vector[i]]);

      for (let i = 0; i < n; i++) {
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) maxRow = k;
        }
        [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];

        for (let k = i + 1; k < n; k++) {
          const factor = aug[k][i] / aug[i][i];
          for (let j = i; j <= n; j++) {
            aug[k][j] -= factor * aug[i][j];
          }
        }
      }

      const solution = new Array(n).fill(0);
      for (let i = n - 1; i >= 0; i--) {
        solution[i] = aug[i][n];
        for (let j = i + 1; j < n; j++) {
          solution[i] -= aug[i][j] * solution[j];
        }
        solution[i] /= aug[i][i];
      }

      return solution;
    }

    function calculateR2(actual, predicted) {
      const n = actual.length;
      const meanActual = actual.reduce((a, b) => a + b, 0) / n;

      let ssTot = 0, ssRes = 0;
      for (let i = 0; i < n; i++) {
        ssTot += (actual[i] - meanActual) ** 2;
        ssRes += (actual[i] - predicted[i]) ** 2;
      }

      return ssTot !== 0 ? 1 - (ssRes / ssTot) : 0;
    }

    // Pivot Tables
    function showPivotModal() {
      document.getElementById('pivotModal').classList.add('active');
    }

    function hidePivotModal() {
      document.getElementById('pivotModal').classList.remove('active');
    }

    function generatePivot() {
      const range = document.getElementById('pivotRange').value;
      const rowField = document.getElementById('pivotRow').value.toUpperCase();
      const valueField = document.getElementById('pivotValue').value.toUpperCase();
      const agg = document.getElementById('pivotAgg').value;

      if (!range || !rowField || !valueField) {
        showToast('Please fill all fields', 'warning');
        return;
      }

      const parts = range.split(':');
      const matrix = getRangeAsMatrix(parts[0], parts[1]);

      const rowIdx = rowField.charCodeAt(0) - parts[0].charCodeAt(0);
      const valIdx = valueField.charCodeAt(0) - parts[0].charCodeAt(0);

      const pivot = {};
      for (let r = 1; r < matrix.length; r++) {
        const key = matrix[r][rowIdx];
        const val = parseFloat(matrix[r][valIdx]) || 0;

        if (!pivot[key]) pivot[key] = [];
        pivot[key].push(val);
      }

      // Calculate aggregations
      const results = {};
      for (const key in pivot) {
        const values = pivot[key];
        switch (agg) {
          case 'sum': results[key] = values.reduce((a, b) => a + b, 0); break;
          case 'count': results[key] = values.length; break;
          case 'average': results[key] = values.reduce((a, b) => a + b, 0) / values.length; break;
          case 'max': results[key] = Math.max(...values); break;
          case 'min': results[key] = Math.min(...values); break;
        }
      }

      // Display pivot table
      let html = '<table class="pivot-table"><thead><tr><th>Row Label</th><th>' + agg.toUpperCase() + ' of ' + valueField + '</th></tr></thead><tbody>';
      let total = 0;
      for (const key in results) {
        html += `<tr><td class="pivot-row-header">${key}</td><td class="pivot-value">${results[key].toFixed(2)}</td></tr>`;
        total += results[key];
      }
      html += `<tr style="font-weight: bold;"><td>Grand Total</td><td class="pivot-value">${total.toFixed(2)}</td></tr>`;
      html += '</tbody></table>';

      document.getElementById('pivotPreview').innerHTML = html;
      showToast('Pivot table generated', 'success');
    }

    // Macros
    function showMacroModal() {
      document.getElementById('macroModal').classList.add('active');
      updateMacroList();
    }

    function hideMacroModal() {
      document.getElementById('macroModal').classList.remove('active');
    }

    function updateMacroList() {
      const select = document.getElementById('savedMacros');
      select.innerHTML = '<option value="">-- Select a macro --</option>';
      for (const name in macros) {
        select.innerHTML += `<option value="${name}">${name}</option>`;
      }
    }

    function saveMacro() {
      const name = document.getElementById('macroName').value.trim();
      const code = document.getElementById('macroCode').value;

      if (!name) {
        showToast('Please enter a macro name', 'warning');
        return;
      }

      macros[name] = code;
      localStorage.setItem('ninjaCalcMacros', JSON.stringify(macros));
      updateMacroList();
      showToast('Macro saved', 'success');
    }

    function loadMacro() {
      const name = document.getElementById('savedMacros').value;
      if (name && macros[name]) {
        document.getElementById('macroName').value = name;
        document.getElementById('macroCode').value = macros[name];
      }
    }

    function runMacro() {
      const code = document.getElementById('macroCode').value;

      try {
        // Create safe context
        const safeEval = new Function('getCellValue', 'setCellValue', 'getRange', 'setRange', code);
        safeEval(getCellValue, setCellValue, getRange, setRange);
        recalculateAll();
        showToast('Macro executed successfully', 'success');
      } catch (e) {
        showToast('Macro error: ' + e.message, 'error');
      }
    }

    function getRange(range) {
      const parts = range.split(':');
      return getRangeValues(parts[0], parts[1] || parts[0]);
    }

    function setRange(range, values) {
      const parts = range.split(':');
      const start = parts[0];
      const startCol = start.charCodeAt(0);
      const startRow = parseInt(start.substring(1));

      let idx = 0;
      for (let i = 0; i < values.length; i++) {
        const ref = String.fromCharCode(startCol) + (startRow + i);
        setCellValue(ref, values[i]);
      }
    }

    // Status bar
    function updateStatusBar() {
      // Update selection info
      const selectionInfo = document.getElementById('selectionInfo');
      const cellCount = document.getElementById('cellCount');

      if (selectedRange && selectedRange.length > 1) {
        selectionInfo.textContent = `${selectedRange[0]}:${selectedRange[selectedRange.length - 1]}`;
        cellCount.textContent = selectedRange.length;
      } else if (selectedCell) {
        selectionInfo.textContent = selectedCell;
        cellCount.textContent = '1';
      }

      // Calculate stats for selection (if multiple) or all data
      const values = [];
      const cellsToCheck = (selectedRange && selectedRange.length > 1) ? selectedRange : Object.keys(data);

      for (const ref of cellsToCheck) {
        const val = parseFloat(data[ref]);
        if (!isNaN(val)) values.push(val);
      }

      if (values.length > 0) {
        const sum = values.reduce((a, b) => a + b, 0);
        document.getElementById('sumDisplay').textContent = sum.toLocaleString(undefined, {maximumFractionDigits: 2});
        document.getElementById('avgDisplay').textContent = (sum / values.length).toLocaleString(undefined, {maximumFractionDigits: 2});
        document.getElementById('countDisplay').textContent = values.length;
      } else {
        document.getElementById('sumDisplay').textContent = '0';
        document.getElementById('avgDisplay').textContent = '0';
        document.getElementById('countDisplay').textContent = '0';
      }
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        document.getElementById('homeToolbar').style.display = 'none';
        document.getElementById('formulasToolbar').style.display = 'none';
        document.getElementById('dataToolbar').style.display = 'none';

        const tabName = tab.dataset.tab;
        if (tabName === 'home') {
          document.getElementById('homeToolbar').style.display = 'flex';
        } else if (tabName === 'formulas') {
          document.getElementById('formulasToolbar').style.display = 'flex';
        } else if (tabName === 'data') {
          document.getElementById('dataToolbar').style.display = 'flex';
        }
      });
    });

    // Export
    function exportCSV() {
      let csv = '';
      for (let r = 1; r <= 50; r++) {
        const row = [];
        for (let c = 65; c < 65 + 10; c++) {
          const ref = String.fromCharCode(c) + r;
          row.push(data[ref] !== undefined ? `"${data[ref]}"` : '');
        }
        csv += row.join(',') + '\n';
      }

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = (document.getElementById('fileName').value || 'spreadsheet') + '.csv';
      a.click();

      showToast('CSV exported', 'success');
    }

    // Toast
    function showToast(message, type = 'info') {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // Remove duplicates
    function removeDuplicates() {
      showToast('Select a range first', 'info');
    }

    function textToColumns() {
      if (!selectedCell && (!selectedRange || selectedRange.length === 0)) {
        showToast('Select cells containing text to split', 'error');
        return;
      }
      document.getElementById('textToColumnsModal').style.display = 'flex';
      updateTTCPreview();

      // Add event listeners for delimiter radio buttons
      document.querySelectorAll('input[name="ttcDelimiter"]').forEach(radio => {
        radio.onchange = () => {
          const customGroup = document.getElementById('customDelimiterGroup');
          customGroup.style.display = radio.value === 'custom' ? 'block' : 'none';
          updateTTCPreview();
        };
      });
      document.getElementById('customDelimiter').oninput = updateTTCPreview;
      document.getElementById('ttcTrimSpaces').onchange = updateTTCPreview;
    }

    function hideTextToColumns() {
      document.getElementById('textToColumnsModal').style.display = 'none';
    }

    function getTTCDelimiter() {
      const selected = document.querySelector('input[name="ttcDelimiter"]:checked').value;
      switch (selected) {
        case 'comma': return ',';
        case 'tab': return '\t';
        case 'semicolon': return ';';
        case 'space': return ' ';
        case 'pipe': return '|';
        case 'custom': return document.getElementById('customDelimiter').value || ',';
        default: return ',';
      }
    }

    function updateTTCPreview() {
      const preview = document.getElementById('ttcPreview');
      const cells = selectedRange && selectedRange.length > 0 ? selectedRange : (selectedCell ? [selectedCell] : []);

      if (cells.length === 0) {
        preview.textContent = 'Select cells to preview';
        return;
      }

      // Get first cell's value
      const firstCell = cells[0];
      const value = data[firstCell] || '';

      if (!value) {
        preview.textContent = '(empty cell)';
        return;
      }

      const delimiter = getTTCDelimiter();
      const trimSpaces = document.getElementById('ttcTrimSpaces').checked;
      let parts = value.split(delimiter);

      if (trimSpaces) {
        parts = parts.map(p => p.trim());
      }

      preview.innerHTML = parts.map((p, i) =>
        `<span style="background: ${i % 2 === 0 ? '#e8f0fe' : '#fff3e0'}; padding: 2px 6px; margin-right: 4px; border-radius: 3px;">${p || '(empty)'}</span>`
      ).join('‚Üí ');
    }

    function executeTextToColumns() {
      const cells = selectedRange && selectedRange.length > 0 ? selectedRange : (selectedCell ? [selectedCell] : []);

      if (cells.length === 0) {
        showToast('No cells selected', 'error');
        return;
      }

      const delimiter = getTTCDelimiter();
      const trimSpaces = document.getElementById('ttcTrimSpaces').checked;

      // Group cells by row
      const rowGroups = {};
      cells.forEach(cellRef => {
        const row = cellRef.slice(1);
        if (!rowGroups[row]) rowGroups[row] = [];
        rowGroups[row].push(cellRef);
      });

      let maxCols = 0;

      // Process each row
      Object.keys(rowGroups).forEach(row => {
        const rowCells = rowGroups[row].sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));
        const firstCell = rowCells[0];
        const startCol = firstCell.charCodeAt(0) - 65;
        const value = data[firstCell] || '';

        if (!value) return;

        let parts = value.split(delimiter);
        if (trimSpaces) {
          parts = parts.map(p => p.trim());
        }

        maxCols = Math.max(maxCols, parts.length);

        // Place each part in consecutive columns
        parts.forEach((part, i) => {
          const targetCol = startCol + i;
          if (targetCol > 25) return; // Don't exceed column Z

          const targetRef = String.fromCharCode(65 + targetCol) + row;
          data[targetRef] = part;

          const cell = document.getElementById(targetRef);
          if (cell) cell.value = part;
        });
      });

      hideTextToColumns();
      showToast(`Split into ${maxCols} columns`, 'success');
    }

    // ==================== CLEAR CELL FUNCTIONS ====================
    function clearCellFormatting() {
      const cells = selectedRange && selectedRange.length > 0 ? selectedRange : (selectedCell ? [selectedCell] : []);

      if (cells.length === 0) {
        showToast('Select cells first', 'error');
        return;
      }

      cells.forEach(cellRef => {
        // Clear formatting object
        delete formatting[cellRef];

        // Reset cell styles
        const cell = document.getElementById(cellRef);
        if (cell) {
          cell.style.fontWeight = '';
          cell.style.fontStyle = '';
          cell.style.textDecoration = '';
          cell.style.color = '';
          cell.style.backgroundColor = '';
          cell.style.textAlign = '';
          cell.style.fontSize = '';
          cell.style.fontFamily = '';
          cell.classList.remove('cf-high', 'cf-medium', 'cf-low');
        }
      });

      showToast(`Cleared formatting from ${cells.length} cell(s)`, 'success');
    }

    function clearCellContents() {
      const cells = selectedRange && selectedRange.length > 0 ? selectedRange : (selectedCell ? [selectedCell] : []);

      if (cells.length === 0) {
        showToast('Select cells first', 'error');
        return;
      }

      cells.forEach(cellRef => {
        // Clear data and formulas
        delete data[cellRef];
        delete formulas[cellRef];

        // Clear cell value
        const cell = document.getElementById(cellRef);
        if (cell) {
          cell.value = '';
        }
      });

      recalculateAll();
      showToast(`Cleared contents from ${cells.length} cell(s)`, 'success');
    }

    function clearCellAll() {
      const cells = selectedRange && selectedRange.length > 0 ? selectedRange : (selectedCell ? [selectedCell] : []);

      if (cells.length === 0) {
        showToast('Select cells first', 'error');
        return;
      }

      cells.forEach(cellRef => {
        // Clear everything
        delete data[cellRef];
        delete formulas[cellRef];
        delete formatting[cellRef];
        delete cellComments[cellRef];
        delete dataValidation[cellRef];
        delete cellHyperlinks[cellRef];

        // Reset cell
        const cell = document.getElementById(cellRef);
        if (cell) {
          cell.value = '';
          cell.style.cssText = '';
          cell.title = '';
          cell.onclick = null;
          cell.classList.remove('cf-high', 'cf-medium', 'cf-low', 'has-comment');
        }
      });

      recalculateAll();
      showToast(`Cleared all from ${cells.length} cell(s)`, 'success');
    }

    // ==================== CELL STYLES GALLERY ====================
    let cellStylesPopup = null;

    const cellStyles = [
      // Good, Bad, Neutral
      { name: 'Good', bg: '#c6efce', color: '#006100', border: '1px solid #006100' },
      { name: 'Bad', bg: '#ffc7ce', color: '#9c0006', border: '1px solid #9c0006' },
      { name: 'Neutral', bg: '#ffeb9c', color: '#9c5700', border: '1px solid #9c5700' },
      // Data styles
      { name: 'Calculation', bg: '#f2f2f2', color: '#fa7d00', border: '1px solid #7f7f7f', bold: true },
      { name: 'Check Cell', bg: '#a5a5a5', color: '#ffffff', border: '1px solid #3f3f3f', bold: true },
      { name: 'Input', bg: '#ffcc99', color: '#3f3f76', border: '1px solid #7f7f7f' },
      { name: 'Output', bg: '#f2f2f2', color: '#3f3f3f', border: '1px solid #3f3f3f', bold: true },
      { name: 'Warning', bg: '#ffffff', color: '#ff0000', border: 'none' },
      // Titles and Headings
      { name: 'Title', bg: 'transparent', color: '#1a73e8', border: 'none', bold: true, fontSize: '18px' },
      { name: 'Heading 1', bg: 'transparent', color: '#1a73e8', border: 'none', bold: true, fontSize: '15px', borderBottom: '2px solid #1a73e8' },
      { name: 'Heading 2', bg: 'transparent', color: '#1a73e8', border: 'none', bold: true, fontSize: '13px', borderBottom: '1px solid #1a73e8' },
      { name: 'Heading 3', bg: 'transparent', color: '#1a73e8', border: 'none', bold: true },
      // Themed
      { name: 'Accent 1', bg: '#4472c4', color: '#ffffff', border: 'none' },
      { name: 'Accent 2', bg: '#ed7d31', color: '#ffffff', border: 'none' },
      { name: 'Accent 3', bg: '#a5a5a5', color: '#ffffff', border: 'none' },
      { name: 'Accent 4', bg: '#ffc000', color: '#000000', border: 'none' },
      { name: '20% Accent 1', bg: '#d6dce5', color: '#000000', border: 'none' },
      { name: '20% Accent 2', bg: '#fbe5d6', color: '#000000', border: 'none' },
      { name: '40% Accent 1', bg: '#b4c6e7', color: '#000000', border: 'none' },
      { name: '40% Accent 2', bg: '#f8cbad', color: '#000000', border: 'none' }
    ];

    function showCellStyles(event) {
      event.stopPropagation();

      if (!selectedCell && selectedRange.length === 0) {
        showToast('Select a cell first', 'warning');
        return;
      }

      if (cellStylesPopup) {
        cellStylesPopup.remove();
        cellStylesPopup = null;
        return;
      }

      const btn = event.target;
      const rect = btn.getBoundingClientRect();

      cellStylesPopup = document.createElement('div');
      cellStylesPopup.style.cssText = `
        position: fixed;
        top: ${rect.bottom + 5}px;
        left: ${Math.min(rect.left, window.innerWidth - 340)}px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        z-index: 10000;
        width: 320px;
        max-height: 400px;
        overflow-y: auto;
      `;

      let html = `<div style="font-weight: bold; margin-bottom: 10px; color: #333;">üé® Cell Styles</div>`;

      // Good, Bad, Neutral section
      html += `<div style="font-size: 11px; color: #666; margin-bottom: 4px;">Data Status</div>`;
      html += `<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 10px;">`;
      cellStyles.slice(0, 3).forEach(style => {
        html += createStylePreview(style);
      });
      html += `</div>`;

      // Data styles section
      html += `<div style="font-size: 11px; color: #666; margin-bottom: 4px;">Data & Model</div>`;
      html += `<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 10px;">`;
      cellStyles.slice(3, 8).forEach(style => {
        html += createStylePreview(style);
      });
      html += `</div>`;

      // Titles section
      html += `<div style="font-size: 11px; color: #666; margin-bottom: 4px;">Titles & Headings</div>`;
      html += `<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 10px;">`;
      cellStyles.slice(8, 12).forEach(style => {
        html += createStylePreview(style);
      });
      html += `</div>`;

      // Themed section
      html += `<div style="font-size: 11px; color: #666; margin-bottom: 4px;">Themed</div>`;
      html += `<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px;">`;
      cellStyles.slice(12).forEach(style => {
        html += createStylePreview(style);
      });
      html += `</div>`;

      cellStylesPopup.innerHTML = html;
      document.body.appendChild(cellStylesPopup);

      setTimeout(() => {
        document.addEventListener('click', closeCellStylesPopup);
      }, 10);
    }

    function createStylePreview(style) {
      const escapedName = style.name.replace(/'/g, "\\'");
      return `
        <div onclick="applyCellStyle('${escapedName}')"
             style="padding: 6px 4px; text-align: center; cursor: pointer;
                    background: ${style.bg}; color: ${style.color};
                    border: ${style.border || '1px solid #ddd'}; border-radius: 4px;
                    font-size: 10px; font-weight: ${style.bold ? 'bold' : 'normal'};
                    transition: transform 0.2s; white-space: nowrap; overflow: hidden;"
             onmouseover="this.style.transform='scale(1.05)'"
             onmouseout="this.style.transform='scale(1)'"
             title="${style.name}">
          ${style.name}
        </div>`;
    }

    function closeCellStylesPopup(e) {
      if (cellStylesPopup && !cellStylesPopup.contains(e.target)) {
        cellStylesPopup.remove();
        cellStylesPopup = null;
        document.removeEventListener('click', closeCellStylesPopup);
      }
    }

    function applyCellStyle(styleName) {
      const style = cellStyles.find(s => s.name === styleName);
      if (!style) return;

      const cells = selectedRange.length > 0 ? selectedRange : [selectedCell];

      cells.forEach(ref => {
        const cell = document.getElementById(ref);
        if (!cell) return;

        cell.style.backgroundColor = style.bg === 'transparent' ? '' : style.bg;
        cell.style.color = style.color;
        cell.style.fontWeight = style.bold ? 'bold' : '';
        cell.style.fontSize = style.fontSize || '';

        if (style.borderBottom) {
          cell.style.borderBottom = style.borderBottom;
        } else if (style.border && style.border !== 'none') {
          cell.style.border = style.border;
        }
      });

      showToast(`Applied "${styleName}" style to ${cells.length} cell(s)`, 'success');

      if (cellStylesPopup) {
        cellStylesPopup.remove();
        cellStylesPopup = null;
      }
    }

    // Flash Fill - automatically fill data based on patterns
    function flashFill() {
      if (!selectedCell) {
        showToast('Select a cell with an example value first', 'warning');
        return;
      }

      const col = selectedCell.match(/[A-Z]+/)[0];
      const row = parseInt(selectedCell.match(/\d+/)[0]);
      const exampleValue = data[selectedCell];

      if (!exampleValue) {
        showToast('Enter an example value in the selected cell first', 'warning');
        return;
      }

      // Find the source column (column to the left)
      const sourceCol = String.fromCharCode(col.charCodeAt(0) - 1);
      if (sourceCol < 'A') {
        showToast('No source column to the left', 'error');
        return;
      }

      const sourceValue = data[sourceCol + row];
      if (!sourceValue) {
        showToast('No source data in adjacent column', 'error');
        return;
      }

      // Detect pattern
      const pattern = detectFlashFillPattern(String(sourceValue), String(exampleValue));
      if (!pattern) {
        showToast('Could not detect a pattern', 'warning');
        return;
      }

      // Apply pattern to cells below
      let filled = 0;
      for (let r = row + 1; r <= 100; r++) {
        const srcCell = sourceCol + r;
        const targetCell = col + r;
        const srcVal = data[srcCell];

        if (!srcVal) break; // Stop at empty source cell

        const result = applyFlashFillPattern(String(srcVal), pattern);
        if (result) {
          data[targetCell] = result;
          updateCellDisplay(targetCell);
          filled++;
        }
      }

      if (filled > 0) {
        showToast(`Flash Fill: ${filled} cell(s) filled`, 'success');
      } else {
        showToast('No cells to fill', 'info');
      }
    }

    function detectFlashFillPattern(source, example) {
      source = String(source);
      example = String(example);

      // Pattern: Extract first name (text before space)
      if (source.includes(' ') && example === source.split(' ')[0]) {
        return { type: 'first_word' };
      }

      // Pattern: Extract last name (text after last space)
      if (source.includes(' ') && example === source.split(' ').pop()) {
        return { type: 'last_word' };
      }

      // Pattern: Extract initials
      const initials = source.split(' ').map(w => w[0]).join('').toUpperCase();
      if (example.toUpperCase() === initials) {
        return { type: 'initials' };
      }

      // Pattern: Extract first N characters
      if (source.startsWith(example)) {
        return { type: 'first_chars', count: example.length };
      }

      // Pattern: Extract last N characters
      if (source.endsWith(example)) {
        return { type: 'last_chars', count: example.length };
      }

      // Pattern: Uppercase
      if (example === source.toUpperCase()) {
        return { type: 'uppercase' };
      }

      // Pattern: Lowercase
      if (example === source.toLowerCase()) {
        return { type: 'lowercase' };
      }

      // Pattern: Title case
      const titleCase = source.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
      if (example === titleCase) {
        return { type: 'titlecase' };
      }

      // Pattern: Extract email domain
      if (source.includes('@') && example === source.split('@')[1]) {
        return { type: 'email_domain' };
      }

      // Pattern: Extract email username
      if (source.includes('@') && example === source.split('@')[0]) {
        return { type: 'email_user' };
      }

      // Pattern: Number extraction
      const numbers = source.match(/\d+/g);
      if (numbers && example === numbers.join('')) {
        return { type: 'extract_numbers' };
      }

      // Pattern: Add prefix/suffix
      if (example.includes(source)) {
        const prefix = example.substring(0, example.indexOf(source));
        const suffix = example.substring(example.indexOf(source) + source.length);
        return { type: 'wrap', prefix, suffix };
      }

      return null;
    }

    function applyFlashFillPattern(source, pattern) {
      source = String(source);

      switch (pattern.type) {
        case 'first_word':
          return source.split(' ')[0];
        case 'last_word':
          return source.split(' ').pop();
        case 'initials':
          return source.split(' ').map(w => w[0] || '').join('').toUpperCase();
        case 'first_chars':
          return source.substring(0, pattern.count);
        case 'last_chars':
          return source.substring(source.length - pattern.count);
        case 'uppercase':
          return source.toUpperCase();
        case 'lowercase':
          return source.toLowerCase();
        case 'titlecase':
          return source.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
        case 'email_domain':
          return source.includes('@') ? source.split('@')[1] : '';
        case 'email_user':
          return source.includes('@') ? source.split('@')[0] : '';
        case 'extract_numbers':
          const nums = source.match(/\d+/g);
          return nums ? nums.join('') : '';
        case 'wrap':
          return pattern.prefix + source + pattern.suffix;
        default:
          return null;
      }
    }

    // ==================== ZOOM CONTROLS ====================
    let zoomLevel = 100;

    function zoomIn() {
      if (zoomLevel < 200) {
        zoomLevel += 10;
        applyZoom();
      }
    }

    function zoomOut() {
      if (zoomLevel > 50) {
        zoomLevel -= 10;
        applyZoom();
      }
    }

    function applyZoom() {
      const area = document.getElementById('spreadsheetArea');
      area.style.transform = `scale(${zoomLevel / 100})`;
      area.style.transformOrigin = 'top left';
      document.getElementById('zoomLevel').textContent = zoomLevel + '%';
    }

    // ==================== FIND & REPLACE ====================
    let findMatchCells = [];
    let currentFindCellIndex = -1;

    function showFindBar() {
      document.getElementById('findBar').style.display = 'flex';
      document.getElementById('findInput').focus();
    }

    function hideFindBar() {
      document.getElementById('findBar').style.display = 'none';
      clearCellHighlights();
    }

    function clearCellHighlights() {
      findMatchCells.forEach(ref => {
        const cell = document.getElementById(ref);
        if (cell) cell.style.background = '';
      });
      findMatchCells = [];
      currentFindCellIndex = -1;
    }

    function findInCells() {
      const searchText = document.getElementById('findInput').value.toLowerCase();
      clearCellHighlights();

      if (!searchText) {
        document.getElementById('findCount').textContent = '0 found';
        return;
      }

      for (const ref in data) {
        const val = String(data[ref]).toLowerCase();
        if (val.includes(searchText)) {
          findMatchCells.push(ref);
          const cell = document.getElementById(ref);
          if (cell) cell.style.background = '#ffeb3b';
        }
      }

      document.getElementById('findCount').textContent = findMatchCells.length + ' found';
      if (findMatchCells.length > 0) {
        currentFindCellIndex = 0;
        highlightCurrentCell();
      }
    }

    function highlightCurrentCell() {
      findMatchCells.forEach((ref, i) => {
        const cell = document.getElementById(ref);
        if (cell) {
          cell.style.background = i === currentFindCellIndex ? '#ff9800' : '#ffeb3b';
        }
      });
      if (findMatchCells[currentFindCellIndex]) {
        selectCell(findMatchCells[currentFindCellIndex]);
        document.getElementById(findMatchCells[currentFindCellIndex]).scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function findNextCell() {
      if (findMatchCells.length === 0) return;
      currentFindCellIndex = (currentFindCellIndex + 1) % findMatchCells.length;
      highlightCurrentCell();
    }

    function findPrevCell() {
      if (findMatchCells.length === 0) return;
      currentFindCellIndex = (currentFindCellIndex - 1 + findMatchCells.length) % findMatchCells.length;
      highlightCurrentCell();
    }

    function replaceOneCell() {
      if (findMatchCells.length === 0 || currentFindCellIndex < 0) return;
      const replaceText = document.getElementById('replaceInput').value;
      const ref = findMatchCells[currentFindCellIndex];
      setCellValue(ref, replaceText);
      findInCells();
      showToast('Replaced 1 cell', 'success');
    }

    function replaceAllCells() {
      const searchText = document.getElementById('findInput').value.toLowerCase();
      const replaceText = document.getElementById('replaceInput').value;
      if (!searchText) return;

      let count = 0;
      for (const ref in data) {
        const val = String(data[ref]).toLowerCase();
        if (val.includes(searchText)) {
          setCellValue(ref, replaceText);
          count++;
        }
      }

      clearCellHighlights();
      document.getElementById('findCount').textContent = '0 found';
      showToast(`Replaced ${count} cells`, 'success');
    }

    // ==================== MULTIPLE SHEETS ====================
    let sheets = [{ name: 'Sheet1', data: {}, formulas: {} }];
    let currentSheetIndex = 0;

    function addSheet() {
      const newIndex = sheets.length;
      sheets.push({ name: 'Sheet' + (newIndex + 1), data: {}, formulas: {} });
      renderSheetTabs();
      switchSheet(newIndex);
      showToast('Sheet added', 'success');
    }

    function switchSheet(index) {
      // Save current sheet data
      sheets[currentSheetIndex].data = { ...data };
      sheets[currentSheetIndex].formulas = { ...formulas };

      // Clear current data
      for (const key in data) delete data[key];
      for (const key in formulas) delete formulas[key];

      // Load new sheet data
      currentSheetIndex = index;
      Object.assign(data, sheets[index].data || {});
      Object.assign(formulas, sheets[index].formulas || {});

      // Re-render
      initSpreadsheet();
      renderSheetTabs();
    }

    function renderSheetTabs() {
      const container = document.getElementById('sheetTabs');
      container.innerHTML = sheets.map((sheet, i) => `
        <div class="sheet-tab ${i === currentSheetIndex ? 'active' : ''}"
             data-sheet="${i}"
             onclick="switchSheet(${i})"
             ondblclick="renameSheet(${i})">${sheet.name}</div>
      `).join('') + '<div class="sheet-tab-add" onclick="addSheet()" title="Add Sheet">+</div>';
    }

    function renameSheet(index) {
      const newName = prompt('Enter sheet name:', sheets[index].name);
      if (newName) {
        sheets[index].name = newName;
        renderSheetTabs();
      }
    }

    // ==================== XLSX IMPORT/EXPORT ====================
    function importXlsx() {
      toggleFileMenu();
      document.getElementById('xlsxImport').click();
    }

    function handleXlsxImport(event) {
      const file = event.target.files[0];
      if (!file) return;

      showToast('Importing XLSX...', 'info');

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const workbook = XLSX.read(e.target.result, { type: 'array' });

          // Clear existing data
          for (const key in data) delete data[key];
          for (const key in formulas) delete formulas[key];
          sheets = [];

          // Import all sheets
          workbook.SheetNames.forEach((sheetName, idx) => {
            const worksheet = workbook.Sheets[sheetName];
            const sheetData = {};
            const sheetFormulas = {};

            // Get range
            const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');

            for (let r = range.s.r; r <= Math.min(range.e.r, 100); r++) {
              for (let c = range.s.c; c <= Math.min(range.e.c, 25); c++) {
                const cellRef = XLSX.utils.encode_cell({ r, c });
                const cell = worksheet[cellRef];
                if (cell) {
                  const ourRef = String.fromCharCode(65 + c) + (r + 1);
                  sheetData[ourRef] = cell.v;
                  if (cell.f) {
                    sheetFormulas[ourRef] = '=' + cell.f;
                  }
                }
              }
            }

            sheets.push({ name: sheetName, data: sheetData, formulas: sheetFormulas });
          });

          // Load first sheet
          currentSheetIndex = 0;
          Object.assign(data, sheets[0].data);
          Object.assign(formulas, sheets[0].formulas);

          // Render
          initSpreadsheet();
          renderSheetTabs();

          document.getElementById('fileName').value = file.name.replace(/\.(xlsx|xls)$/i, '');
          showToast('XLSX imported successfully! (' + sheets.length + ' sheets)', 'success');
        } catch (err) {
          console.error('XLSX import error:', err);
          showToast('Error importing XLSX: ' + err.message, 'error');
        }
      };
      reader.readAsArrayBuffer(file);
      event.target.value = '';
    }

    function exportXlsx() {
      toggleFileMenu();
      showToast('Generating XLSX...', 'info');

      try {
        // Save current sheet first
        sheets[currentSheetIndex].data = { ...data };
        sheets[currentSheetIndex].formulas = { ...formulas };

        const workbook = XLSX.utils.book_new();

        sheets.forEach((sheet, idx) => {
          // Convert our data format to 2D array
          const rows = [];
          let maxRow = 0, maxCol = 0;

          for (const ref in sheet.data) {
            const col = ref.charCodeAt(0) - 65;
            const row = parseInt(ref.substring(1)) - 1;
            if (row > maxRow) maxRow = row;
            if (col > maxCol) maxCol = col;
          }

          for (let r = 0; r <= maxRow; r++) {
            rows[r] = [];
            for (let c = 0; c <= maxCol; c++) {
              const ref = String.fromCharCode(65 + c) + (r + 1);
              rows[r][c] = sheet.data[ref] !== undefined ? sheet.data[ref] : '';
            }
          }

          const worksheet = XLSX.utils.aoa_to_sheet(rows);
          XLSX.utils.book_append_sheet(workbook, worksheet, sheet.name);
        });

        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const fileName = document.getElementById('fileName').value || 'spreadsheet';
        saveAs(blob, fileName + '.xlsx');

        showToast('XLSX exported successfully!', 'success');
      } catch (err) {
        console.error('XLSX export error:', err);
        showToast('Error exporting XLSX: ' + err.message, 'error');
      }
    }

    function exportHTML() {
      toggleFileMenu();
      const fileName = document.getElementById('fileName').value || 'spreadsheet';

      // Save current sheet first
      sheets[currentSheetIndex].data = { ...data };
      sheets[currentSheetIndex].formulas = { ...formulas };
      sheets[currentSheetIndex].formatting = { ...formatting };

      let htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${fileName}</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 2rem; }
    h1 { color: #1d6f42; margin-bottom: 0.5rem; }
    h2 { color: #333; font-size: 1.2rem; margin: 2rem 0 0.5rem; border-bottom: 2px solid #1d6f42; padding-bottom: 0.25rem; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 2rem; }
    th { background: #1d6f42; color: white; padding: 8px 12px; text-align: left; font-weight: 500; }
    td { border: 1px solid #ddd; padding: 8px 12px; }
    tr:nth-child(even) { background: #f9f9f9; }
    tr:hover { background: #f0f7f0; }
    .number { text-align: right; }
    .header-row { background: #e8f5e9 !important; font-weight: 600; }
    footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #eee; font-size: 0.8rem; color: #666; }
    @media print { body { padding: 0; } }
  </style>
</head>
<body>
<h1>${fileName}</h1>
<p style="color: #666; margin-bottom: 2rem;">Exported from NinjaCalc - ${new Date().toLocaleDateString()}</p>
`;

      sheets.forEach((sheet, sheetIdx) => {
        htmlContent += `<h2>Sheet: ${sheet.name}</h2>\n<table>\n`;

        // Find data bounds
        let maxRow = 0, maxCol = 0;
        for (const ref in sheet.data) {
          const col = ref.charCodeAt(0) - 65;
          const row = parseInt(ref.substring(1)) - 1;
          if (row > maxRow) maxRow = row;
          if (col > maxCol) maxCol = col;
        }

        // Skip empty sheets
        if (maxRow === 0 && maxCol === 0 && !sheet.data['A1']) {
          htmlContent += '<tr><td colspan="3" style="text-align: center; color: #999;">(Empty sheet)</td></tr>\n';
        } else {
          // Header row
          htmlContent += '<tr><th></th>';
          for (let c = 0; c <= maxCol; c++) {
            htmlContent += `<th>${String.fromCharCode(65 + c)}</th>`;
          }
          htmlContent += '</tr>\n';

          // Data rows
          for (let r = 0; r <= maxRow; r++) {
            htmlContent += `<tr><th style="background: #f5f5f5; color: #333;">${r + 1}</th>`;
            for (let c = 0; c <= maxCol; c++) {
              const ref = String.fromCharCode(65 + c) + (r + 1);
              const value = sheet.data[ref] !== undefined ? sheet.data[ref] : '';
              const fmt = sheet.formatting?.[ref] || {};
              let style = '';
              if (fmt.bold) style += 'font-weight: bold;';
              if (fmt.italic) style += 'font-style: italic;';
              if (fmt.color) style += `color: ${fmt.color};`;
              if (fmt.background) style += `background: ${fmt.background};`;
              if (typeof value === 'number') style += 'text-align: right;';
              htmlContent += `<td${style ? ` style="${style}"` : ''}>${value}</td>`;
            }
            htmlContent += '</tr>\n';
          }
        }
        htmlContent += '</table>\n';
      });

      htmlContent += `<footer>
  <p>Generated by NinjaCalc - ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}</p>
</footer>
</body>
</html>`;

      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName + '.html';
      a.click();
      URL.revokeObjectURL(url);
      showToast('HTML exported successfully!', 'success');
    }

    // ==================== MORE EXCEL FUNCTIONS ====================
    // Enhanced formula evaluation - add more functions
    const originalEvaluateFormula = evaluateFormula;

    // Add DATE/TIME functions
    function NOW() { return new Date().toLocaleString(); }
    function TODAY() { return new Date().toLocaleDateString(); }
    function YEAR(date) { return new Date(date).getFullYear(); }
    function MONTH(date) { return new Date(date).getMonth() + 1; }
    function DAY(date) { return new Date(date).getDate(); }

    // Add MATH functions
    function ROUND(num, places = 0) { return Math.round(num * Math.pow(10, places)) / Math.pow(10, places); }
    function ABS(num) { return Math.abs(num); }
    function SQRT(num) { return Math.sqrt(num); }
    function POWER(base, exp) { return Math.pow(base, exp); }
    function MOD(num, divisor) { return num % divisor; }
    function CEILING(num) { return Math.ceil(num); }
    function FLOOR(num) { return Math.floor(num); }

    // Add TEXT functions
    function UPPER(text) { return String(text).toUpperCase(); }
    function LOWER(text) { return String(text).toLowerCase(); }
    function TRIM(text) { return String(text).trim(); }
    function PROPER(text) { return String(text).replace(/\b\w/g, c => c.toUpperCase()); }

    // ==================== FREEZE PANES ====================
    function freezePane() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      const col = selectedCell.charCodeAt(0) - 65;
      const row = parseInt(selectedCell.slice(1)) - 1;
      frozenRow = row;
      frozenCol = col;

      // Apply sticky positioning to frozen cells
      applyFreezePanes();
      showToast(`Frozen at ${selectedCell}`, 'success');
    }

    function unfreezePane() {
      frozenRow = 0;
      frozenCol = 0;
      // Remove freeze styling
      document.querySelectorAll('.freeze-row, .freeze-col').forEach(el => {
        el.classList.remove('freeze-row', 'freeze-col');
        el.style.position = '';
        el.style.left = '';
        el.style.top = '';
        el.style.zIndex = '';
      });
      showToast('Panes unfrozen', 'info');
    }

    function freezeTopRow() {
      frozenRow = 1;
      frozenCol = 0;
      applyFreezePanes();
      showToast('Top row frozen', 'success');
    }

    function freezeFirstColumn() {
      frozenRow = 0;
      frozenCol = 1;
      applyFreezePanes();
      showToast('First column frozen', 'success');
    }

    function applyFreezePanes() {
      const table = document.getElementById('spreadsheet');
      const rows = table.querySelectorAll('tr');

      rows.forEach((row, rowIdx) => {
        if (rowIdx <= frozenRow) {
          row.querySelectorAll('th, td').forEach((cell, colIdx) => {
            if (colIdx <= frozenCol) {
              cell.style.position = 'sticky';
              cell.style.left = colIdx === 0 ? '0' : 'auto';
              cell.style.top = rowIdx === 0 ? '0' : `${rowIdx * 25}px`;
              cell.style.zIndex = '15';
              cell.style.background = '#e3f2fd';
            }
          });
        }
      });
    }

    // ==================== SPLIT VIEW ====================
    let splitViewActive = false;
    let splitViewMode = 'none'; // 'none', 'horizontal', 'vertical'

    function toggleSplitView() {
      const btn = document.getElementById('splitViewBtn');
      const container = document.querySelector('.spreadsheet-wrapper');

      if (splitViewMode === 'none') {
        // Enable horizontal split
        splitViewMode = 'horizontal';
        enableSplitView('horizontal');
        btn.textContent = '‚äü Split H';
        btn.style.background = '#e8f0fe';
        showToast('Horizontal split view enabled. Click again for vertical, or again to disable.', 'info');
      } else if (splitViewMode === 'horizontal') {
        // Switch to vertical split
        disableSplitView();
        splitViewMode = 'vertical';
        enableSplitView('vertical');
        btn.textContent = '‚äü Split V';
        showToast('Vertical split view enabled. Click again to disable.', 'info');
      } else {
        // Disable split view
        disableSplitView();
        splitViewMode = 'none';
        btn.textContent = '‚äü Split View';
        btn.style.background = '';
        showToast('Split view disabled', 'info');
      }
    }

    function enableSplitView(mode) {
      const wrapper = document.querySelector('.spreadsheet-wrapper');
      const originalTable = document.getElementById('spreadsheet');

      // Create split container
      const splitContainer = document.createElement('div');
      splitContainer.className = 'split-view-container' + (mode === 'vertical' ? ' horizontal' : '');
      splitContainer.id = 'splitViewContainer';

      // Create first pane with original table
      const pane1 = document.createElement('div');
      pane1.className = 'split-pane';
      pane1.id = 'splitPane1';
      pane1.style.overflow = 'auto';

      // Create divider
      const divider = document.createElement('div');
      divider.className = 'split-divider';
      divider.title = 'Drag to resize panes';

      // Create second pane with cloned table
      const pane2 = document.createElement('div');
      pane2.className = 'split-pane';
      pane2.id = 'splitPane2';
      pane2.style.overflow = 'auto';

      // Clone the table for second pane
      const clonedTable = originalTable.cloneNode(true);
      clonedTable.id = 'spreadsheet-clone';

      // Move original to pane1
      pane1.appendChild(originalTable);
      pane2.appendChild(clonedTable);

      splitContainer.appendChild(pane1);
      splitContainer.appendChild(divider);
      splitContainer.appendChild(pane2);

      wrapper.innerHTML = '';
      wrapper.appendChild(splitContainer);

      // Sync scrolling between panes
      if (mode === 'horizontal') {
        // Horizontal split - sync horizontal scroll
        pane1.addEventListener('scroll', () => {
          pane2.scrollLeft = pane1.scrollLeft;
        });
        pane2.addEventListener('scroll', () => {
          pane1.scrollLeft = pane2.scrollLeft;
        });
      } else {
        // Vertical split - sync vertical scroll
        pane1.addEventListener('scroll', () => {
          pane2.scrollTop = pane1.scrollTop;
        });
        pane2.addEventListener('scroll', () => {
          pane1.scrollTop = pane2.scrollTop;
        });
      }

      // Make divider draggable
      let isDragging = false;
      divider.addEventListener('mousedown', (e) => {
        isDragging = true;
        document.body.style.cursor = mode === 'vertical' ? 'ew-resize' : 'ns-resize';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const rect = splitContainer.getBoundingClientRect();
        if (mode === 'vertical') {
          const percent = ((e.clientX - rect.left) / rect.width) * 100;
          pane1.style.flex = `0 0 ${Math.max(20, Math.min(80, percent))}%`;
          pane2.style.flex = '1';
        } else {
          const percent = ((e.clientY - rect.top) / rect.height) * 100;
          pane1.style.flex = `0 0 ${Math.max(20, Math.min(80, percent))}%`;
          pane2.style.flex = '1';
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.style.cursor = '';
      });

      splitViewActive = true;
    }

    function disableSplitView() {
      const wrapper = document.querySelector('.spreadsheet-wrapper');
      const splitContainer = document.getElementById('splitViewContainer');

      if (splitContainer) {
        const originalTable = document.getElementById('spreadsheet');
        if (originalTable) {
          wrapper.innerHTML = '';
          wrapper.appendChild(originalTable);
        }
      }

      splitViewActive = false;
    }

    // ==================== HIDE/SHOW ROWS & COLUMNS ====================
    function hideSelectedRows() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      const row = parseInt(selectedCell.slice(1));
      hiddenRows.add(row);
      const tableRow = document.querySelector(`#spreadsheet tr:nth-child(${row + 1})`);
      if (tableRow) {
        tableRow.style.display = 'none';
      }
      showToast(`Row ${row} hidden`, 'info');
    }

    function showAllRows() {
      hiddenRows.clear();
      document.querySelectorAll('#spreadsheet tr').forEach(row => {
        row.style.display = '';
      });
      showToast('All rows visible', 'info');
    }

    function hideSelectedColumns() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      const col = selectedCell.charCodeAt(0) - 65;
      hiddenCols.add(col);
      document.querySelectorAll(`#spreadsheet td:nth-child(${col + 2}), #spreadsheet th:nth-child(${col + 2})`).forEach(cell => {
        cell.style.display = 'none';
      });
      showToast(`Column ${String.fromCharCode(65 + col)} hidden`, 'info');
    }

    function showAllColumns() {
      hiddenCols.clear();
      document.querySelectorAll('#spreadsheet td, #spreadsheet th').forEach(cell => {
        cell.style.display = '';
      });
      showToast('All columns visible', 'info');
    }

    // ==================== CELL COMMENTS ====================
    function addCellComment() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      const existingComment = cellComments[selectedCell] || '';
      const comment = prompt('Enter comment:', existingComment);
      if (comment !== null) {
        if (comment.trim()) {
          cellComments[selectedCell] = comment;
          // Add comment indicator
          const cell = document.getElementById(`cell-${selectedCell}`);
          if (cell) {
            cell.parentElement.classList.add('has-comment');
            cell.title = comment;
          }
          showToast('Comment added', 'success');
        } else {
          delete cellComments[selectedCell];
          const cell = document.getElementById(`cell-${selectedCell}`);
          if (cell) {
            cell.parentElement.classList.remove('has-comment');
            cell.title = '';
          }
          showToast('Comment removed', 'info');
        }
      }
    }

    // ==================== DATA VALIDATION ====================
    function showDataValidation() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      document.getElementById('dvCell').value = selectedCell;
      const existing = dataValidation[selectedCell];
      if (existing) {
        document.getElementById('dvType').value = existing.type;
        document.getElementById('dvErrorMsg').value = existing.errorMsg || '';
        updateDvOptions();
      }
      document.getElementById('dataValidationModal').classList.add('active');
    }

    function hideDataValidation() {
      document.getElementById('dataValidationModal').classList.remove('active');
    }

    function updateDvOptions() {
      const type = document.getElementById('dvType').value;
      document.getElementById('dvRangeGroup').style.display = ['number', 'decimal', 'textLength'].includes(type) ? 'block' : 'none';
      document.getElementById('dvListGroup').style.display = type === 'list' ? 'block' : 'none';
    }

    function applyDataValidation() {
      const cell = document.getElementById('dvCell').value;
      const type = document.getElementById('dvType').value;
      const errorMsg = document.getElementById('dvErrorMsg').value;

      if (type === 'any') {
        delete dataValidation[cell];
      } else {
        dataValidation[cell] = {
          type: type,
          condition: document.getElementById('dvCondition')?.value,
          min: document.getElementById('dvMin')?.value,
          max: document.getElementById('dvMax')?.value,
          list: document.getElementById('dvList')?.value?.split(',').map(s => s.trim()),
          errorMsg: errorMsg
        };
      }

      hideDataValidation();
      showToast('Data validation applied', 'success');
    }

    function clearDataValidation() {
      const cell = document.getElementById('dvCell').value;
      delete dataValidation[cell];
      hideDataValidation();
      showToast('Data validation cleared', 'info');
    }

    function validateCellInput(cellRef, value) {
      const rule = dataValidation[cellRef];
      if (!rule) return true;

      let valid = true;
      const numValue = parseFloat(value);

      switch (rule.type) {
        case 'number':
          valid = Number.isInteger(numValue);
          break;
        case 'decimal':
          valid = !isNaN(numValue);
          break;
        case 'list':
          valid = rule.list.includes(value);
          break;
        case 'textLength':
          const len = String(value).length;
          valid = validateCondition(len, rule.condition, parseFloat(rule.min), parseFloat(rule.max));
          break;
      }

      if (!valid) {
        showToast(rule.errorMsg || 'Invalid value', 'error');
      }
      return valid;
    }

    function validateCondition(value, condition, min, max) {
      switch (condition) {
        case 'between': return value >= min && value <= max;
        case 'notBetween': return value < min || value > max;
        case 'equal': return value === min;
        case 'notEqual': return value !== min;
        case 'greater': return value > min;
        case 'less': return value < min;
        default: return true;
      }
    }

    // ==================== CELL BORDERS ====================
    function showCellBorders() {
      document.getElementById('bordersModal').classList.add('active');
    }

    function hideCellBorders() {
      document.getElementById('bordersModal').classList.remove('active');
    }

    function applyBorder(type) {
      if (!selectedCell && selectedRange.length === 0) {
        showToast('Select cells first', 'warning');
        return;
      }

      const style = document.getElementById('borderStyle').value;
      const width = document.getElementById('borderWidth').value;
      const color = document.getElementById('borderColor').value;
      const border = `${width} ${style} ${color}`;

      const cells = selectedRange.length > 0 ? selectedRange : [selectedCell];

      cells.forEach(cellRef => {
        const cell = document.getElementById(`cell-${cellRef}`);
        if (!cell) return;

        const td = cell.parentElement;
        if (!formatting[cellRef]) formatting[cellRef] = {};

        switch (type) {
          case 'all':
            td.style.border = border;
            formatting[cellRef].border = border;
            break;
          case 'outside':
            td.style.border = border;
            formatting[cellRef].border = border;
            break;
          case 'top':
            td.style.borderTop = border;
            formatting[cellRef].borderTop = border;
            break;
          case 'bottom':
            td.style.borderBottom = border;
            formatting[cellRef].borderBottom = border;
            break;
          case 'left':
            td.style.borderLeft = border;
            formatting[cellRef].borderLeft = border;
            break;
          case 'right':
            td.style.borderRight = border;
            formatting[cellRef].borderRight = border;
            break;
          case 'none':
            td.style.border = '1px solid #e0e0e0';
            delete formatting[cellRef].border;
            break;
        }
      });

      showToast('Borders applied', 'success');
    }

    // ==================== NAMED RANGES ====================
    function showNamedRanges() {
      updateNamedRangesList();
      document.getElementById('namedRangesModal').classList.add('active');
    }

    function hideNamedRanges() {
      document.getElementById('namedRangesModal').classList.remove('active');
    }

    function addNamedRange() {
      const name = document.getElementById('rangeName').value.trim();
      const ref = document.getElementById('rangeRef').value.trim().toUpperCase();

      if (!name || !ref) {
        showToast('Enter name and range reference', 'warning');
        return;
      }

      if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)) {
        showToast('Invalid name format', 'error');
        return;
      }

      namedRanges[name] = ref;
      updateNamedRangesList();
      document.getElementById('rangeName').value = '';
      document.getElementById('rangeRef').value = '';
      showToast(`Named range "${name}" created`, 'success');
    }

    function updateNamedRangesList() {
      const list = document.getElementById('namedRangesList');
      const names = Object.keys(namedRanges);

      if (names.length === 0) {
        list.innerHTML = '<p style="color: var(--secondary); font-size: 0.9rem;">No named ranges defined.</p>';
        return;
      }

      list.innerHTML = names.map(name => `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-bottom: 1px solid var(--border);">
          <span><strong>${name}</strong> = ${namedRanges[name]}</span>
          <button class="btn btn-danger" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;" onclick="deleteNamedRange('${name}')">√ó</button>
        </div>
      `).join('');
    }

    function deleteNamedRange(name) {
      delete namedRanges[name];
      updateNamedRangesList();
      showToast(`Named range "${name}" deleted`, 'info');
    }

    // ==================== TAB SWITCHING (with View toolbar) ====================
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        ['homeToolbar', 'formulasToolbar', 'dataToolbar', 'viewToolbar'].forEach(id => {
          document.getElementById(id).style.display = 'none';
        });

        const tabName = tab.dataset.tab;
        const toolbarMap = {
          home: 'homeToolbar',
          formulas: 'formulasToolbar',
          data: 'dataToolbar',
          view: 'viewToolbar'
        };

        if (toolbarMap[tabName]) {
          document.getElementById(toolbarMap[tabName]).style.display = 'flex';
        }
      });
    });

    // ==================== KEYBOARD SHORTCUTS ====================
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        showFindBar();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveSpreadsheet();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        redo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
        e.preventDefault();
        showGoToCell();
      }
      if (e.shiftKey && e.key === 'F3') {
        e.preventDefault();
        showFormulaBuilder();
      }
      if (e.key === 'Escape') {
        hideFindBar();
        hideFormulaBuilder();
      }
    });

    // ==================== FORMULA BUILDER ====================
    const functionLibrary = {
      // Math & Trig
      SUM: { category: 'math', syntax: 'SUM(number1, [number2], ...)', description: 'Adds all the numbers in a range of cells.', args: ['number1', 'number2'] },
      AVERAGE: { category: 'statistical', syntax: 'AVERAGE(number1, [number2], ...)', description: 'Returns the average (arithmetic mean) of the arguments.', args: ['number1', 'number2'] },
      COUNT: { category: 'statistical', syntax: 'COUNT(value1, [value2], ...)', description: 'Counts the number of cells that contain numbers.', args: ['value1', 'value2'] },
      COUNTA: { category: 'statistical', syntax: 'COUNTA(value1, [value2], ...)', description: 'Counts the number of cells that are not empty.', args: ['value1', 'value2'] },
      MAX: { category: 'statistical', syntax: 'MAX(number1, [number2], ...)', description: 'Returns the largest value in a set of values.', args: ['number1', 'number2'] },
      MIN: { category: 'statistical', syntax: 'MIN(number1, [number2], ...)', description: 'Returns the smallest value in a set of values.', args: ['number1', 'number2'] },
      ROUND: { category: 'math', syntax: 'ROUND(number, num_digits)', description: 'Rounds a number to a specified number of digits.', args: ['number', 'num_digits'] },
      ROUNDUP: { category: 'math', syntax: 'ROUNDUP(number, num_digits)', description: 'Rounds a number up, away from zero.', args: ['number', 'num_digits'] },
      ROUNDDOWN: { category: 'math', syntax: 'ROUNDDOWN(number, num_digits)', description: 'Rounds a number down, toward zero.', args: ['number', 'num_digits'] },
      ABS: { category: 'math', syntax: 'ABS(number)', description: 'Returns the absolute value of a number.', args: ['number'] },
      SQRT: { category: 'math', syntax: 'SQRT(number)', description: 'Returns a positive square root.', args: ['number'] },
      POWER: { category: 'math', syntax: 'POWER(number, power)', description: 'Returns the result of a number raised to a power.', args: ['number', 'power'] },
      MOD: { category: 'math', syntax: 'MOD(number, divisor)', description: 'Returns the remainder after division.', args: ['number', 'divisor'] },
      INT: { category: 'math', syntax: 'INT(number)', description: 'Rounds a number down to the nearest integer.', args: ['number'] },
      RAND: { category: 'math', syntax: 'RAND()', description: 'Returns a random number between 0 and 1.', args: [] },
      RANDBETWEEN: { category: 'math', syntax: 'RANDBETWEEN(bottom, top)', description: 'Returns a random integer between two numbers.', args: ['bottom', 'top'] },
      PI: { category: 'math', syntax: 'PI()', description: 'Returns the value of pi (3.14159...).', args: [] },
      SIN: { category: 'math', syntax: 'SIN(number)', description: 'Returns the sine of an angle.', args: ['number'] },
      COS: { category: 'math', syntax: 'COS(number)', description: 'Returns the cosine of an angle.', args: ['number'] },
      TAN: { category: 'math', syntax: 'TAN(number)', description: 'Returns the tangent of an angle.', args: ['number'] },
      LOG: { category: 'math', syntax: 'LOG(number, [base])', description: 'Returns the logarithm of a number to a specified base.', args: ['number', 'base'] },
      LN: { category: 'math', syntax: 'LN(number)', description: 'Returns the natural logarithm of a number.', args: ['number'] },
      EXP: { category: 'math', syntax: 'EXP(number)', description: 'Returns e raised to the power of number.', args: ['number'] },
      CEILING: { category: 'math', syntax: 'CEILING(number, significance)', description: 'Rounds a number up to the nearest multiple.', args: ['number', 'significance'] },
      FLOOR: { category: 'math', syntax: 'FLOOR(number, significance)', description: 'Rounds a number down to the nearest multiple.', args: ['number', 'significance'] },
      SUMIF: { category: 'math', syntax: 'SUMIF(range, criteria, [sum_range])', description: 'Sums cells that meet a criteria.', args: ['range', 'criteria', 'sum_range'] },
      SUMIFS: { category: 'math', syntax: 'SUMIFS(sum_range, criteria_range1, criteria1, ...)', description: 'Sums cells that meet multiple criteria.', args: ['sum_range', 'criteria_range1', 'criteria1'] },
      PRODUCT: { category: 'math', syntax: 'PRODUCT(number1, [number2], ...)', description: 'Multiplies all the numbers given as arguments.', args: ['number1', 'number2'] },
      // Statistical
      MEDIAN: { category: 'statistical', syntax: 'MEDIAN(number1, [number2], ...)', description: 'Returns the median of the given numbers.', args: ['number1', 'number2'] },
      MODE: { category: 'statistical', syntax: 'MODE(number1, [number2], ...)', description: 'Returns the most frequently occurring value.', args: ['number1', 'number2'] },
      STDEV: { category: 'statistical', syntax: 'STDEV(number1, [number2], ...)', description: 'Estimates standard deviation based on a sample.', args: ['number1', 'number2'] },
      VAR: { category: 'statistical', syntax: 'VAR(number1, [number2], ...)', description: 'Estimates variance based on a sample.', args: ['number1', 'number2'] },
      COUNTIF: { category: 'statistical', syntax: 'COUNTIF(range, criteria)', description: 'Counts cells that meet a criteria.', args: ['range', 'criteria'] },
      COUNTIFS: { category: 'statistical', syntax: 'COUNTIFS(criteria_range1, criteria1, ...)', description: 'Counts cells that meet multiple criteria.', args: ['criteria_range1', 'criteria1'] },
      AVERAGEIF: { category: 'statistical', syntax: 'AVERAGEIF(range, criteria, [average_range])', description: 'Averages cells that meet a criteria.', args: ['range', 'criteria', 'average_range'] },
      LARGE: { category: 'statistical', syntax: 'LARGE(array, k)', description: 'Returns the k-th largest value in a data set.', args: ['array', 'k'] },
      SMALL: { category: 'statistical', syntax: 'SMALL(array, k)', description: 'Returns the k-th smallest value in a data set.', args: ['array', 'k'] },
      RANK: { category: 'statistical', syntax: 'RANK(number, ref, [order])', description: 'Returns the rank of a number in a list.', args: ['number', 'ref', 'order'] },
      // Text
      CONCAT: { category: 'text', syntax: 'CONCAT(text1, [text2], ...)', description: 'Joins several text strings into one.', args: ['text1', 'text2'] },
      CONCATENATE: { category: 'text', syntax: 'CONCATENATE(text1, [text2], ...)', description: 'Joins several text strings into one.', args: ['text1', 'text2'] },
      LEFT: { category: 'text', syntax: 'LEFT(text, [num_chars])', description: 'Returns the leftmost characters from a text.', args: ['text', 'num_chars'] },
      RIGHT: { category: 'text', syntax: 'RIGHT(text, [num_chars])', description: 'Returns the rightmost characters from a text.', args: ['text', 'num_chars'] },
      MID: { category: 'text', syntax: 'MID(text, start_num, num_chars)', description: 'Returns characters from the middle of a text.', args: ['text', 'start_num', 'num_chars'] },
      LEN: { category: 'text', syntax: 'LEN(text)', description: 'Returns the number of characters in a text.', args: ['text'] },
      TRIM: { category: 'text', syntax: 'TRIM(text)', description: 'Removes extra spaces from text.', args: ['text'] },
      UPPER: { category: 'text', syntax: 'UPPER(text)', description: 'Converts text to uppercase.', args: ['text'] },
      LOWER: { category: 'text', syntax: 'LOWER(text)', description: 'Converts text to lowercase.', args: ['text'] },
      PROPER: { category: 'text', syntax: 'PROPER(text)', description: 'Capitalizes the first letter of each word.', args: ['text'] },
      FIND: { category: 'text', syntax: 'FIND(find_text, within_text, [start_num])', description: 'Finds one text within another (case-sensitive).', args: ['find_text', 'within_text', 'start_num'] },
      SEARCH: { category: 'text', syntax: 'SEARCH(find_text, within_text, [start_num])', description: 'Finds one text within another (not case-sensitive).', args: ['find_text', 'within_text', 'start_num'] },
      REPLACE: { category: 'text', syntax: 'REPLACE(old_text, start_num, num_chars, new_text)', description: 'Replaces characters within text.', args: ['old_text', 'start_num', 'num_chars', 'new_text'] },
      SUBSTITUTE: { category: 'text', syntax: 'SUBSTITUTE(text, old_text, new_text, [instance_num])', description: 'Substitutes new text for old text.', args: ['text', 'old_text', 'new_text', 'instance_num'] },
      TEXT: { category: 'text', syntax: 'TEXT(value, format_text)', description: 'Formats a number as text.', args: ['value', 'format_text'] },
      VALUE: { category: 'text', syntax: 'VALUE(text)', description: 'Converts text to a number.', args: ['text'] },
      REPT: { category: 'text', syntax: 'REPT(text, number_times)', description: 'Repeats text a given number of times.', args: ['text', 'number_times'] },
      // Logical
      IF: { category: 'logical', syntax: 'IF(logical_test, value_if_true, [value_if_false])', description: 'Returns one value if a condition is true and another if false.', args: ['logical_test', 'value_if_true', 'value_if_false'] },
      AND: { category: 'logical', syntax: 'AND(logical1, [logical2], ...)', description: 'Returns TRUE if all arguments are TRUE.', args: ['logical1', 'logical2'] },
      OR: { category: 'logical', syntax: 'OR(logical1, [logical2], ...)', description: 'Returns TRUE if any argument is TRUE.', args: ['logical1', 'logical2'] },
      NOT: { category: 'logical', syntax: 'NOT(logical)', description: 'Reverses the logic of its argument.', args: ['logical'] },
      IFERROR: { category: 'logical', syntax: 'IFERROR(value, value_if_error)', description: 'Returns value_if_error if expression is an error.', args: ['value', 'value_if_error'] },
      IFS: { category: 'logical', syntax: 'IFS(logical_test1, value_if_true1, ...)', description: 'Checks multiple conditions and returns a value.', args: ['logical_test1', 'value_if_true1'] },
      SWITCH: { category: 'logical', syntax: 'SWITCH(expression, value1, result1, ...)', description: 'Evaluates expression against a list of values.', args: ['expression', 'value1', 'result1'] },
      TRUE: { category: 'logical', syntax: 'TRUE()', description: 'Returns the logical value TRUE.', args: [] },
      FALSE: { category: 'logical', syntax: 'FALSE()', description: 'Returns the logical value FALSE.', args: [] },
      // Lookup & Reference
      VLOOKUP: { category: 'lookup', syntax: 'VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])', description: 'Looks for a value in the leftmost column and returns a value in the same row.', args: ['lookup_value', 'table_array', 'col_index_num', 'range_lookup'] },
      HLOOKUP: { category: 'lookup', syntax: 'HLOOKUP(lookup_value, table_array, row_index_num, [range_lookup])', description: 'Looks for a value in the top row and returns a value in the same column.', args: ['lookup_value', 'table_array', 'row_index_num', 'range_lookup'] },
      INDEX: { category: 'lookup', syntax: 'INDEX(array, row_num, [column_num])', description: 'Returns a value from a table or range.', args: ['array', 'row_num', 'column_num'] },
      MATCH: { category: 'lookup', syntax: 'MATCH(lookup_value, lookup_array, [match_type])', description: 'Returns the relative position of an item in an array.', args: ['lookup_value', 'lookup_array', 'match_type'] },
      XLOOKUP: { category: 'lookup', syntax: 'XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found])', description: 'Searches a range or array and returns an item.', args: ['lookup_value', 'lookup_array', 'return_array', 'if_not_found'] },
      CHOOSE: { category: 'lookup', syntax: 'CHOOSE(index_num, value1, [value2], ...)', description: 'Chooses a value from a list of values.', args: ['index_num', 'value1', 'value2'] },
      ROW: { category: 'lookup', syntax: 'ROW([reference])', description: 'Returns the row number of a reference.', args: ['reference'] },
      COLUMN: { category: 'lookup', syntax: 'COLUMN([reference])', description: 'Returns the column number of a reference.', args: ['reference'] },
      ROWS: { category: 'lookup', syntax: 'ROWS(array)', description: 'Returns the number of rows in a reference.', args: ['array'] },
      COLUMNS: { category: 'lookup', syntax: 'COLUMNS(array)', description: 'Returns the number of columns in a reference.', args: ['array'] },
      INDIRECT: { category: 'lookup', syntax: 'INDIRECT(ref_text, [a1])', description: 'Returns the reference specified by a text string.', args: ['ref_text', 'a1'] },
      OFFSET: { category: 'lookup', syntax: 'OFFSET(reference, rows, cols, [height], [width])', description: 'Returns a reference offset from a starting point.', args: ['reference', 'rows', 'cols', 'height', 'width'] },
      // Date & Time
      TODAY: { category: 'date', syntax: 'TODAY()', description: 'Returns the current date.', args: [] },
      NOW: { category: 'date', syntax: 'NOW()', description: 'Returns the current date and time.', args: [] },
      DATE: { category: 'date', syntax: 'DATE(year, month, day)', description: 'Returns a date from year, month, and day.', args: ['year', 'month', 'day'] },
      YEAR: { category: 'date', syntax: 'YEAR(serial_number)', description: 'Returns the year of a date.', args: ['serial_number'] },
      MONTH: { category: 'date', syntax: 'MONTH(serial_number)', description: 'Returns the month of a date.', args: ['serial_number'] },
      DAY: { category: 'date', syntax: 'DAY(serial_number)', description: 'Returns the day of a date.', args: ['serial_number'] },
      HOUR: { category: 'date', syntax: 'HOUR(serial_number)', description: 'Returns the hour of a time.', args: ['serial_number'] },
      MINUTE: { category: 'date', syntax: 'MINUTE(serial_number)', description: 'Returns the minute of a time.', args: ['serial_number'] },
      SECOND: { category: 'date', syntax: 'SECOND(serial_number)', description: 'Returns the second of a time.', args: ['serial_number'] },
      WEEKDAY: { category: 'date', syntax: 'WEEKDAY(serial_number, [return_type])', description: 'Returns the day of the week.', args: ['serial_number', 'return_type'] },
      DATEDIF: { category: 'date', syntax: 'DATEDIF(start_date, end_date, unit)', description: 'Calculates the difference between two dates.', args: ['start_date', 'end_date', 'unit'] },
      EDATE: { category: 'date', syntax: 'EDATE(start_date, months)', description: 'Returns a date a number of months before/after.', args: ['start_date', 'months'] },
      EOMONTH: { category: 'date', syntax: 'EOMONTH(start_date, months)', description: 'Returns the last day of a month.', args: ['start_date', 'months'] },
      NETWORKDAYS: { category: 'date', syntax: 'NETWORKDAYS(start_date, end_date, [holidays])', description: 'Returns the number of working days between dates.', args: ['start_date', 'end_date', 'holidays'] },
      // Financial
      PMT: { category: 'financial', syntax: 'PMT(rate, nper, pv, [fv], [type])', description: 'Calculates the payment for a loan.', args: ['rate', 'nper', 'pv', 'fv', 'type'] },
      PV: { category: 'financial', syntax: 'PV(rate, nper, pmt, [fv], [type])', description: 'Returns the present value of an investment.', args: ['rate', 'nper', 'pmt', 'fv', 'type'] },
      FV: { category: 'financial', syntax: 'FV(rate, nper, pmt, [pv], [type])', description: 'Returns the future value of an investment.', args: ['rate', 'nper', 'pmt', 'pv', 'type'] },
      NPV: { category: 'financial', syntax: 'NPV(rate, value1, [value2], ...)', description: 'Returns the net present value of an investment.', args: ['rate', 'value1', 'value2'] },
      IRR: { category: 'financial', syntax: 'IRR(values, [guess])', description: 'Returns the internal rate of return.', args: ['values', 'guess'] },
      RATE: { category: 'financial', syntax: 'RATE(nper, pmt, pv, [fv], [type], [guess])', description: 'Returns the interest rate per period.', args: ['nper', 'pmt', 'pv', 'fv', 'type', 'guess'] },
      NPER: { category: 'financial', syntax: 'NPER(rate, pmt, pv, [fv], [type])', description: 'Returns the number of periods for an investment.', args: ['rate', 'pmt', 'pv', 'fv', 'type'] },
      // Information
      ISBLANK: { category: 'info', syntax: 'ISBLANK(value)', description: 'Returns TRUE if value is blank.', args: ['value'] },
      ISERROR: { category: 'info', syntax: 'ISERROR(value)', description: 'Returns TRUE if value is any error.', args: ['value'] },
      ISNUMBER: { category: 'info', syntax: 'ISNUMBER(value)', description: 'Returns TRUE if value is a number.', args: ['value'] },
      ISTEXT: { category: 'info', syntax: 'ISTEXT(value)', description: 'Returns TRUE if value is text.', args: ['value'] },
      ISLOGICAL: { category: 'info', syntax: 'ISLOGICAL(value)', description: 'Returns TRUE if value is a logical value.', args: ['value'] },
      TYPE: { category: 'info', syntax: 'TYPE(value)', description: 'Returns the type of value.', args: ['value'] },
      NA: { category: 'info', syntax: 'NA()', description: 'Returns the error value #N/A.', args: [] }
    };

    let selectedFunction = null;

    function showFormulaBuilder() {
      document.getElementById('formulaBuilderModal').classList.add('active');
      document.getElementById('functionSearch').value = '';
      document.getElementById('functionCategory').value = 'all';
      selectedFunction = null;
      document.getElementById('insertFormulaBtn').disabled = true;
      document.getElementById('functionArguments').style.display = 'none';
      document.getElementById('functionDetails').innerHTML = '<p style="color: #666; text-align: center; margin-top: 2rem;">Select a function to see its description and syntax</p>';
      renderFunctionList(Object.keys(functionLibrary));
    }

    function hideFormulaBuilder() {
      document.getElementById('formulaBuilderModal').classList.remove('active');
    }

    function renderFunctionList(functions) {
      const listEl = document.getElementById('functionList');
      listEl.innerHTML = functions.map(fn => `
        <div class="function-item" onclick="selectFunction('${fn}')" style="padding: 0.5rem 0.75rem; cursor: pointer; border-bottom: 1px solid #eee; transition: background 0.2s;"
             onmouseover="this.style.background='#e8f0fe'" onmouseout="this.style.background='${selectedFunction === fn ? '#e8f0fe' : 'white'}'">
          <strong style="color: #1a73e8;">${fn}</strong>
          <div style="font-size: 0.8rem; color: #666; margin-top: 2px;">${functionLibrary[fn].description.substring(0, 50)}...</div>
        </div>
      `).join('');
    }

    function filterFunctions() {
      const search = document.getElementById('functionSearch').value.toLowerCase();
      const filtered = Object.keys(functionLibrary).filter(fn =>
        fn.toLowerCase().includes(search) ||
        functionLibrary[fn].description.toLowerCase().includes(search)
      );
      renderFunctionList(filtered);
    }

    function filterFunctionsByCategory() {
      const category = document.getElementById('functionCategory').value;
      document.getElementById('functionSearch').value = '';
      if (category === 'all') {
        renderFunctionList(Object.keys(functionLibrary));
      } else {
        const filtered = Object.keys(functionLibrary).filter(fn => functionLibrary[fn].category === category);
        renderFunctionList(filtered);
      }
    }

    function selectFunction(fn) {
      selectedFunction = fn;
      const func = functionLibrary[fn];
      document.getElementById('insertFormulaBtn').disabled = false;

      // Update details panel
      document.getElementById('functionDetails').innerHTML = `
        <h4 style="color: #1a73e8; margin-bottom: 0.5rem;">${fn}</h4>
        <p style="margin-bottom: 1rem;">${func.description}</p>
        <div style="background: #2d2d2d; color: #fff; padding: 0.75rem; border-radius: 4px; font-family: monospace; margin-bottom: 1rem;">
          ${func.syntax}
        </div>
        <p style="font-size: 0.85rem; color: #666;">Category: <strong>${func.category.charAt(0).toUpperCase() + func.category.slice(1)}</strong></p>
      `;

      // Show argument inputs if function has arguments
      if (func.args.length > 0) {
        document.getElementById('functionArguments').style.display = 'block';
        document.getElementById('argInputs').innerHTML = func.args.map((arg, i) => `
          <div style="margin-bottom: 0.5rem;">
            <label style="font-size: 0.85rem; color: #666;">${arg}${arg.startsWith('[') ? ' (optional)' : ''}:</label>
            <input type="text" class="form-control formula-arg" data-arg="${i}" placeholder="e.g., A1:A10 or value" style="font-family: monospace;">
          </div>
        `).join('');
      } else {
        document.getElementById('functionArguments').style.display = 'none';
      }

      // Highlight selected in list
      document.querySelectorAll('.function-item').forEach(el => {
        el.style.background = el.querySelector('strong').textContent === fn ? '#e8f0fe' : 'white';
      });
    }

    function insertBuiltFormula() {
      if (!selectedFunction) return;

      const func = functionLibrary[selectedFunction];
      let formula = '=' + selectedFunction + '(';

      // Get argument values
      const argInputs = document.querySelectorAll('.formula-arg');
      const args = [];
      argInputs.forEach(input => {
        if (input.value.trim()) {
          args.push(input.value.trim());
        }
      });

      formula += args.join(', ') + ')';

      // Insert into current cell
      if (currentCell) {
        const input = document.getElementById('formulaInput');
        input.value = formula;
        input.focus();
        hideFormulaBuilder();
        showToast(`Inserted ${selectedFunction} function`, 'success');
      } else {
        showToast('Select a cell first', 'warning');
      }
    }

    // ==================== AUTO-FILL DRAG HANDLE ====================
    let isAutoFilling = false;
    let autoFillStart = null;
    let autoFillEnd = null;

    function initAutoFillHandle(cellRef) {
      const cell = document.getElementById(cellRef);
      if (!cell) return;

      const td = cell.parentElement;

      // Create fill handle if not exists
      let handle = td.querySelector('.fill-handle');
      if (!handle) {
        handle = document.createElement('div');
        handle.className = 'fill-handle';
        handle.style.cssText = `
          position: absolute;
          bottom: -3px;
          right: -3px;
          width: 8px;
          height: 8px;
          background: #1a73e8;
          cursor: crosshair;
          z-index: 10;
        `;
        td.style.position = 'relative';
        td.appendChild(handle);

        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          isAutoFilling = true;
          autoFillStart = cellRef;
          autoFillEnd = cellRef;
          document.addEventListener('mousemove', handleAutoFillDrag);
          document.addEventListener('mouseup', finishAutoFill);
        });
      }
    }

    function handleAutoFillDrag(e) {
      if (!isAutoFilling) return;

      const element = document.elementFromPoint(e.clientX, e.clientY);
      if (element && element.classList.contains('cell')) {
        autoFillEnd = element.id;
        highlightAutoFillRange();
      }
    }

    function highlightAutoFillRange() {
      // Remove previous highlights
      document.querySelectorAll('.auto-fill-preview').forEach(el => {
        el.classList.remove('auto-fill-preview');
      });

      // Get range
      const startCol = autoFillStart.charCodeAt(0);
      const startRow = parseInt(autoFillStart.slice(1));
      const endCol = autoFillEnd.charCodeAt(0);
      const endRow = parseInt(autoFillEnd.slice(1));

      const minCol = Math.min(startCol, endCol);
      const maxCol = Math.max(startCol, endCol);
      const minRow = Math.min(startRow, endRow);
      const maxRow = Math.max(startRow, endRow);

      for (let c = minCol; c <= maxCol; c++) {
        for (let r = minRow; r <= maxRow; r++) {
          const ref = String.fromCharCode(c) + r;
          const cell = document.getElementById(ref);
          if (cell) {
            cell.classList.add('auto-fill-preview');
            cell.style.background = '#e3f2fd';
          }
        }
      }
    }

    function finishAutoFill() {
      if (!isAutoFilling) return;
      isAutoFilling = false;
      document.removeEventListener('mousemove', handleAutoFillDrag);
      document.removeEventListener('mouseup', finishAutoFill);

      // Remove highlights
      document.querySelectorAll('.auto-fill-preview').forEach(el => {
        el.classList.remove('auto-fill-preview');
        el.style.background = '';
      });

      // Perform auto-fill
      performAutoFill(autoFillStart, autoFillEnd);
    }

    function performAutoFill(startRef, endRef) {
      const startCol = startRef.charCodeAt(0);
      const startRow = parseInt(startRef.slice(1));
      const endCol = endRef.charCodeAt(0);
      const endRow = parseInt(endRef.slice(1));

      const sourceValue = data[startRef];
      const sourceFormula = formulas[startRef];

      // Determine fill direction
      if (endCol === startCol) {
        // Vertical fill
        const increment = detectPattern(sourceValue);
        for (let r = startRow + 1; r <= endRow; r++) {
          const ref = String.fromCharCode(startCol) + r;
          if (sourceFormula) {
            // Adjust formula references
            const newFormula = adjustFormulaReferences(sourceFormula, 0, r - startRow);
            setCellValue(ref, newFormula);
          } else if (typeof sourceValue === 'number' && increment !== 0) {
            setCellValue(ref, sourceValue + increment * (r - startRow));
          } else {
            setCellValue(ref, sourceValue);
          }
        }
      } else if (endRow === startRow) {
        // Horizontal fill
        for (let c = startCol + 1; c <= endCol; c++) {
          const ref = String.fromCharCode(c) + startRow;
          if (sourceFormula) {
            const newFormula = adjustFormulaReferences(sourceFormula, c - startCol, 0);
            setCellValue(ref, newFormula);
          } else {
            setCellValue(ref, sourceValue);
          }
        }
      }

      recalculateAll();
      showToast('Auto-fill complete', 'success');
    }

    function detectPattern(value) {
      if (typeof value === 'number') return 1;
      return 0;
    }

    function adjustFormulaReferences(formula, colOffset, rowOffset) {
      return formula.replace(/([A-Z])(\d+)/g, (match, col, row) => {
        const newCol = String.fromCharCode(col.charCodeAt(0) + colOffset);
        const newRow = parseInt(row) + rowOffset;
        return newCol + newRow;
      });
    }

    // Update selectCell to show fill handle
    const originalSelectCell = selectCell;
    selectCell = function(ref) {
      originalSelectCell(ref);
      initAutoFillHandle(ref);
    };

    // ==================== MERGE CELLS ====================
    let mergedCells = {};

    function mergeCells() {
      const range = prompt('Enter range to merge (e.g., A1:B2):', selectedCell + ':' + selectedCell);
      if (!range) return;

      const parts = range.toUpperCase().split(':');
      if (parts.length !== 2) {
        showToast('Invalid range format', 'error');
        return;
      }

      const start = parts[0];
      const end = parts[1];

      const startCol = start.charCodeAt(0);
      const startRow = parseInt(start.slice(1));
      const endCol = end.charCodeAt(0);
      const endRow = parseInt(end.slice(1));

      const colSpan = endCol - startCol + 1;
      const rowSpan = endRow - startRow + 1;

      // Get the primary cell (top-left)
      const primaryCell = document.getElementById(start);
      const primaryTd = primaryCell?.parentElement;
      if (!primaryTd) return;

      // Set colspan and rowspan
      primaryTd.colSpan = colSpan;
      primaryTd.rowSpan = rowSpan;
      primaryCell.style.height = (rowSpan * 24) + 'px';

      // Hide other cells in the range
      for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
          const ref = String.fromCharCode(c) + r;
          if (ref !== start) {
            const cell = document.getElementById(ref);
            if (cell) {
              cell.parentElement.style.display = 'none';
            }
          }
        }
      }

      mergedCells[start] = { end: end, colSpan, rowSpan };
      showToast(`Cells ${range} merged`, 'success');
    }

    function unmergeCells() {
      const range = prompt('Enter merged cell start (e.g., A1):');
      if (!range || !mergedCells[range.toUpperCase()]) {
        showToast('No merged cells at that location', 'warning');
        return;
      }

      const start = range.toUpperCase();
      const merged = mergedCells[start];
      const end = merged.end;

      const startCol = start.charCodeAt(0);
      const startRow = parseInt(start.slice(1));
      const endCol = end.charCodeAt(0);
      const endRow = parseInt(end.slice(1));

      // Reset primary cell
      const primaryCell = document.getElementById(start);
      const primaryTd = primaryCell?.parentElement;
      if (primaryTd) {
        primaryTd.colSpan = 1;
        primaryTd.rowSpan = 1;
        primaryCell.style.height = '';
      }

      // Show hidden cells
      for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
          const ref = String.fromCharCode(c) + r;
          const cell = document.getElementById(ref);
          if (cell) {
            cell.parentElement.style.display = '';
          }
        }
      }

      delete mergedCells[start];
      showToast('Cells unmerged', 'success');
    }

    // ==================== TEXT WRAP IN CELLS ====================
    function toggleTextWrap() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }

      const cell = document.getElementById(selectedCell);
      const td = cell.parentElement;

      if (cell.style.whiteSpace === 'normal') {
        cell.style.whiteSpace = 'nowrap';
        cell.style.overflow = 'hidden';
        cell.style.textOverflow = 'ellipsis';
        td.style.height = '';
        showToast('Text wrap disabled', 'info');
      } else {
        cell.style.whiteSpace = 'normal';
        cell.style.overflow = 'visible';
        cell.style.textOverflow = '';
        td.style.height = 'auto';
        td.style.minHeight = '24px';
        showToast('Text wrap enabled', 'success');
      }
    }

    // ==================== TEXT ROTATION IN CELLS ====================
    let textRotationPopup = null;
    let cellRotations = {};

    const rotationOptions = [
      { name: 'Normal', angle: 0, icon: '‚Üí' },
      { name: '45¬∞ Up', angle: -45, icon: '‚Üó' },
      { name: '45¬∞ Down', angle: 45, icon: '‚Üò' },
      { name: '90¬∞ Up', angle: -90, icon: '‚Üë' },
      { name: '90¬∞ Down', angle: 90, icon: '‚Üì' },
      { name: 'Vertical', angle: 'vertical', icon: '‚áÖ' }
    ];

    function showTextRotation(event) {
      event.stopPropagation();

      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }

      if (textRotationPopup) {
        textRotationPopup.remove();
        textRotationPopup = null;
        return;
      }

      const btn = event.target;
      const rect = btn.getBoundingClientRect();

      textRotationPopup = document.createElement('div');
      textRotationPopup.style.cssText = `
        position: fixed;
        top: ${rect.bottom + 5}px;
        left: ${rect.left}px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        z-index: 10000;
        width: 220px;
      `;

      const currentRotation = cellRotations[selectedCell] || 0;

      let html = `<div style="font-weight: bold; margin-bottom: 8px; color: #333;">Text Rotation</div>`;
      html += `<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 12px;">`;

      rotationOptions.forEach(opt => {
        const isActive = currentRotation === opt.angle;
        html += `
          <div onclick="applyTextRotation(${typeof opt.angle === 'string' ? `'${opt.angle}'` : opt.angle})"
               style="padding: 8px; text-align: center; cursor: pointer; border: 2px solid ${isActive ? '#1a73e8' : '#ddd'};
                      border-radius: 6px; background: ${isActive ? '#e8f0fe' : 'white'}; transition: all 0.2s;"
               title="${opt.name}">
            <div style="font-size: 20px; margin-bottom: 2px;">${opt.icon}</div>
            <div style="font-size: 10px; color: #666;">${opt.name}</div>
          </div>`;
      });
      html += `</div>`;

      // Custom angle input
      html += `
        <div style="border-top: 1px solid #eee; padding-top: 10px;">
          <label style="font-size: 12px; color: #666;">Custom Angle:</label>
          <div style="display: flex; gap: 8px; margin-top: 4px;">
            <input type="number" id="customRotationAngle" min="-90" max="90" value="${typeof currentRotation === 'number' ? currentRotation : 0}"
                   style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
            <button onclick="applyCustomRotation()"
                    style="padding: 6px 12px; background: #1a73e8; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Apply
            </button>
          </div>
        </div>
      `;

      textRotationPopup.innerHTML = html;
      document.body.appendChild(textRotationPopup);

      setTimeout(() => {
        document.addEventListener('click', closeTextRotationPopup);
      }, 10);
    }

    function closeTextRotationPopup(e) {
      if (textRotationPopup && !textRotationPopup.contains(e.target)) {
        textRotationPopup.remove();
        textRotationPopup = null;
        document.removeEventListener('click', closeTextRotationPopup);
      }
    }

    function applyTextRotation(angle) {
      if (!selectedCell) return;

      const cell = document.getElementById(selectedCell);
      const td = cell.parentElement;

      if (angle === 0) {
        // Reset to normal
        cell.style.transform = '';
        cell.style.writingMode = '';
        cell.style.textOrientation = '';
        td.style.height = '';
        td.style.verticalAlign = '';
        delete cellRotations[selectedCell];
        showToast('Text rotation reset', 'info');
      } else if (angle === 'vertical') {
        // Vertical text (stacked)
        cell.style.transform = '';
        cell.style.writingMode = 'vertical-rl';
        cell.style.textOrientation = 'mixed';
        td.style.height = 'auto';
        td.style.minHeight = '60px';
        td.style.verticalAlign = 'middle';
        cellRotations[selectedCell] = angle;
        showToast('Vertical text applied', 'success');
      } else {
        // Angle rotation
        cell.style.writingMode = '';
        cell.style.textOrientation = '';
        cell.style.transform = `rotate(${angle}deg)`;
        cell.style.transformOrigin = 'center center';
        cell.style.display = 'inline-block';

        // Adjust cell height for rotated text
        const absAngle = Math.abs(angle);
        if (absAngle > 45) {
          td.style.height = '60px';
        } else {
          td.style.height = '40px';
        }
        td.style.verticalAlign = 'middle';

        cellRotations[selectedCell] = angle;
        showToast(`Text rotated ${angle}¬∞`, 'success');
      }

      if (textRotationPopup) {
        textRotationPopup.remove();
        textRotationPopup = null;
      }
    }

    function applyCustomRotation() {
      const input = document.getElementById('customRotationAngle');
      let angle = parseInt(input.value);

      if (isNaN(angle)) {
        showToast('Please enter a valid angle', 'warning');
        return;
      }

      // Clamp to -90 to 90
      angle = Math.max(-90, Math.min(90, angle));
      applyTextRotation(angle);
    }

    // ==================== CELL INDENTATION ====================
    let cellIndents = {};

    function increaseIndent() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }

      const cell = document.getElementById(selectedCell);
      const currentIndent = cellIndents[selectedCell] || 0;
      const newIndent = Math.min(currentIndent + 1, 10); // Max 10 levels

      cellIndents[selectedCell] = newIndent;
      cell.style.paddingLeft = (8 + newIndent * 12) + 'px';
      cell.style.textAlign = 'left';

      showToast(`Indent level: ${newIndent}`, 'info');
    }

    function decreaseIndent() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }

      const cell = document.getElementById(selectedCell);
      const currentIndent = cellIndents[selectedCell] || 0;
      const newIndent = Math.max(currentIndent - 1, 0);

      cellIndents[selectedCell] = newIndent;

      if (newIndent === 0) {
        cell.style.paddingLeft = '4px';
        delete cellIndents[selectedCell];
      } else {
        cell.style.paddingLeft = (8 + newIndent * 12) + 'px';
      }

      showToast(newIndent === 0 ? 'Indent removed' : `Indent level: ${newIndent}`, 'info');
    }

    // ==================== ENHANCED NUMBER FORMATTING ====================
    let numberFormats = {};

    function showNumberFormatModal() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      document.getElementById('numberFormatModal').classList.add('active');
    }

    function hideNumberFormatModal() {
      document.getElementById('numberFormatModal').classList.remove('active');
    }

    function applyNumberFormat(format) {
      if (!selectedCell) return;

      const cell = document.getElementById(selectedCell);
      let value = parseFloat(data[selectedCell]);

      if (isNaN(value)) {
        showToast('Cell must contain a number', 'warning');
        return;
      }

      numberFormats[selectedCell] = format;
      cell.value = formatNumberValue(value, format);
      showToast('Number format applied', 'success');
    }

    function formatNumberValue(value, format) {
      switch (format) {
        case 'general':
          return value;
        case 'number':
          return value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        case 'currency':
          return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        case 'currency-euro':
          return '‚Ç¨' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        case 'currency-pound':
          return '¬£' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        case 'accounting':
          const formatted = '$' + Math.abs(value).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          return value < 0 ? `(${formatted})` : formatted;
        case 'percent':
          return (value * 100).toFixed(2) + '%';
        case 'percent-0':
          return Math.round(value * 100) + '%';
        case 'scientific':
          return value.toExponential(2);
        case 'fraction':
          return decimalToFraction(value);
        case 'date-short':
          return new Date(value * 24 * 60 * 60 * 1000 + new Date('1900-01-01').getTime()).toLocaleDateString();
        case 'date-long':
          return new Date(value * 24 * 60 * 60 * 1000 + new Date('1900-01-01').getTime()).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        case 'thousands':
          return Math.round(value / 1000) + 'K';
        case 'millions':
          return (value / 1000000).toFixed(2) + 'M';
        default:
          return value;
      }
    }

    function decimalToFraction(decimal) {
      const tolerance = 1.0E-6;
      let numerator = 1;
      let denominator = 1;
      let fraction = decimal;

      while (Math.abs(fraction - Math.round(fraction)) > tolerance) {
        denominator++;
        fraction = decimal * denominator;
      }
      numerator = Math.round(fraction);

      const gcd = (a, b) => b ? gcd(b, a % b) : a;
      const divisor = gcd(numerator, denominator);

      return `${numerator / divisor}/${denominator / divisor}`;
    }

    // ==================== PRINT PREVIEW ====================
    function showPrintPreview() {
      updatePrintPreview();
      document.getElementById('printPreviewModal').classList.add('active');
    }

    function hidePrintPreview() {
      document.getElementById('printPreviewModal').classList.remove('active');
    }

    // Print Area
    let printArea = null;

    function setPrintArea() {
      if (!selectedRange || selectedRange.length < 2) {
        showToast('Select a range first (click and drag)', 'warning');
        return;
      }

      // Get the range bounds
      const cells = selectedRange;
      let minCol = 'Z', maxCol = 'A', minRow = 999, maxRow = 0;

      cells.forEach(ref => {
        const col = ref.match(/[A-Z]+/)[0];
        const row = parseInt(ref.match(/\d+/)[0]);
        if (col < minCol) minCol = col;
        if (col > maxCol) maxCol = col;
        if (row < minRow) minRow = row;
        if (row > maxRow) maxRow = row;
      });

      printArea = {
        startCol: minCol,
        startRow: minRow,
        endCol: maxCol,
        endRow: maxRow
      };

      // Visual feedback - highlight print area cells
      highlightPrintArea();

      showToast(`Print area set: ${minCol}${minRow}:${maxCol}${maxRow}`, 'success');
    }

    function clearPrintArea() {
      printArea = null;
      // Remove print area highlighting
      document.querySelectorAll('.print-area-cell').forEach(cell => {
        cell.classList.remove('print-area-cell');
      });
      showToast('Print area cleared', 'info');
    }

    function highlightPrintArea() {
      // Remove existing highlights
      document.querySelectorAll('.print-area-cell').forEach(cell => {
        cell.classList.remove('print-area-cell');
      });

      if (!printArea) return;

      // Add highlight to cells in print area
      for (let col = printArea.startCol.charCodeAt(0); col <= printArea.endCol.charCodeAt(0); col++) {
        for (let row = printArea.startRow; row <= printArea.endRow; row++) {
          const cellRef = String.fromCharCode(col) + row;
          const cell = document.getElementById(cellRef);
          if (cell) {
            cell.parentElement.classList.add('print-area-cell');
          }
        }
      }
    }

    function updatePrintPreview() {
      const preview = document.getElementById('printPreviewContent');
      const printRange = document.getElementById('printRange').value;
      const orientation = document.getElementById('printOrientation').value;
      const showGridlines = document.getElementById('printGridlines').checked;
      const showHeaders = document.getElementById('printHeaders').checked;

      // Determine range to print
      let startCol = 'A', endCol = 'Z', startRow = 1, endRow = 50;

      if (printRange === 'custom') {
        const custom = document.getElementById('customPrintRange').value.toUpperCase();
        const match = custom.match(/([A-Z]+)(\d+):([A-Z]+)(\d+)/);
        if (match) {
          startCol = match[1];
          startRow = parseInt(match[2]);
          endCol = match[3];
          endRow = parseInt(match[4]);
        }
      } else if (printRange === 'selection' && selectedRange.length >= 2) {
        startCol = selectedRange[0][0];
        startRow = parseInt(selectedRange[0].slice(1));
        endCol = selectedRange[1][0];
        endRow = parseInt(selectedRange[1].slice(1));
      }

      // Build table
      let html = '<table style="border-collapse: collapse; font-size: 12px; width: 100%;">';

      // Header row
      if (showHeaders) {
        html += '<tr><th style="width: 40px;"></th>';
        for (let c = startCol.charCodeAt(0); c <= endCol.charCodeAt(0); c++) {
          html += `<th style="background: #f0f0f0; padding: 4px 8px; ${showGridlines ? 'border: 1px solid #ccc;' : ''}">${String.fromCharCode(c)}</th>`;
        }
        html += '</tr>';
      }

      // Data rows
      for (let r = startRow; r <= endRow; r++) {
        html += '<tr>';
        if (showHeaders) {
          html += `<td style="background: #f0f0f0; padding: 4px 8px; font-weight: bold; ${showGridlines ? 'border: 1px solid #ccc;' : ''}">${r}</td>`;
        }
        for (let c = startCol.charCodeAt(0); c <= endCol.charCodeAt(0); c++) {
          const ref = String.fromCharCode(c) + r;
          const value = data[ref] || '';
          html += `<td style="padding: 4px 8px; ${showGridlines ? 'border: 1px solid #ccc;' : ''}">${value}</td>`;
        }
        html += '</tr>';
      }

      html += '</table>';

      preview.innerHTML = html;
      preview.style.width = orientation === 'landscape' ? '800px' : '600px';
    }

    function exportToPDF() {
      showToast('Generating PDF... (use browser print for now)', 'info');
      window.print();
    }

    // ==================== ROW/COLUMN GROUPING ====================
    let groups = { rows: [], cols: [] };

    function showGroupModal() {
      document.getElementById('groupModal').classList.add('active');
    }

    function hideGroupModal() {
      document.getElementById('groupModal').classList.remove('active');
    }

    function createGroup() {
      const type = document.getElementById('groupType').value;
      const start = document.getElementById('groupStart').value.toUpperCase();
      const end = document.getElementById('groupEnd').value.toUpperCase();

      if (!start || !end) {
        showToast('Please enter start and end values', 'warning');
        return;
      }

      if (type === 'rows') {
        const startRow = parseInt(start);
        const endRow = parseInt(end);
        if (isNaN(startRow) || isNaN(endRow)) {
          showToast('Invalid row numbers', 'error');
          return;
        }
        groups.rows.push({ start: startRow, end: endRow, collapsed: false });
        showToast(`Grouped rows ${startRow}-${endRow}`, 'success');
      } else {
        const startCol = start.charCodeAt(0) - 64;
        const endCol = end.charCodeAt(0) - 64;
        groups.cols.push({ start: startCol, end: endCol, collapsed: false });
        showToast(`Grouped columns ${start}-${end}`, 'success');
      }

      hideGroupModal();
      renderGroupIndicators();
    }

    function renderGroupIndicators() {
      // Remove existing group indicators
      document.querySelectorAll('.group-indicator').forEach(el => el.remove());

      // Add row group indicators
      groups.rows.forEach((group, idx) => {
        const firstRowCell = document.querySelector(`td[data-row="${group.start}"]`);
        if (firstRowCell) {
          const indicator = document.createElement('div');
          indicator.className = 'group-indicator';
          indicator.innerHTML = group.collapsed ? '+' : '‚àí';
          indicator.style.cssText = `
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: #1a73e8;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
          `;
          indicator.onclick = () => toggleRowGroup(idx);
          firstRowCell.style.position = 'relative';
          firstRowCell.appendChild(indicator);
        }
      });
    }

    function toggleRowGroup(idx) {
      const group = groups.rows[idx];
      group.collapsed = !group.collapsed;

      for (let r = group.start; r <= group.end; r++) {
        const row = document.querySelector(`tr[data-row="${r}"]`);
        if (row) {
          row.style.display = group.collapsed ? 'none' : '';
        }
      }

      renderGroupIndicators();
      showToast(group.collapsed ? 'Group collapsed' : 'Group expanded', 'info');
    }

    // ==================== SPARKLINES ====================
    let sparklines = {};

    function showSparklinesModal() {
      document.getElementById('sparklineRange').value = '';
      document.getElementById('sparklineTarget').value = selectedCell || '';
      document.getElementById('sparklinePreview').innerHTML = '';
      document.getElementById('sparklinesModal').classList.add('active');
    }

    function hideSparklinesModal() {
      document.getElementById('sparklinesModal').classList.remove('active');
    }

    function getSparklineData(range) {
      const parts = range.split(':');
      if (parts.length !== 2) return [];

      const startCol = parts[0].replace(/[0-9]/g, '');
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endCol = parts[1].replace(/[0-9]/g, '');
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      const values = [];
      if (startCol === endCol) {
        // Vertical range
        for (let r = startRow; r <= endRow; r++) {
          values.push(parseFloat(data[startCol + r]) || 0);
        }
      } else {
        // Horizontal range
        for (let c = startCol.charCodeAt(0); c <= endCol.charCodeAt(0); c++) {
          values.push(parseFloat(data[String.fromCharCode(c) + startRow]) || 0);
        }
      }
      return values;
    }

    function previewSparkline() {
      const range = document.getElementById('sparklineRange').value.toUpperCase();
      const type = document.getElementById('sparklineType').value;
      const color = document.getElementById('sparklineColor').value;

      if (!range) {
        showToast('Enter a data range', 'warning');
        return;
      }

      const values = getSparklineData(range);
      if (values.length === 0) {
        showToast('Invalid range', 'error');
        return;
      }

      const preview = document.getElementById('sparklinePreview');
      preview.innerHTML = generateSparklineSVG(values, type, color, 200, 40);
    }

    function generateSparklineSVG(values, type, color, width, height) {
      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min || 1;
      const padding = 2;

      if (type === 'line') {
        const points = values.map((v, i) => {
          const x = padding + (i / (values.length - 1)) * (width - padding * 2);
          const y = height - padding - ((v - min) / range) * (height - padding * 2);
          return `${x},${y}`;
        }).join(' ');

        return `<svg width="${width}" height="${height}">
          <polyline points="${points}" fill="none" stroke="${color}" stroke-width="2"/>
        </svg>`;
      } else if (type === 'bar' || type === 'column') {
        const barWidth = (width - padding * 2) / values.length - 2;
        const bars = values.map((v, i) => {
          const barHeight = ((v - min) / range) * (height - padding * 2);
          const x = padding + i * (barWidth + 2);
          const y = height - padding - barHeight;
          return `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${color}"/>`;
        }).join('');

        return `<svg width="${width}" height="${height}">${bars}</svg>`;
      } else if (type === 'winloss') {
        // Win/Loss: positive values up, negative/zero down
        const barWidth = (width - padding * 2) / values.length - 2;
        const midY = height / 2;
        const barHeight = (height - padding * 2) / 2 - 2;

        const bars = values.map((v, i) => {
          const x = padding + i * (barWidth + 2);
          const isWin = v > 0;
          const y = isWin ? midY - barHeight : midY + 2;
          const fillColor = isWin ? color : '#ea4335';
          return `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${fillColor}"/>`;
        }).join('');

        return `<svg width="${width}" height="${height}">
          <line x1="${padding}" y1="${midY}" x2="${width - padding}" y2="${midY}" stroke="#ccc" stroke-width="1"/>
          ${bars}
        </svg>`;
      } else if (type === 'area') {
        // Area chart (filled line)
        const points = values.map((v, i) => {
          const x = padding + (i / (values.length - 1)) * (width - padding * 2);
          const y = height - padding - ((v - min) / range) * (height - padding * 2);
          return `${x},${y}`;
        });

        // Create closed path for fill
        const firstX = padding;
        const lastX = padding + (width - padding * 2);
        const bottomY = height - padding;
        const areaPath = `M${firstX},${bottomY} L${points.join(' L')} L${lastX},${bottomY} Z`;
        const linePath = points.join(' ');

        return `<svg width="${width}" height="${height}">
          <path d="${areaPath}" fill="${color}" fill-opacity="0.3"/>
          <polyline points="${linePath}" fill="none" stroke="${color}" stroke-width="2"/>
        </svg>`;
      }

      return '';
    }

    function insertSparkline() {
      const range = document.getElementById('sparklineRange').value.toUpperCase();
      const target = document.getElementById('sparklineTarget').value.toUpperCase();
      const type = document.getElementById('sparklineType').value;
      const color = document.getElementById('sparklineColor').value;

      if (!range || !target) {
        showToast('Enter range and target cell', 'warning');
        return;
      }

      const values = getSparklineData(range);
      if (values.length === 0) {
        showToast('Invalid range', 'error');
        return;
      }

      // Store sparkline info
      sparklines[target] = { range, type, color, values };

      // Insert SVG into cell
      const svg = generateSparklineSVG(values, type, color, 80, 20);
      data[target] = `[SPARKLINE]`;

      const cell = document.querySelector(`td[data-ref="${target}"]`);
      if (cell) {
        cell.innerHTML = svg;
      }

      hideSparklinesModal();
      showToast('Sparkline inserted', 'success');
    }

    // ==================== GOAL SEEK ====================
    function showGoalSeek() {
      document.getElementById('goalSetCell').value = '';
      document.getElementById('goalValue').value = '';
      document.getElementById('goalChangeCell').value = '';
      document.getElementById('goalSeekResult').style.display = 'none';
      document.getElementById('goalSeekModal').classList.add('active');
    }

    function hideGoalSeek() {
      document.getElementById('goalSeekModal').classList.remove('active');
    }

    function runGoalSeek() {
      const setCell = document.getElementById('goalSetCell').value.toUpperCase();
      const targetValue = parseFloat(document.getElementById('goalValue').value);
      const changeCell = document.getElementById('goalChangeCell').value.toUpperCase();

      if (!setCell || isNaN(targetValue) || !changeCell) {
        showToast('Fill in all fields', 'warning');
        return;
      }

      const formula = formulas[setCell];
      if (!formula) {
        showToast('Set cell must contain a formula', 'error');
        return;
      }

      // Goal seek algorithm (bisection method)
      let low = -10000;
      let high = 10000;
      let mid, result;
      const tolerance = 0.0001;
      const maxIterations = 100;

      const originalValue = data[changeCell];

      for (let i = 0; i < maxIterations; i++) {
        mid = (low + high) / 2;
        data[changeCell] = mid;
        result = evaluateCell(setCell);

        if (Math.abs(result - targetValue) < tolerance) {
          break;
        }

        // Determine direction
        data[changeCell] = low;
        const lowResult = evaluateCell(setCell);
        data[changeCell] = high;
        const highResult = evaluateCell(setCell);

        if ((lowResult < targetValue && highResult > targetValue) ||
            (lowResult > targetValue && highResult < targetValue)) {
          if ((result > targetValue) === (highResult > targetValue)) {
            high = mid;
          } else {
            low = mid;
          }
        } else {
          // Try different bounds
          if (result < targetValue) {
            low = mid;
          } else {
            high = mid;
          }
        }
      }

      const finalValue = mid;
      data[changeCell] = finalValue;
      updateCellDisplay(changeCell);
      recalculateAll();

      document.getElementById('goalSeekResult').style.display = 'block';
      document.getElementById('goalSeekResult').innerHTML = `
        <strong>Solution Found!</strong><br>
        ${changeCell} = ${finalValue.toFixed(4)}<br>
        ${setCell} = ${evaluateCell(setCell).toFixed(4)}
      `;

      showToast('Goal seek completed', 'success');
    }

    // ==================== SOLVER ====================
    let solverConstraints = [];

    function showSolver() {
      solverConstraints = [];
      document.getElementById('solverObjective').value = selectedRange.length ? selectedRange[0].dataset.ref : '';
      document.getElementById('solverChangeCells').value = '';
      document.getElementById('solverResult').style.display = 'none';
      renderSolverConstraints();
      document.getElementById('solverModal').classList.add('active');
    }

    function hideSolver() {
      document.getElementById('solverModal').classList.remove('active');
    }

    function addSolverConstraint() {
      const cell = document.getElementById('solverConstraintCell').value.trim().toUpperCase();
      const op = document.getElementById('solverConstraintOp').value;
      const value = document.getElementById('solverConstraintValue').value.trim();

      if (!cell || !value) {
        showToast('Please enter cell and value', 'error');
        return;
      }

      solverConstraints.push({ cell, op, value });
      renderSolverConstraints();

      document.getElementById('solverConstraintCell').value = '';
      document.getElementById('solverConstraintValue').value = '';
    }

    function removeSolverConstraint(index) {
      solverConstraints.splice(index, 1);
      renderSolverConstraints();
    }

    function clearSolverConstraints() {
      solverConstraints = [];
      renderSolverConstraints();
    }

    function renderSolverConstraints() {
      const container = document.getElementById('solverConstraints');
      if (solverConstraints.length === 0) {
        container.innerHTML = '<p style="color: #666; font-style: italic; margin: 0;">No constraints added</p>';
        return;
      }
      container.innerHTML = solverConstraints.map((c, i) => `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #eee;">
          <span>${c.cell} ${c.op} ${c.value}</span>
          <button class="btn btn-sm" onclick="removeSolverConstraint(${i})" style="padding: 2px 8px; font-size: 0.75rem;">√ó</button>
        </div>
      `).join('');
    }

    function runSolver() {
      const objectiveCell = document.getElementById('solverObjective').value.trim().toUpperCase();
      const changeCellsInput = document.getElementById('solverChangeCells').value.trim().toUpperCase();
      const goalType = document.querySelector('input[name="solverGoal"]:checked').value;
      const targetValue = parseFloat(document.getElementById('solverTargetValue').value) || 0;
      const nonNegative = document.getElementById('solverNonNegative').checked;
      const integerOnly = document.getElementById('solverInteger').checked;
      const maxIterations = parseInt(document.getElementById('solverMaxIterations').value) || 100;

      if (!objectiveCell || !changeCellsInput) {
        showToast('Please specify objective and change cells', 'error');
        return;
      }

      // Parse change cells (handle ranges and comma-separated)
      const changeCells = [];
      changeCellsInput.split(',').forEach(part => {
        part = part.trim();
        if (part.includes(':')) {
          const [start, end] = part.split(':');
          const startCol = start.match(/[A-Z]+/)[0];
          const startRow = parseInt(start.match(/\d+/)[0]);
          const endCol = end.match(/[A-Z]+/)[0];
          const endRow = parseInt(end.match(/\d+/)[0]);

          for (let c = startCol.charCodeAt(0); c <= endCol.charCodeAt(0); c++) {
            for (let r = startRow; r <= endRow; r++) {
              changeCells.push(String.fromCharCode(c) + r);
            }
          }
        } else {
          changeCells.push(part);
        }
      });

      // Store original values
      const originalValues = {};
      changeCells.forEach(cell => {
        originalValues[cell] = parseFloat(data[cell]) || 0;
      });

      // Simple gradient descent solver
      let currentValues = { ...originalValues };
      let bestValues = { ...currentValues };
      let bestObjective = evaluateObjective(objectiveCell, currentValues, changeCells);

      const stepSize = 0.1;
      let iterations = 0;
      let improved = true;

      while (improved && iterations < maxIterations) {
        improved = false;
        iterations++;

        for (const cell of changeCells) {
          // Try increasing
          currentValues[cell] += stepSize;
          applyValues(currentValues, changeCells);

          if (checkConstraints(currentValues, changeCells, nonNegative, integerOnly)) {
            const newObj = evaluateObjective(objectiveCell, currentValues, changeCells);
            if (isBetter(newObj, bestObjective, goalType, targetValue)) {
              bestObjective = newObj;
              bestValues = { ...currentValues };
              improved = true;
            }
          }

          // Try decreasing
          currentValues[cell] -= 2 * stepSize;
          applyValues(currentValues, changeCells);

          if (checkConstraints(currentValues, changeCells, nonNegative, integerOnly)) {
            const newObj = evaluateObjective(objectiveCell, currentValues, changeCells);
            if (isBetter(newObj, bestObjective, goalType, targetValue)) {
              bestObjective = newObj;
              bestValues = { ...currentValues };
              improved = true;
            }
          }

          // Reset to best
          currentValues[cell] = bestValues[cell];
        }
      }

      // Apply best solution
      applyValues(bestValues, changeCells);
      recalculateAll();

      // Show results
      let resultHTML = `<p>Iterations: ${iterations}</p>`;
      resultHTML += `<p>Objective (${objectiveCell}): ${bestObjective.toFixed(4)}</p>`;
      resultHTML += '<p>Variable values:</p><ul>';
      changeCells.forEach(cell => {
        resultHTML += `<li>${cell} = ${bestValues[cell].toFixed(4)}</li>`;
      });
      resultHTML += '</ul>';

      if (iterations >= maxIterations) {
        resultHTML += '<p style="color: #ff9800;">‚ö†Ô∏è Max iterations reached. Solution may not be optimal.</p>';
      }

      document.getElementById('solverResult').style.display = 'block';
      document.getElementById('solverResultText').innerHTML = resultHTML;
      showToast('Solver completed', 'success');
    }

    function evaluateObjective(objectiveCell, values, changeCells) {
      // Temporarily apply values
      changeCells.forEach(cell => {
        data[cell] = values[cell];
        updateCellDisplay(cell);
      });
      recalculateAll();
      return evaluateCell(objectiveCell);
    }

    function applyValues(values, changeCells) {
      changeCells.forEach(cell => {
        data[cell] = values[cell];
        updateCellDisplay(cell);
      });
    }

    function checkConstraints(values, changeCells, nonNegative, integerOnly) {
      // Check non-negative
      if (nonNegative) {
        for (const cell of changeCells) {
          if (values[cell] < 0) return false;
        }
      }

      // Check integer
      if (integerOnly) {
        for (const cell of changeCells) {
          if (!Number.isInteger(values[cell])) return false;
        }
      }

      // Check user constraints
      for (const constraint of solverConstraints) {
        const cellValue = evaluateCell(constraint.cell);
        const constraintValue = isNaN(parseFloat(constraint.value))
          ? evaluateCell(constraint.value.toUpperCase())
          : parseFloat(constraint.value);

        switch (constraint.op) {
          case '<=':
            if (cellValue > constraintValue) return false;
            break;
          case '>=':
            if (cellValue < constraintValue) return false;
            break;
          case '=':
            if (Math.abs(cellValue - constraintValue) > 0.001) return false;
            break;
        }
      }

      return true;
    }

    function isBetter(newVal, oldVal, goalType, targetValue) {
      if (goalType === 'max') return newVal > oldVal;
      if (goalType === 'min') return newVal < oldVal;
      if (goalType === 'value') return Math.abs(newVal - targetValue) < Math.abs(oldVal - targetValue);
      return false;
    }

    // ==================== FORMAT AS TABLE ====================
    let selectedTableStyle = 'blue';
    let tableFormatRanges = {};

    function showFormatTable() {
      if (selectedRange.length > 1) {
        const refs = selectedRange.map(s => s.dataset.ref);
        const sorted = refs.sort();
        document.getElementById('tableRange').value = sorted[0] + ':' + sorted[sorted.length - 1];
      } else {
        document.getElementById('tableRange').value = '';
      }
      document.getElementById('formatTableModal').classList.add('active');
    }

    function hideFormatTable() {
      document.getElementById('formatTableModal').classList.remove('active');
    }

    function selectTableStyle(style) {
      selectedTableStyle = style;
      document.querySelectorAll('.table-style-option').forEach(el => {
        el.style.borderColor = 'transparent';
      });
      event.target.style.borderColor = '#4285f4';
    }

    const tableColors = {
      blue: { header: '#4285f4', odd: '#c2deff', even: '#ffffff' },
      green: { header: '#34a853', odd: '#c6efce', even: '#ffffff' },
      orange: { header: '#ff9800', odd: '#ffe0b2', even: '#ffffff' },
      purple: { header: '#9c27b0', odd: '#e1bee7', even: '#ffffff' }
    };

    function applyTableFormat() {
      const range = document.getElementById('tableRange').value.toUpperCase();
      const hasHeaders = document.getElementById('tableHasHeaders').checked;

      if (!range || !range.includes(':')) {
        showToast('Enter a valid range', 'warning');
        return;
      }

      const parts = range.split(':');
      const startCol = parts[0].replace(/[0-9]/g, '').charCodeAt(0);
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endCol = parts[1].replace(/[0-9]/g, '').charCodeAt(0);
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      const colors = tableColors[selectedTableStyle];
      let rowIndex = 0;

      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          const ref = String.fromCharCode(c) + r;
          const cell = document.querySelector(`td[data-ref="${ref}"]`);
          if (cell) {
            if (hasHeaders && r === startRow) {
              cell.style.background = colors.header;
              cell.style.color = 'white';
              cell.style.fontWeight = 'bold';
            } else {
              const isOdd = (r - startRow - (hasHeaders ? 1 : 0)) % 2 === 0;
              cell.style.background = isOdd ? colors.odd : colors.even;
              cell.style.color = '#333';
            }
            cell.style.border = `1px solid ${colors.header}`;

            // Store formatting
            if (!formatting[ref]) formatting[ref] = {};
            formatting[ref].tableStyle = selectedTableStyle;
          }
        }
        rowIndex++;
      }

      tableFormatRanges[range] = { style: selectedTableStyle, hasHeaders };
      hideFormatTable();
      showToast('Table formatting applied', 'success');
    }

    // ==================== ADVANCED CONDITIONAL FORMATTING ====================
    let advCondFormats = {};

    function showAdvCondFormat() {
      if (selectedRange.length > 1) {
        const refs = selectedRange.map(s => s.dataset.ref);
        const sorted = refs.sort();
        document.getElementById('advCondRange').value = sorted[0] + ':' + sorted[sorted.length - 1];
      } else {
        document.getElementById('advCondRange').value = '';
      }
      updateAdvCondOptions();
      document.getElementById('advCondFormatModal').classList.add('active');
    }

    function hideAdvCondFormat() {
      document.getElementById('advCondFormatModal').classList.remove('active');
    }

    function updateAdvCondOptions() {
      const type = document.getElementById('advCondType').value;
      const container = document.getElementById('advCondOptions');

      let html = '';
      switch (type) {
        case 'dataBar':
          html = `
            <div class="form-group">
              <label>Bar Color</label>
              <input type="color" class="form-control" id="dataBarColor" value="#4285f4" style="height: 40px;">
            </div>
            <div class="form-group">
              <label>Fill Type</label>
              <select class="form-control" id="dataBarFill">
                <option value="solid">Solid Fill</option>
                <option value="gradient">Gradient Fill</option>
              </select>
            </div>
          `;
          break;
        case 'colorScale':
          html = `
            <div class="form-group">
              <label>Minimum Color</label>
              <input type="color" class="form-control" id="colorScaleMin" value="#f8d7da" style="height: 40px;">
            </div>
            <div class="form-group">
              <label>Midpoint Color</label>
              <input type="color" class="form-control" id="colorScaleMid" value="#fff3cd" style="height: 40px;">
            </div>
            <div class="form-group">
              <label>Maximum Color</label>
              <input type="color" class="form-control" id="colorScaleMax" value="#d4edda" style="height: 40px;">
            </div>
          `;
          break;
        case 'iconSet':
          html = `
            <div class="form-group">
              <label>Icon Set</label>
              <select class="form-control" id="iconSetType">
                <option value="arrows">Arrows (3)</option>
                <option value="circles">Traffic Lights (3)</option>
                <option value="flags">Flags (3)</option>
                <option value="stars">Stars (3)</option>
              </select>
            </div>
            <div class="form-group">
              <label><input type="checkbox" id="iconShowOnly"> Show Icon Only</label>
            </div>
          `;
          break;
        case 'topBottom':
          html = `
            <div class="form-group">
              <label>Rule Type</label>
              <select class="form-control" id="topBottomType">
                <option value="top10">Top 10 Items</option>
                <option value="bottom10">Bottom 10 Items</option>
                <option value="top10pct">Top 10%</option>
                <option value="bottom10pct">Bottom 10%</option>
                <option value="aboveAvg">Above Average</option>
                <option value="belowAvg">Below Average</option>
              </select>
            </div>
            <div class="form-group">
              <label>Highlight Color</label>
              <input type="color" class="form-control" id="topBottomColor" value="#fff3cd" style="height: 40px;">
            </div>
          `;
          break;
      }
      container.innerHTML = html;
    }

    function applyAdvCondFormat() {
      const range = document.getElementById('advCondRange').value.toUpperCase();
      const type = document.getElementById('advCondType').value;

      if (!range || !range.includes(':')) {
        showToast('Enter a valid range', 'warning');
        return;
      }

      const parts = range.split(':');
      const startCol = parts[0].replace(/[0-9]/g, '').charCodeAt(0);
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endCol = parts[1].replace(/[0-9]/g, '').charCodeAt(0);
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      // Gather all values in range
      const values = [];
      const cells = [];
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          const ref = String.fromCharCode(c) + r;
          const val = parseFloat(data[ref]) || 0;
          values.push(val);
          cells.push({ ref, val });
        }
      }

      const min = Math.min(...values);
      const max = Math.max(...values);
      const avg = values.reduce((a, b) => a + b, 0) / values.length;

      cells.forEach(({ ref, val }) => {
        const cell = document.querySelector(`td[data-ref="${ref}"]`);
        if (!cell) return;

        switch (type) {
          case 'dataBar':
            const barColor = document.getElementById('dataBarColor').value;
            const fillType = document.getElementById('dataBarFill').value;
            const pct = ((val - min) / (max - min || 1)) * 100;
            if (fillType === 'gradient') {
              cell.style.background = `linear-gradient(to right, ${barColor}80 ${pct}%, transparent ${pct}%)`;
            } else {
              cell.style.background = `linear-gradient(to right, ${barColor} ${pct}%, transparent ${pct}%)`;
            }
            break;

          case 'colorScale':
            const minColor = document.getElementById('colorScaleMin').value;
            const midColor = document.getElementById('colorScaleMid').value;
            const maxColor = document.getElementById('colorScaleMax').value;
            const ratio = (val - min) / (max - min || 1);
            cell.style.background = interpolateColor(minColor, midColor, maxColor, ratio);
            break;

          case 'iconSet':
            const iconType = document.getElementById('iconSetType').value;
            const showOnly = document.getElementById('iconShowOnly').checked;
            const icons = getIcons(iconType);
            const tier = val < avg * 0.67 ? 0 : val < avg * 1.33 ? 1 : 2;
            const icon = icons[tier];
            if (showOnly) {
              cell.innerHTML = icon;
            } else {
              cell.innerHTML = icon + ' ' + (data[ref] || '');
            }
            break;

          case 'topBottom':
            const tbType = document.getElementById('topBottomType').value;
            const tbColor = document.getElementById('topBottomColor').value;
            const sortedVals = [...values].sort((a, b) => b - a);
            let shouldHighlight = false;

            if (tbType === 'top10') {
              shouldHighlight = sortedVals.indexOf(val) < 10;
            } else if (tbType === 'bottom10') {
              shouldHighlight = sortedVals.indexOf(val) >= sortedVals.length - 10;
            } else if (tbType === 'top10pct') {
              shouldHighlight = val >= sortedVals[Math.floor(values.length * 0.1)];
            } else if (tbType === 'bottom10pct') {
              shouldHighlight = val <= sortedVals[Math.floor(values.length * 0.9)];
            } else if (tbType === 'aboveAvg') {
              shouldHighlight = val > avg;
            } else if (tbType === 'belowAvg') {
              shouldHighlight = val < avg;
            }

            if (shouldHighlight) {
              cell.style.background = tbColor;
            }
            break;
        }
      });

      advCondFormats[range] = { type };
      hideAdvCondFormat();
      showToast('Conditional formatting applied', 'success');
    }

    function getIcons(type) {
      switch (type) {
        case 'arrows': return ['‚¨áÔ∏è', '‚û°Ô∏è', '‚¨ÜÔ∏è'];
        case 'circles': return ['üî¥', 'üü°', 'üü¢'];
        case 'flags': return ['üö©', 'üü®', 'üü©'];
        case 'stars': return ['‚òÜ', '‚≠ê', 'üåü'];
        default: return ['‚ùå', '‚ûñ', '‚úÖ'];
      }
    }

    function interpolateColor(c1, c2, c3, ratio) {
      const hex = (c) => parseInt(c.slice(1), 16);
      const r1 = hex(c1) >> 16, g1 = (hex(c1) >> 8) & 0xff, b1 = hex(c1) & 0xff;
      const r2 = hex(c2) >> 16, g2 = (hex(c2) >> 8) & 0xff, b2 = hex(c2) & 0xff;
      const r3 = hex(c3) >> 16, g3 = (hex(c3) >> 8) & 0xff, b3 = hex(c3) & 0xff;

      let r, g, b;
      if (ratio < 0.5) {
        const t = ratio * 2;
        r = Math.round(r1 + (r2 - r1) * t);
        g = Math.round(g1 + (g2 - g1) * t);
        b = Math.round(b1 + (b2 - b1) * t);
      } else {
        const t = (ratio - 0.5) * 2;
        r = Math.round(r2 + (r3 - r2) * t);
        g = Math.round(g2 + (g3 - g2) * t);
        b = Math.round(b2 + (b3 - b2) * t);
      }

      return `rgb(${r}, ${g}, ${b})`;
    }

    function clearAdvCondFormat() {
      const range = document.getElementById('advCondRange').value.toUpperCase();
      if (!range) return;

      const parts = range.split(':');
      const startCol = parts[0].replace(/[0-9]/g, '').charCodeAt(0);
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endCol = parts[1].replace(/[0-9]/g, '').charCodeAt(0);
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          const ref = String.fromCharCode(c) + r;
          const cell = document.querySelector(`td[data-ref="${ref}"]`);
          if (cell) {
            cell.style.background = '';
            cell.textContent = data[ref] || '';
          }
        }
      }

      delete advCondFormats[range];
      showToast('Conditional formatting cleared', 'success');
    }

    // ==========================================
    // Subtotals Functions
    // ==========================================
    let subtotalRows = new Set();

    function showSubtotals() {
      document.getElementById('subtotalsModal').style.display = 'flex';
      // Auto-populate range if cells selected
      if (selectedRange.length > 1) {
        const refs = selectedRange.map(r => r);
        const cols = refs.map(r => r.charCodeAt(0));
        const rows = refs.map(r => parseInt(r.substring(1)));
        const startRef = String.fromCharCode(Math.min(...cols)) + Math.min(...rows);
        const endRef = String.fromCharCode(Math.max(...cols)) + Math.max(...rows);
        document.getElementById('subtotalRange').value = `${startRef}:${endRef}`;
      }
    }

    function hideSubtotals() {
      document.getElementById('subtotalsModal').style.display = 'none';
    }

    function applySubtotals() {
      const range = document.getElementById('subtotalRange').value.toUpperCase();
      const groupByCol = document.getElementById('subtotalGroupBy').value;
      const func = document.getElementById('subtotalFunction').value;
      const applyToCol = document.getElementById('subtotalApplyTo').value;
      const replace = document.getElementById('subtotalReplace').checked;

      if (!range || !range.includes(':')) {
        showToast('Please enter a valid range', 'warning');
        return;
      }

      const parts = range.split(':');
      const startCol = parts[0].replace(/[0-9]/g, '').charCodeAt(0);
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endCol = parts[1].replace(/[0-9]/g, '').charCodeAt(0);
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      // Remove existing subtotals if replace is checked
      if (replace) {
        removeSubtotals(false);
      }

      // Group data by the specified column
      const groups = {};
      for (let r = startRow; r <= endRow; r++) {
        const groupKey = data[groupByCol + r] || 'Other';
        if (!groups[groupKey]) groups[groupKey] = [];
        groups[groupKey].push(r);
      }

      // Calculate and insert subtotals
      const sortedGroups = Object.keys(groups).sort();
      let insertedRows = 0;

      sortedGroups.forEach(group => {
        const rows = groups[group];
        const lastRowInGroup = Math.max(...rows) + insertedRows;
        const subtotalRow = lastRowInGroup + 1;

        // Calculate subtotal
        const values = rows.map(r => parseFloat(data[applyToCol + r]) || 0);
        let result;
        switch (func) {
          case 'sum': result = values.reduce((a, b) => a + b, 0); break;
          case 'count': result = values.filter(v => v !== 0).length; break;
          case 'average': result = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0; break;
          case 'max': result = Math.max(...values); break;
          case 'min': result = Math.min(...values); break;
        }

        // Insert subtotal row (we'll style existing rows instead of truly inserting)
        const subtotalRef = applyToCol + subtotalRow;
        if (subtotalRow <= ROWS) {
          data[subtotalRef] = Math.round(result * 100) / 100;
          data[groupByCol + subtotalRow] = `${group} ${func.toUpperCase()}`;

          // Style the subtotal row
          subtotalRows.add(subtotalRow);
          for (let c = startCol; c <= endCol; c++) {
            const ref = String.fromCharCode(c) + subtotalRow;
            const cell = document.getElementById(ref);
            if (cell) {
              cell.style.background = '#e8f0fe';
              cell.style.fontWeight = 'bold';
              cell.value = data[ref] || '';
            }
          }
        }

        insertedRows++;
      });

      // Add grand total
      const allValues = [];
      for (let r = startRow; r <= endRow; r++) {
        const val = parseFloat(data[applyToCol + r]);
        if (!isNaN(val)) allValues.push(val);
      }

      let grandTotal;
      switch (func) {
        case 'sum': grandTotal = allValues.reduce((a, b) => a + b, 0); break;
        case 'count': grandTotal = allValues.length; break;
        case 'average': grandTotal = allValues.length ? allValues.reduce((a, b) => a + b, 0) / allValues.length : 0; break;
        case 'max': grandTotal = Math.max(...allValues); break;
        case 'min': grandTotal = Math.min(...allValues); break;
      }

      const grandTotalRow = endRow + sortedGroups.length + 1;
      if (grandTotalRow <= ROWS) {
        data[groupByCol + grandTotalRow] = 'Grand Total';
        data[applyToCol + grandTotalRow] = Math.round(grandTotal * 100) / 100;
        subtotalRows.add(grandTotalRow);

        for (let c = startCol; c <= endCol; c++) {
          const ref = String.fromCharCode(c) + grandTotalRow;
          const cell = document.getElementById(ref);
          if (cell) {
            cell.style.background = '#c8e6c9';
            cell.style.fontWeight = 'bold';
            cell.value = data[ref] || '';
          }
        }
      }

      hideSubtotals();
      showToast('Subtotals applied', 'success');
    }

    function removeSubtotals(notify = true) {
      subtotalRows.forEach(row => {
        for (let c = 65; c <= 90; c++) { // A to Z
          const ref = String.fromCharCode(c) + row;
          const cell = document.getElementById(ref);
          if (cell) {
            cell.style.background = '';
            cell.style.fontWeight = '';
            if (data[ref] && (String(data[ref]).includes('Total') || String(data[ref]).includes('SUM') ||
                String(data[ref]).includes('COUNT') || String(data[ref]).includes('AVERAGE') ||
                String(data[ref]).includes('MAX') || String(data[ref]).includes('MIN'))) {
              delete data[ref];
              cell.value = '';
            }
          }
        }
      });
      subtotalRows.clear();
      if (notify) showToast('Subtotals removed', 'success');
    }

    // ==========================================
    // Slicers Functions
    // ==========================================
    let slicers = [];
    let slicerFilters = {};

    function showSlicers() {
      document.getElementById('slicersModal').style.display = 'flex';
      document.getElementById('slicerRange').addEventListener('blur', previewSlicerOptions);
      document.getElementById('slicerColumn').addEventListener('change', previewSlicerOptions);
    }

    function hideSlicers() {
      document.getElementById('slicersModal').style.display = 'none';
    }

    function previewSlicerOptions() {
      const range = document.getElementById('slicerRange').value.toUpperCase();
      const column = document.getElementById('slicerColumn').value;
      const preview = document.getElementById('slicerPreview');

      if (!range || !range.includes(':')) {
        preview.innerHTML = '<p style="color: #666; text-align: center; font-size: 0.9rem;">Enter a valid data range</p>';
        return;
      }

      const parts = range.split(':');
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      // Get unique values from the column
      const uniqueValues = new Set();
      for (let r = startRow; r <= endRow; r++) {
        const val = data[column + r];
        if (val !== undefined && val !== '') {
          uniqueValues.add(val);
        }
      }

      if (uniqueValues.size === 0) {
        preview.innerHTML = '<p style="color: #666; text-align: center; font-size: 0.9rem;">No data found in selected column</p>';
        return;
      }

      const sortedValues = [...uniqueValues].sort();
      preview.innerHTML = `
        <p style="font-weight: bold; margin-bottom: 0.5rem;">Preview (${sortedValues.length} unique values):</p>
        <div style="display: flex; flex-wrap: wrap; gap: 0.25rem;">
          ${sortedValues.slice(0, 10).map(v => `<span style="padding: 0.25rem 0.5rem; background: #e8f0fe; border-radius: 4px; font-size: 0.85rem;">${v}</span>`).join('')}
          ${sortedValues.length > 10 ? `<span style="padding: 0.25rem 0.5rem; color: #666; font-size: 0.85rem;">...and ${sortedValues.length - 10} more</span>` : ''}
        </div>
      `;
    }

    function getSlicerColors(style) {
      const colors = {
        blue: { bg: '#e8f0fe', active: '#1a73e8', border: '#4285f4' },
        green: { bg: '#e6f4ea', active: '#1e8e3e', border: '#34a853' },
        orange: { bg: '#fef7e0', active: '#e37400', border: '#f9ab00' },
        gray: { bg: '#f1f3f4', active: '#5f6368', border: '#9aa0a6' }
      };
      return colors[style] || colors.blue;
    }

    function insertSlicer() {
      const range = document.getElementById('slicerRange').value.toUpperCase();
      const column = document.getElementById('slicerColumn').value;
      const title = document.getElementById('slicerTitle').value || `Filter by ${column}`;
      const style = document.getElementById('slicerStyle').value;

      if (!range || !range.includes(':')) {
        showToast('Please enter a valid range', 'warning');
        return;
      }

      const parts = range.split(':');
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      // Get unique values
      const uniqueValues = new Set();
      for (let r = startRow; r <= endRow; r++) {
        const val = data[column + r];
        if (val !== undefined && val !== '') {
          uniqueValues.add(val);
        }
      }

      if (uniqueValues.size === 0) {
        showToast('No data found in selected column', 'warning');
        return;
      }

      const slicerId = 'slicer_' + Date.now();
      const slicerData = {
        id: slicerId,
        range,
        column,
        title,
        style,
        values: [...uniqueValues].sort(),
        selected: new Set([...uniqueValues]) // All selected by default
      };

      slicers.push(slicerData);
      renderSlicer(slicerData);

      hideSlicers();
      showToast('Slicer created', 'success');
    }

    function renderSlicer(slicer) {
      const colors = getSlicerColors(slicer.style);
      const container = document.getElementById('slicerContainer');

      const slicerEl = document.createElement('div');
      slicerEl.id = slicer.id;
      slicerEl.className = 'slicer';
      slicerEl.style.cssText = `
        width: 200px;
        background: white;
        border: 1px solid ${colors.border};
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 1rem;
        overflow: hidden;
      `;

      const header = document.createElement('div');
      header.style.cssText = `
        padding: 0.75rem;
        background: ${colors.bg};
        border-bottom: 1px solid ${colors.border};
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        font-size: 0.9rem;
        cursor: move;
      `;
      header.innerHTML = `
        <span>${slicer.title}</span>
        <button onclick="removeSlicer('${slicer.id}')" style="background: none; border: none; cursor: pointer; font-size: 1.2rem; color: #666;">&times;</button>
      `;

      const controls = document.createElement('div');
      controls.style.cssText = `padding: 0.5rem; border-bottom: 1px solid #eee; display: flex; gap: 0.5rem;`;
      controls.innerHTML = `
        <button onclick="selectAllSlicerValues('${slicer.id}')" style="flex: 1; padding: 0.25rem; font-size: 0.75rem; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; background: white;">Select All</button>
        <button onclick="clearSlicerValues('${slicer.id}')" style="flex: 1; padding: 0.25rem; font-size: 0.75rem; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; background: white;">Clear</button>
      `;

      const body = document.createElement('div');
      body.style.cssText = 'max-height: 200px; overflow-y: auto; padding: 0.5rem;';

      slicer.values.forEach(val => {
        const item = document.createElement('div');
        item.style.cssText = `
          padding: 0.4rem 0.6rem;
          margin: 0.2rem 0;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.85rem;
          background: ${slicer.selected.has(val) ? colors.active : colors.bg};
          color: ${slicer.selected.has(val) ? 'white' : 'inherit'};
          transition: all 0.15s ease;
        `;
        item.textContent = val;
        item.onclick = () => toggleSlicerValue(slicer.id, val);
        item.dataset.value = val;
        body.appendChild(item);
      });

      slicerEl.appendChild(header);
      slicerEl.appendChild(controls);
      slicerEl.appendChild(body);
      container.appendChild(slicerEl);

      // Make draggable
      makeDraggable(slicerEl, header);
    }

    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      handle.onmousedown = dragMouseDown;

      function dragMouseDown(e) {
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }

      function elementDrag(e) {
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
        element.style.right = 'auto';
        element.style.position = 'absolute';
      }

      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }

    function toggleSlicerValue(slicerId, value) {
      const slicer = slicers.find(s => s.id === slicerId);
      if (!slicer) return;

      if (slicer.selected.has(value)) {
        slicer.selected.delete(value);
      } else {
        slicer.selected.add(value);
      }

      updateSlicerUI(slicer);
      applySlicerFilter(slicer);
    }

    function selectAllSlicerValues(slicerId) {
      const slicer = slicers.find(s => s.id === slicerId);
      if (!slicer) return;

      slicer.values.forEach(v => slicer.selected.add(v));
      updateSlicerUI(slicer);
      applySlicerFilter(slicer);
    }

    function clearSlicerValues(slicerId) {
      const slicer = slicers.find(s => s.id === slicerId);
      if (!slicer) return;

      slicer.selected.clear();
      updateSlicerUI(slicer);
      applySlicerFilter(slicer);
    }

    function updateSlicerUI(slicer) {
      const colors = getSlicerColors(slicer.style);
      const slicerEl = document.getElementById(slicer.id);
      if (!slicerEl) return;

      const items = slicerEl.querySelectorAll('[data-value]');
      items.forEach(item => {
        const val = item.dataset.value;
        item.style.background = slicer.selected.has(val) ? colors.active : colors.bg;
        item.style.color = slicer.selected.has(val) ? 'white' : 'inherit';
      });
    }

    function applySlicerFilter(slicer) {
      const parts = slicer.range.split(':');
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));
      const startCol = parts[0].replace(/[0-9]/g, '').charCodeAt(0);
      const endCol = parts[1].replace(/[0-9]/g, '').charCodeAt(0);

      // Show/hide rows based on filter
      for (let r = startRow; r <= endRow; r++) {
        const cellValue = data[slicer.column + r];
        const shouldShow = slicer.selected.size === 0 || slicer.selected.has(cellValue);

        for (let c = startCol; c <= endCol; c++) {
          const cell = document.getElementById(String.fromCharCode(c) + r);
          if (cell) {
            const td = cell.closest('td');
            const tr = td?.closest('tr');
            if (tr) {
              tr.style.display = shouldShow ? '' : 'none';
            }
          }
        }
      }

      showToast('Filter applied', 'success');
    }

    function removeSlicer(slicerId) {
      const slicer = slicers.find(s => s.id === slicerId);
      if (slicer) {
        // Reset filter - show all rows
        const parts = slicer.range.split(':');
        const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
        const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

        for (let r = startRow; r <= endRow; r++) {
          const cell = document.getElementById('A' + r);
          if (cell) {
            const tr = cell.closest('tr');
            if (tr) tr.style.display = '';
          }
        }
      }

      slicers = slicers.filter(s => s.id !== slicerId);
      const el = document.getElementById(slicerId);
      if (el) el.remove();
      showToast('Slicer removed', 'success');
    }

    // ==================== SCENARIO MANAGER ====================
    let scenarios = [];
    let currentScenarioChangingCells = [];

    function showScenarioManager() {
      document.getElementById('scenarioManagerModal').style.display = 'flex';
      renderScenarioList();
    }

    function hideScenarioManager() {
      document.getElementById('scenarioManagerModal').style.display = 'none';
    }

    function renderScenarioList() {
      const list = document.getElementById('scenarioList');
      if (scenarios.length === 0) {
        list.innerHTML = '<p style="color: #666; font-style: italic;">No scenarios defined. Click "Add" to create one.</p>';
        return;
      }
      list.innerHTML = scenarios.map((s, i) => `
        <div class="scenario-item ${i === 0 ? 'selected' : ''}" onclick="selectScenario(${i})" data-index="${i}">
          <strong>${s.name}</strong>
          <div style="font-size: 11px; color: #666;">Changing cells: ${s.changingCells}</div>
        </div>
      `).join('');
    }

    function selectScenario(index) {
      document.querySelectorAll('.scenario-item').forEach(el => el.classList.remove('selected'));
      document.querySelector(`.scenario-item[data-index="${index}"]`)?.classList.add('selected');
    }

    function getSelectedScenarioIndex() {
      const selected = document.querySelector('.scenario-item.selected');
      return selected ? parseInt(selected.dataset.index) : -1;
    }

    function showAddScenario() {
      document.getElementById('addScenarioModal').style.display = 'flex';
      document.getElementById('newScenarioName').value = 'Scenario ' + (scenarios.length + 1);
      document.getElementById('newScenarioChangingCells').value = selectedRange || 'B2:B5';
      currentScenarioChangingCells = [];
    }

    function hideAddScenario() {
      document.getElementById('addScenarioModal').style.display = 'none';
    }

    function proceedToScenarioValues() {
      const name = document.getElementById('newScenarioName').value.trim();
      const cells = document.getElementById('newScenarioChangingCells').value.trim();

      if (!name) {
        showToast('Please enter a scenario name', 'error');
        return;
      }
      if (!cells) {
        showToast('Please specify changing cells', 'error');
        return;
      }

      // Parse the cell range
      const cellList = expandRange(cells);
      currentScenarioChangingCells = cellList;

      // Build value inputs
      const container = document.getElementById('scenarioValuesContainer');
      container.innerHTML = cellList.map(cell => {
        const currentVal = getCellValue(cell) || '';
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
            <label style="width: 50px; font-weight: 500;">${cell}:</label>
            <input type="text" id="scenarioVal_${cell}" value="${currentVal}" style="flex: 1; padding: 0.25rem;">
          </div>
        `;
      }).join('');

      document.getElementById('scenarioStep1').style.display = 'none';
      document.getElementById('scenarioStep2').style.display = 'block';
    }

    function backToScenarioStep1() {
      document.getElementById('scenarioStep1').style.display = 'block';
      document.getElementById('scenarioStep2').style.display = 'none';
    }

    function saveScenario() {
      const name = document.getElementById('newScenarioName').value.trim();
      const cells = document.getElementById('newScenarioChangingCells').value.trim();

      const values = {};
      currentScenarioChangingCells.forEach(cell => {
        values[cell] = document.getElementById('scenarioVal_' + cell).value;
      });

      scenarios.push({
        name: name,
        changingCells: cells,
        values: values
      });

      hideAddScenario();
      renderScenarioList();
      showToast('Scenario "' + name + '" saved', 'success');

      // Reset for next time
      document.getElementById('scenarioStep1').style.display = 'block';
      document.getElementById('scenarioStep2').style.display = 'none';
    }

    function expandRange(range) {
      // Expand a range like A1:A5 or A1,B2,C3 into array of cells
      const cells = [];
      const parts = range.split(',').map(p => p.trim());

      parts.forEach(part => {
        if (part.includes(':')) {
          const [start, end] = part.split(':');
          const startCol = start.replace(/[0-9]/g, '');
          const startRow = parseInt(start.replace(/[A-Z]/gi, ''));
          const endCol = end.replace(/[0-9]/g, '');
          const endRow = parseInt(end.replace(/[A-Z]/gi, ''));

          const startColNum = startCol.charCodeAt(0) - 65;
          const endColNum = endCol.charCodeAt(0) - 65;

          for (let c = startColNum; c <= endColNum; c++) {
            for (let r = startRow; r <= endRow; r++) {
              cells.push(String.fromCharCode(65 + c) + r);
            }
          }
        } else {
          cells.push(part);
        }
      });

      return cells;
    }

    function showScenario() {
      const index = getSelectedScenarioIndex();
      if (index < 0) {
        showToast('Please select a scenario', 'error');
        return;
      }

      const scenario = scenarios[index];
      Object.entries(scenario.values).forEach(([cell, value]) => {
        setCellValue(cell, value);
      });

      showToast('Showing scenario: ' + scenario.name, 'success');
    }

    function deleteScenario() {
      const index = getSelectedScenarioIndex();
      if (index < 0) {
        showToast('Please select a scenario', 'error');
        return;
      }

      const name = scenarios[index].name;
      scenarios.splice(index, 1);
      renderScenarioList();
      showToast('Scenario "' + name + '" deleted', 'success');
    }

    function createScenarioReport() {
      if (scenarios.length === 0) {
        showToast('No scenarios to summarize', 'error');
        return;
      }

      // Create a summary in a new area of the sheet
      const startRow = 20;
      const startCol = 'E';

      setCellValue(startCol + startRow, 'Scenario Summary');
      setCellValue(startCol + (startRow + 1), 'Changing Cells:');

      // Get all unique changing cells
      const allCells = [...new Set(scenarios.flatMap(s => Object.keys(s.values)))];

      // Header row with scenario names
      let col = startCol.charCodeAt(0) - 65 + 1;
      scenarios.forEach((s, i) => {
        setCellValue(String.fromCharCode(65 + col + i) + (startRow + 1), s.name);
      });

      // Data rows
      allCells.forEach((cell, rowOffset) => {
        setCellValue(startCol + (startRow + 2 + rowOffset), cell);
        scenarios.forEach((s, colOffset) => {
          const val = s.values[cell] || '';
          setCellValue(String.fromCharCode(65 + col + colOffset) + (startRow + 2 + rowOffset), val);
        });
      });

      hideScenarioManager();
      showToast('Scenario summary created at ' + startCol + startRow, 'success');
    }

    // ==================== DATA TABLE (What-If Analysis) ====================
    let dataTableConfig = { type: 'one-variable' };

    function showDataTable() {
      document.getElementById('dataTableModal').style.display = 'flex';
      document.getElementById('dataTableRange').value = selectedRange || 'A1:D5';
      updateDataTableOptions();
    }

    function hideDataTable() {
      document.getElementById('dataTableModal').style.display = 'none';
    }

    function updateDataTableOptions() {
      const type = document.getElementById('dataTableType').value;
      dataTableConfig.type = type;

      const colInput = document.getElementById('colInputCellGroup');
      if (type === 'one-variable') {
        colInput.style.display = 'none';
      } else {
        colInput.style.display = 'block';
      }
    }

    function generateDataTable() {
      const range = document.getElementById('dataTableRange').value.trim();
      const rowInput = document.getElementById('rowInputCell').value.trim();
      const colInput = document.getElementById('colInputCell').value.trim();

      if (!range) {
        showToast('Please specify a data table range', 'error');
        return;
      }

      // Parse the range
      const [startCell, endCell] = range.split(':');
      const startCol = startCell.replace(/[0-9]/g, '').charCodeAt(0) - 65;
      const startRow = parseInt(startCell.replace(/[A-Z]/gi, ''));
      const endCol = endCell.replace(/[0-9]/g, '').charCodeAt(0) - 65;
      const endRow = parseInt(endCell.replace(/[A-Z]/gi, ''));

      // The formula cell is at top-left corner
      const formulaCell = String.fromCharCode(65 + startCol) + startRow;
      const formula = getCellValue(formulaCell);

      if (dataTableConfig.type === 'one-variable') {
        // Input values are in the first column (below the formula)
        // Results go in subsequent columns
        const originalValue = getCellValue(rowInput);

        for (let r = startRow + 1; r <= endRow; r++) {
          const inputValue = getCellValue(String.fromCharCode(65 + startCol) + r);

          // Temporarily set the input cell
          setCellValue(rowInput, inputValue);

          // Recalculate and get result
          recalculateAll();
          const result = getCellValue(formulaCell);

          // Store result in next column
          setCellValue(String.fromCharCode(65 + startCol + 1) + r, result);
        }

        // Restore original value
        setCellValue(rowInput, originalValue);
        recalculateAll();

      } else {
        // Two-variable data table
        const originalRowValue = getCellValue(rowInput);
        const originalColValue = getCellValue(colInput);

        // Row inputs are in first row (starting from second column)
        // Column inputs are in first column (starting from second row)
        for (let r = startRow + 1; r <= endRow; r++) {
          const colInputValue = getCellValue(String.fromCharCode(65 + startCol) + r);
          setCellValue(colInput, colInputValue);

          for (let c = startCol + 1; c <= endCol; c++) {
            const rowInputValue = getCellValue(String.fromCharCode(65 + c) + startRow);
            setCellValue(rowInput, rowInputValue);

            recalculateAll();
            const result = getCellValue(formulaCell);
            setCellValue(String.fromCharCode(65 + c) + r, result);
          }
        }

        // Restore original values
        setCellValue(rowInput, originalRowValue);
        setCellValue(colInput, originalColValue);
        recalculateAll();
      }

      hideDataTable();
      showToast('Data table generated', 'success');
    }

    // ==================== SHEET PROTECTION ====================
    let sheetProtection = {
      enabled: false,
      password: '',
      options: {
        selectLockedCells: true,
        selectUnlockedCells: true,
        formatCells: false,
        formatColumns: false,
        formatRows: false,
        insertColumns: false,
        insertRows: false,
        insertHyperlinks: false,
        deleteColumns: false,
        deleteRows: false,
        sort: false,
        autoFilter: false
      }
    };
    let lockedCells = new Set();

    function showSheetProtection() {
      document.getElementById('sheetProtectionModal').style.display = 'flex';

      // Set current state
      Object.keys(sheetProtection.options).forEach(key => {
        const checkbox = document.getElementById('protect_' + key);
        if (checkbox) checkbox.checked = sheetProtection.options[key];
      });
    }

    function hideSheetProtection() {
      document.getElementById('sheetProtectionModal').style.display = 'none';
    }

    function protectSheet() {
      const password = document.getElementById('protectionPassword').value;

      // Collect options
      Object.keys(sheetProtection.options).forEach(key => {
        const checkbox = document.getElementById('protect_' + key);
        if (checkbox) sheetProtection.options[key] = checkbox.checked;
      });

      sheetProtection.enabled = true;
      sheetProtection.password = password;

      // Lock all cells by default (in a real app, you'd allow selecting which cells to lock)
      document.querySelectorAll('.spreadsheet td').forEach(cell => {
        if (cell.id && !lockedCells.has(cell.id)) {
          lockedCells.add(cell.id);
        }
      });

      // Add visual indicator
      document.getElementById('spreadsheet').classList.add('protected');

      hideSheetProtection();
      showToast('Sheet protected', 'success');
    }

    function unprotectSheet() {
      if (sheetProtection.password) {
        const entered = prompt('Enter password to unprotect sheet:');
        if (entered !== sheetProtection.password) {
          showToast('Incorrect password', 'error');
          return;
        }
      }

      sheetProtection.enabled = false;
      sheetProtection.password = '';
      lockedCells.clear();

      document.getElementById('spreadsheet').classList.remove('protected');
      hideSheetProtection();
      showToast('Sheet unprotected', 'success');
    }

    function lockSelectedCells() {
      if (!selectedRange) {
        showToast('Please select cells first', 'error');
        return;
      }

      const cells = expandRange(selectedRange);
      cells.forEach(cell => lockedCells.add(cell));
      showToast(cells.length + ' cells locked', 'success');
    }

    function unlockSelectedCells() {
      if (!selectedRange) {
        showToast('Please select cells first', 'error');
        return;
      }

      const cells = expandRange(selectedRange);
      cells.forEach(cell => lockedCells.delete(cell));
      showToast(cells.length + ' cells unlocked', 'success');
    }

    // Override cell editing when protected
    const originalSetCellValue = setCellValue;
    setCellValue = function(cellId, value, skipRecalc) {
      if (sheetProtection.enabled && lockedCells.has(cellId)) {
        showToast('Cannot edit locked cell', 'error');
        return;
      }
      return originalSetCellValue(cellId, value, skipRecalc);
    };

    // ==================== FORMULA AUDITING ====================
    let traceArrows = [];
    let watchedCells = [];
    let showFormulasMode = false;

    function showFormulaAuditing() {
      document.getElementById('formulaAuditingModal').style.display = 'flex';
      updateWatchWindow();
    }

    function hideFormulaAuditing() {
      document.getElementById('formulaAuditingModal').style.display = 'none';
    }

    function tracePrecedents() {
      if (!selectedCell) {
        showToast('Please select a cell first', 'error');
        return;
      }

      const formula = getCellValue(selectedCell);
      if (!formula || !formula.toString().startsWith('=')) {
        showToast('Selected cell has no formula', 'info');
        return;
      }

      // Find all cell references in the formula
      const cellRefs = formula.match(/[A-Z]+[0-9]+/gi) || [];

      clearTraceArrows();

      cellRefs.forEach(ref => {
        drawArrow(ref, selectedCell, 'precedent');
      });

      showToast('Showing ' + cellRefs.length + ' precedent(s)', 'success');
    }

    function traceDependents() {
      if (!selectedCell) {
        showToast('Please select a cell first', 'error');
        return;
      }

      clearTraceArrows();
      let dependentCount = 0;

      // Search all cells for formulas that reference this cell
      const sheet = sheets[currentSheet];
      Object.entries(sheet).forEach(([cellId, value]) => {
        if (value && value.toString().startsWith('=')) {
          const refs = value.match(/[A-Z]+[0-9]+/gi) || [];
          if (refs.includes(selectedCell.toUpperCase())) {
            drawArrow(selectedCell, cellId, 'dependent');
            dependentCount++;
          }
        }
      });

      showToast('Showing ' + dependentCount + ' dependent(s)', 'success');
    }

    function drawArrow(fromCell, toCell, type) {
      const fromEl = document.getElementById(fromCell);
      const toEl = document.getElementById(toCell);

      if (!fromEl || !toEl) return;

      const container = document.getElementById('spreadsheet');
      const containerRect = container.getBoundingClientRect();
      const fromRect = fromEl.getBoundingClientRect();
      const toRect = toEl.getBoundingClientRect();

      // Create SVG arrow
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.classList.add('trace-arrow');
      svg.style.position = 'absolute';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '1000';
      svg.style.overflow = 'visible';

      const x1 = fromRect.left + fromRect.width / 2 - containerRect.left + container.scrollLeft;
      const y1 = fromRect.top + fromRect.height / 2 - containerRect.top + container.scrollTop;
      const x2 = toRect.left + toRect.width / 2 - containerRect.left + container.scrollLeft;
      const y2 = toRect.top + toRect.height / 2 - containerRect.top + container.scrollTop;

      const minX = Math.min(x1, x2) - 10;
      const minY = Math.min(y1, y2) - 10;
      const width = Math.abs(x2 - x1) + 20;
      const height = Math.abs(y2 - y1) + 20;

      svg.style.left = minX + 'px';
      svg.style.top = minY + 'px';
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      // Define arrowhead marker
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead-' + traceArrows.length);
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '7');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3.5');
      marker.setAttribute('orient', 'auto');

      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
      polygon.setAttribute('fill', type === 'precedent' ? '#2196F3' : '#4CAF50');
      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);

      // Draw line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1 - minX);
      line.setAttribute('y1', y1 - minY);
      line.setAttribute('x2', x2 - minX);
      line.setAttribute('y2', y2 - minY);
      line.setAttribute('stroke', type === 'precedent' ? '#2196F3' : '#4CAF50');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('marker-end', 'url(#arrowhead-' + traceArrows.length + ')');
      svg.appendChild(line);

      // Draw circles at endpoints
      const circle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle1.setAttribute('cx', x1 - minX);
      circle1.setAttribute('cy', y1 - minY);
      circle1.setAttribute('r', '4');
      circle1.setAttribute('fill', type === 'precedent' ? '#2196F3' : '#4CAF50');
      svg.appendChild(circle1);

      container.style.position = 'relative';
      container.appendChild(svg);
      traceArrows.push(svg);
    }

    function clearTraceArrows() {
      traceArrows.forEach(arrow => arrow.remove());
      traceArrows = [];
    }

    function toggleShowFormulas() {
      showFormulasMode = !showFormulasMode;

      document.querySelectorAll('.spreadsheet td').forEach(cell => {
        if (cell.id) {
          const value = sheets[currentSheet][cell.id];
          if (showFormulasMode && value && value.toString().startsWith('=')) {
            cell.textContent = value;
            cell.classList.add('show-formula');
          } else {
            cell.textContent = getCellDisplayValue(cell.id);
            cell.classList.remove('show-formula');
          }
        }
      });

      showToast(showFormulasMode ? 'Showing formulas' : 'Showing values', 'info');
    }

    function evaluateFormula() {
      if (!selectedCell) {
        showToast('Please select a cell first', 'error');
        return;
      }

      const formula = getCellValue(selectedCell);
      if (!formula || !formula.toString().startsWith('=')) {
        showToast('Selected cell has no formula', 'info');
        return;
      }

      // Show evaluation steps
      const steps = [];
      let currentFormula = formula.substring(1);
      steps.push('Original: ' + formula);

      // Replace cell references with their values
      const refs = currentFormula.match(/[A-Z]+[0-9]+/gi) || [];
      refs.forEach(ref => {
        const val = getCellDisplayValue(ref);
        currentFormula = currentFormula.replace(new RegExp(ref, 'gi'), '(' + val + ')');
      });
      steps.push('After substitution: =' + currentFormula);

      try {
        const result = eval(currentFormula);
        steps.push('Result: ' + result);
      } catch (e) {
        steps.push('Error: ' + e.message);
      }

      showToast('Formula evaluated - check console for steps', 'info');
      console.log('Formula Evaluation Steps:', steps);
    }

    function checkErrors() {
      const errors = [];
      const sheet = sheets[currentSheet];

      Object.entries(sheet).forEach(([cellId, value]) => {
        if (value && value.toString().startsWith('=')) {
          const display = getCellDisplayValue(cellId);
          if (display && (display.startsWith('#') || display === 'NaN' || display === 'Infinity')) {
            errors.push({ cell: cellId, formula: value, error: display });
          }
        }
      });

      if (errors.length === 0) {
        showToast('No formula errors found', 'success');
      } else {
        showToast('Found ' + errors.length + ' formula error(s). Check console for details.', 'warning');
        console.log('Formula errors:', errors);
      }
    }

    function addWatch() {
      if (!selectedCell) {
        showToast('Please select a cell first', 'error');
        return;
      }

      if (!watchedCells.includes(selectedCell)) {
        watchedCells.push(selectedCell);
        updateWatchWindow();
        showToast('Added ' + selectedCell + ' to Watch Window', 'success');
      }
    }

    function removeWatch(cell) {
      watchedCells = watchedCells.filter(c => c !== cell);
      updateWatchWindow();
    }

    function updateWatchWindow() {
      const container = document.getElementById('watchWindow');
      if (!container) return;

      if (watchedCells.length === 0) {
        container.innerHTML = '<p style="color: #666; font-style: italic;">No cells being watched. Select a cell and click "Add Watch".</p>';
        return;
      }

      container.innerHTML = `
        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
          <tr style="background: #f5f5f5;">
            <th style="padding: 4px; text-align: left; border: 1px solid #ddd;">Cell</th>
            <th style="padding: 4px; text-align: left; border: 1px solid #ddd;">Value</th>
            <th style="padding: 4px; text-align: left; border: 1px solid #ddd;">Formula</th>
            <th style="padding: 4px; border: 1px solid #ddd;"></th>
          </tr>
          ${watchedCells.map(cell => {
            const formula = getCellValue(cell) || '';
            const value = getCellDisplayValue(cell);
            return `
              <tr>
                <td style="padding: 4px; border: 1px solid #ddd;">${cell}</td>
                <td style="padding: 4px; border: 1px solid #ddd;">${value}</td>
                <td style="padding: 4px; border: 1px solid #ddd;">${formula.toString().startsWith('=') ? formula : '-'}</td>
                <td style="padding: 4px; border: 1px solid #ddd; text-align: center;">
                  <button onclick="removeWatch('${cell}')" style="padding: 2px 6px; cursor: pointer;">√ó</button>
                </td>
              </tr>
            `;
          }).join('')}
        </table>
      `;
    }

    // ==================== FORM CONTROLS ====================
    let formControls = [];
    let selectedFormControlType = 'button';
    let formControlIdCounter = 0;

    function showFormControls() {
      document.getElementById('formCtrlPosition').value = selectedCell || 'E2';
      document.getElementById('formCtrlLabel').value = '';
      document.getElementById('formCtrlCellLink').value = '';
      selectFormControlType('button');
      document.getElementById('formControlsModal').classList.add('active');
    }

    function hideFormControls() {
      document.getElementById('formControlsModal').classList.remove('active');
    }

    function selectFormControlType(type) {
      selectedFormControlType = type;
      document.querySelectorAll('.form-ctrl-type').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });

      // Show/hide relevant options
      const rangeGroup = document.getElementById('formCtrlRangeGroup');
      const minMaxGroup = document.getElementById('formCtrlMinMaxGroup');

      rangeGroup.style.display = ['dropdown', 'radio'].includes(type) ? 'block' : 'none';
      minMaxGroup.style.display = ['spinner', 'slider'].includes(type) ? 'block' : 'none';

      // Set default labels
      const labelInput = document.getElementById('formCtrlLabel');
      if (!labelInput.value) {
        const defaults = {
          button: 'Click Me',
          checkbox: 'Option',
          dropdown: '',
          spinner: '',
          slider: '',
          radio: 'Choice'
        };
        labelInput.value = defaults[type] || '';
      }
    }

    function insertFormControl() {
      const type = selectedFormControlType;
      const label = document.getElementById('formCtrlLabel').value || 'Control';
      const cellLink = document.getElementById('formCtrlCellLink').value.toUpperCase();
      const position = document.getElementById('formCtrlPosition').value.toUpperCase();
      const inputRange = document.getElementById('formCtrlInputRange').value.toUpperCase();
      const min = parseInt(document.getElementById('formCtrlMin').value) || 0;
      const max = parseInt(document.getElementById('formCtrlMax').value) || 100;
      const step = parseInt(document.getElementById('formCtrlStep').value) || 1;

      if (!position) {
        showToast('Please specify a position cell', 'error');
        return;
      }

      const control = {
        id: 'ctrl-' + (++formControlIdCounter),
        type: type,
        label: label,
        cellLink: cellLink,
        position: position,
        inputRange: inputRange,
        min: min,
        max: max,
        step: step,
        value: type === 'checkbox' ? false : (type === 'spinner' || type === 'slider' ? min : 0)
      };

      formControls.push(control);
      renderFormControl(control);
      hideFormControls();
      showToast(`${type} control inserted`, 'success');
    }

    function renderFormControl(control) {
      const cell = document.getElementById(control.position);
      if (!cell) return;

      const container = document.createElement('div');
      container.id = control.id;
      container.className = 'form-control-element';
      container.style.cssText = 'position: absolute; z-index: 100; background: white; border: 1px solid #ccc; border-radius: 4px; padding: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);';

      const rect = cell.getBoundingClientRect();
      const tableRect = document.getElementById('spreadsheet').getBoundingClientRect();

      switch (control.type) {
        case 'button':
          container.innerHTML = `
            <button style="padding: 4px 12px; cursor: pointer; background: #1a73e8; color: white; border: none; border-radius: 3px;"
                    onclick="handleFormControlClick('${control.id}')">${control.label}</button>
          `;
          break;

        case 'checkbox':
          container.innerHTML = `
            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
              <input type="checkbox" ${control.value ? 'checked' : ''} onchange="updateFormControl('${control.id}', this.checked)">
              <span>${control.label}</span>
            </label>
          `;
          break;

        case 'dropdown':
          const options = getDropdownOptions(control.inputRange);
          container.innerHTML = `
            <select style="padding: 4px; min-width: 100px;" onchange="updateFormControl('${control.id}', this.selectedIndex + 1)">
              ${options.map((opt, i) => `<option value="${i + 1}" ${control.value === i + 1 ? 'selected' : ''}>${opt}</option>`).join('')}
            </select>
          `;
          break;

        case 'spinner':
          container.innerHTML = `
            <div style="display: flex; align-items: center; gap: 4px;">
              <button onclick="spinnerDecrement('${control.id}')" style="padding: 2px 8px; cursor: pointer;">‚àí</button>
              <input type="number" value="${control.value}" min="${control.min}" max="${control.max}" step="${control.step}"
                     style="width: 60px; text-align: center; padding: 2px;"
                     onchange="updateFormControl('${control.id}', parseInt(this.value))">
              <button onclick="spinnerIncrement('${control.id}')" style="padding: 2px 8px; cursor: pointer;">+</button>
            </div>
          `;
          break;

        case 'slider':
          container.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 11px;">${control.min}</span>
              <input type="range" min="${control.min}" max="${control.max}" step="${control.step}" value="${control.value}"
                     style="width: 100px;" onchange="updateFormControl('${control.id}', parseInt(this.value))">
              <span style="font-size: 11px;">${control.max}</span>
              <span style="font-size: 11px; min-width: 30px;" id="${control.id}-value">${control.value}</span>
            </div>
          `;
          break;

        case 'radio':
          const radioOptions = getDropdownOptions(control.inputRange);
          container.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 2px;">
              ${radioOptions.map((opt, i) => `
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 12px;">
                  <input type="radio" name="${control.id}" value="${i + 1}" ${control.value === i + 1 ? 'checked' : ''}
                         onchange="updateFormControl('${control.id}', ${i + 1})">
                  <span>${opt}</span>
                </label>
              `).join('')}
            </div>
          `;
          break;
      }

      // Position relative to spreadsheet
      const spreadsheet = document.getElementById('spreadsheet');
      spreadsheet.style.position = 'relative';

      container.style.left = (cell.offsetLeft + 2) + 'px';
      container.style.top = (cell.offsetTop + 2) + 'px';

      // Remove existing control with same ID
      const existing = document.getElementById(control.id);
      if (existing) existing.remove();

      spreadsheet.appendChild(container);
    }

    function getDropdownOptions(range) {
      if (!range) return ['Option 1', 'Option 2', 'Option 3'];

      const values = [];
      const parts = range.split(':');
      if (parts.length !== 2) return ['Option 1', 'Option 2', 'Option 3'];

      const startCol = parts[0].replace(/[0-9]/g, '');
      const startRow = parseInt(parts[0].replace(/[A-Z]/gi, ''));
      const endRow = parseInt(parts[1].replace(/[A-Z]/gi, ''));

      for (let r = startRow; r <= endRow; r++) {
        const val = getCellValue(startCol + r);
        if (val) values.push(val);
      }

      return values.length > 0 ? values : ['Option 1', 'Option 2', 'Option 3'];
    }

    function updateFormControl(controlId, value) {
      const control = formControls.find(c => c.id === controlId);
      if (!control) return;

      control.value = value;

      // Update linked cell
      if (control.cellLink) {
        setCellValue(control.cellLink, value);
      }

      // Update display for slider
      if (control.type === 'slider') {
        const valueSpan = document.getElementById(controlId + '-value');
        if (valueSpan) valueSpan.textContent = value;
      }

      recalculateAll();
    }

    function handleFormControlClick(controlId) {
      const control = formControls.find(c => c.id === controlId);
      if (!control) return;

      // For buttons, increment the linked cell or show a message
      if (control.cellLink) {
        const currentVal = parseInt(getCellValue(control.cellLink)) || 0;
        setCellValue(control.cellLink, currentVal + 1);
        recalculateAll();
        showToast(`Button clicked (${control.cellLink} = ${currentVal + 1})`, 'info');
      } else {
        showToast('Button clicked!', 'info');
      }
    }

    function spinnerIncrement(controlId) {
      const control = formControls.find(c => c.id === controlId);
      if (!control) return;

      const newVal = Math.min(control.max, control.value + control.step);
      updateFormControl(controlId, newVal);

      // Update input display
      const input = document.querySelector(`#${controlId} input[type="number"]`);
      if (input) input.value = newVal;
    }

    function spinnerDecrement(controlId) {
      const control = formControls.find(c => c.id === controlId);
      if (!control) return;

      const newVal = Math.max(control.min, control.value - control.step);
      updateFormControl(controlId, newVal);

      // Update input display
      const input = document.querySelector(`#${controlId} input[type="number"]`);
      if (input) input.value = newVal;
    }

    // Re-render form controls when spreadsheet scrolls or updates
    function rerenderFormControls() {
      formControls.forEach(control => renderFormControl(control));
    }

    // Initialize
    initSpreadsheet();
    renderSheetTabs();

    // Dark Mode
    let darkModeEnabled = localStorage.getItem('ninjacalc-darkmode') === 'true';

    function toggleDarkMode() {
      darkModeEnabled = !darkModeEnabled;
      applyDarkMode();
      localStorage.setItem('ninjacalc-darkmode', darkModeEnabled);
    }

    function applyDarkMode() {
      const btn = document.getElementById('darkModeBtn');
      if (darkModeEnabled) {
        document.body.classList.add('dark-mode');
        btn.classList.add('active');
        btn.innerHTML = '‚òÄÔ∏è Light Mode';
      } else {
        document.body.classList.remove('dark-mode');
        btn.classList.remove('active');
        btn.innerHTML = 'üåô Dark Mode';
      }
    }

    // Apply saved dark mode preference on load
    if (darkModeEnabled) {
      applyDarkMode();
    }

    // ==================== CASCADING DROPDOWNS ====================
    let cascadingLists = [];

    function showCascadingDropdowns() {
      document.getElementById('cascadePrimaryCell').value = selectedCell || 'A1';
      document.getElementById('cascadeDependentCell').value = '';
      document.getElementById('cascadePrimaryItems').value = '';
      document.getElementById('cascadeDefinitions').innerHTML = '';
      updateExistingCascadingLists();
      document.getElementById('cascadingDropdownsModal').classList.add('active');
    }

    function hideCascadingDropdowns() {
      document.getElementById('cascadingDropdownsModal').classList.remove('active');
    }

    // Update definitions when primary items change
    document.getElementById('cascadePrimaryItems')?.addEventListener('input', function() {
      const items = this.value.split(',').map(s => s.trim()).filter(s => s);
      const container = document.getElementById('cascadeDefinitions');

      if (items.length === 0) {
        container.innerHTML = '<div style="color: #999; padding: 0.5rem;">Enter primary items above to define dependent lists</div>';
        return;
      }

      let html = '';
      items.forEach(item => {
        html += `
          <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; padding: 0.5rem; background: white; border: 1px solid #ddd; border-radius: 4px;">
            <label style="min-width: 100px; font-weight: 500;">${item}:</label>
            <input type="text" class="form-control cascade-dependent-input" data-primary="${item}" placeholder="e.g., Option1, Option2, Option3" style="flex: 1;">
          </div>
        `;
      });

      container.innerHTML = html;
    });

    function previewCascadingDropdowns() {
      const primaryCell = document.getElementById('cascadePrimaryCell').value.toUpperCase();
      const primaryItems = document.getElementById('cascadePrimaryItems').value.split(',').map(s => s.trim()).filter(s => s);

      if (!primaryCell || primaryItems.length === 0) {
        showToast('Please fill in primary dropdown details', 'error');
        return;
      }

      // Show preview of what will be created
      let preview = `Primary dropdown at ${primaryCell}: ${primaryItems.join(', ')}`;

      const dependentInputs = document.querySelectorAll('.cascade-dependent-input');
      dependentInputs.forEach(input => {
        const primary = input.dataset.primary;
        const values = input.value;
        if (values) {
          preview += `\n  When "${primary}" selected: ${values}`;
        }
      });

      showToast('Cascade preview ready - check console', 'info');
      console.log('Cascade Preview:', preview);
    }

    function applyCascadingDropdowns() {
      const primaryCell = document.getElementById('cascadePrimaryCell').value.toUpperCase();
      const dependentCell = document.getElementById('cascadeDependentCell').value.toUpperCase();
      const primaryItems = document.getElementById('cascadePrimaryItems').value.split(',').map(s => s.trim()).filter(s => s);

      if (!primaryCell || !dependentCell || primaryItems.length === 0) {
        showToast('Please fill in all required fields', 'error');
        return;
      }

      // Collect dependent definitions
      const dependentLists = {};
      document.querySelectorAll('.cascade-dependent-input').forEach(input => {
        const primary = input.dataset.primary;
        const values = input.value.split(',').map(s => s.trim()).filter(s => s);
        if (values.length > 0) {
          dependentLists[primary] = values;
        }
      });

      // Create cascading list configuration
      const cascadeConfig = {
        id: Date.now(),
        primaryCell: primaryCell,
        dependentCell: dependentCell,
        primaryItems: primaryItems,
        dependentLists: dependentLists
      };

      cascadingLists.push(cascadeConfig);

      // Create primary dropdown in cell
      createCellDropdown(primaryCell, primaryItems, (value) => {
        // Update dependent dropdown based on selection
        const dependentItems = dependentLists[value] || [];
        createCellDropdown(dependentCell, dependentItems);
      });

      // Initialize dependent dropdown with first option's values
      if (primaryItems.length > 0 && dependentLists[primaryItems[0]]) {
        createCellDropdown(dependentCell, dependentLists[primaryItems[0]]);
      }

      updateExistingCascadingLists();
      hideCascadingDropdowns();
      showToast('Cascading dropdowns created', 'success');
    }

    function createCellDropdown(cellRef, items, onChange) {
      // Store dropdown configuration for the cell
      if (!formatting[cellRef]) formatting[cellRef] = {};
      formatting[cellRef].dropdown = items;
      formatting[cellRef].dropdownOnChange = onChange;

      // Set first value if empty
      if (!data[cellRef] && items.length > 0) {
        data[cellRef] = items[0];
      }

      renderSpreadsheet();
    }

    function updateExistingCascadingLists() {
      const container = document.getElementById('existingCascadingLists');

      if (cascadingLists.length === 0) {
        container.innerHTML = '<span style="color: #999;">No cascading lists defined yet</span>';
        return;
      }

      let html = '';
      cascadingLists.forEach((config, index) => {
        html += `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0; border-bottom: 1px solid #eee;">
            <span>${config.primaryCell} ‚Üí ${config.dependentCell} (${config.primaryItems.length} options)</span>
            <button onclick="removeCascadingList(${index})" style="border: none; background: none; color: #d93025; cursor: pointer;">√ó</button>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    function removeCascadingList(index) {
      const config = cascadingLists[index];

      // Remove dropdown formatting from cells
      if (formatting[config.primaryCell]) {
        delete formatting[config.primaryCell].dropdown;
        delete formatting[config.primaryCell].dropdownOnChange;
      }
      if (formatting[config.dependentCell]) {
        delete formatting[config.dependentCell].dropdown;
        delete formatting[config.dependentCell].dropdownOnChange;
      }

      cascadingLists.splice(index, 1);
      updateExistingCascadingLists();
      renderSpreadsheet();
      showToast('Cascading list removed', 'info');
    }

    // ==================== QUICK ANALYSIS ====================
    function showQuickAnalysis() {
      // Update selection info
      updateQASelectionInfo();
      document.getElementById('quickAnalysisModal').classList.add('active');
    }

    function hideQuickAnalysis() {
      document.getElementById('quickAnalysisModal').classList.remove('active');
    }

    function switchQATab(tab) {
      document.querySelectorAll('.qa-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.qa-panel').forEach(p => p.style.display = 'none');

      document.querySelector(`.qa-tab[data-tab="${tab}"]`).classList.add('active');
      document.getElementById(`qa-${tab}`).style.display = 'block';
    }

    function updateQASelectionInfo() {
      const info = document.getElementById('qaSelectionInfo');
      if (selectedRange.length > 0) {
        info.textContent = `${selectedRange.length} cells selected (${selectedRange[0]} to ${selectedRange[selectedRange.length - 1]})`;
      } else if (selectedCell) {
        info.textContent = `Cell ${selectedCell} selected`;
      } else {
        info.textContent = 'Select cells to analyze';
      }
    }

    function applyQuickFormat(formatType) {
      if (!selectedRange.length && !selectedCell) {
        showToast('Please select cells first', 'error');
        return;
      }

      const cells = selectedRange.length > 0 ? selectedRange : [selectedCell];

      // Get numeric values for calculations
      const values = cells.map(cell => parseFloat(data[cell]) || 0).filter(v => !isNaN(v));
      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min || 1;

      cells.forEach(cellRef => {
        if (!formatting[cellRef]) formatting[cellRef] = {};
        const val = parseFloat(data[cellRef]) || 0;
        const normalized = (val - min) / range;

        switch (formatType) {
          case 'data-bars':
            const barWidth = Math.round(normalized * 100);
            formatting[cellRef].background = `linear-gradient(90deg, #5b9bd5 ${barWidth}%, transparent ${barWidth}%)`;
            break;
          case 'color-scale':
            // Red to Yellow to Green
            let r, g, b;
            if (normalized < 0.5) {
              r = 248; g = Math.round(105 + normalized * 2 * 130); b = 107;
            } else {
              r = Math.round(255 - (normalized - 0.5) * 2 * 156); g = 190; b = 123;
            }
            formatting[cellRef].background = `rgb(${r}, ${g}, ${b})`;
            break;
          case 'icon-set':
            let icon = '';
            if (normalized > 0.66) icon = '‚¨ÜÔ∏è';
            else if (normalized > 0.33) icon = '‚û°Ô∏è';
            else icon = '‚¨áÔ∏è';
            data[cellRef] = icon + ' ' + (data[cellRef] || '');
            break;
          case 'greater-than':
            const avg = values.reduce((a, b) => a + b, 0) / values.length;
            if (val > avg) {
              formatting[cellRef].background = '#ffc7ce';
              formatting[cellRef].color = '#9c0006';
            }
            break;
          case 'top-10':
            const sorted = [...values].sort((a, b) => b - a);
            const top10Threshold = sorted[Math.floor(sorted.length * 0.1)] || sorted[0];
            if (val >= top10Threshold) {
              formatting[cellRef].background = '#c6efce';
              formatting[cellRef].color = '#006100';
            }
            break;
        }
      });

      renderSpreadsheet();
      hideQuickAnalysis();
      showToast(`Applied ${formatType} formatting`, 'success');
    }

    function insertQuickChart(chartType) {
      // Use existing chart functionality
      document.getElementById('chartType').value = chartType === 'bar' ? 'bar' : chartType;
      showChartModal();
      hideQuickAnalysis();
    }

    function insertQuickTotal(totalType) {
      if (!selectedRange.length) {
        showToast('Please select a range of cells', 'error');
        return;
      }

      // Find the cell below the selection to insert total
      const lastCell = selectedRange[selectedRange.length - 1];
      const col = lastCell.match(/[A-Z]+/)[0];
      const row = parseInt(lastCell.match(/\d+/)[0]) + 1;
      const totalCell = col + row;

      const rangeStr = `${selectedRange[0]}:${selectedRange[selectedRange.length - 1]}`;
      let formula = '';

      switch (totalType) {
        case 'sum': formula = `=SUM(${rangeStr})`; break;
        case 'average': formula = `=AVERAGE(${rangeStr})`; break;
        case 'count': formula = `=COUNT(${rangeStr})`; break;
        case 'max': formula = `=MAX(${rangeStr})`; break;
        case 'min': formula = `=MIN(${rangeStr})`; break;
      }

      formulas[totalCell] = formula;
      recalculateAll();
      renderSpreadsheet();
      hideQuickAnalysis();
      showToast(`Inserted ${totalType.toUpperCase()} at ${totalCell}`, 'success');
    }

    function insertQuickTable(tableType) {
      switch (tableType) {
        case 'table':
          showFormatTable();
          break;
        case 'pivot':
          showPivotModal();
          break;
        case 'slicer':
          showSlicers();
          break;
      }
      hideQuickAnalysis();
    }

    function insertQuickSparkline(sparkType) {
      document.getElementById('sparklineType').value = sparkType === 'winloss' ? 'column' : sparkType;
      showSparklinesModal();
      hideQuickAnalysis();
    }

    // Add keyboard shortcut for Quick Analysis (Ctrl+Q)
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'q') {
        e.preventDefault();
        showQuickAnalysis();
      }
    });

    // ========== Watch Window ==========
    // watchedCells defined above in Formula Auditing section
    let watchWindowVisible = false;

    function toggleWatchWindow() {
      watchWindowVisible = !watchWindowVisible;
      const window = document.getElementById('watchWindow');
      window.classList.toggle('visible', watchWindowVisible);
      if (watchWindowVisible) {
        updateWatchWindow();
      }
    }

    function addCellToWatch() {
      const cellRef = document.getElementById('cellRef').value;
      if (!cellRef) {
        showToast('Please select a cell first', 'error');
        return;
      }

      if (watchedCells.includes(cellRef)) {
        showToast(`${cellRef} is already being watched`, 'warning');
        return;
      }

      watchedCells.push(cellRef);
      watchWindowVisible = true;
      document.getElementById('watchWindow').classList.add('visible');
      updateWatchWindow();
      showToast(`Added ${cellRef} to Watch Window`, 'success');
    }

    function removeCellFromWatch(cellRef) {
      watchedCells = watchedCells.filter(c => c !== cellRef);
      updateWatchWindow();
      showToast(`Removed ${cellRef} from Watch Window`, 'success');
    }

    function updateWatchWindow() {
      const tbody = document.getElementById('watchTableBody');
      const emptyMsg = document.getElementById('watchEmpty');

      if (watchedCells.length === 0) {
        tbody.innerHTML = '';
        emptyMsg.style.display = 'block';
        return;
      }

      emptyMsg.style.display = 'none';

      tbody.innerHTML = watchedCells.map(cellRef => {
        const value = data[cellRef] || '';
        const formula = formulas[cellRef] || '';
        return `
          <tr>
            <td><span class="watch-cell-ref" onclick="navigateToCell('${cellRef}')">${cellRef}</span></td>
            <td class="watch-value">${value}</td>
            <td class="watch-formula">${formula || '(no formula)'}</td>
            <td><button class="watch-remove" onclick="removeCellFromWatch('${cellRef}')" title="Remove">&times;</button></td>
          </tr>
        `;
      }).join('');
    }

    function navigateToCell(cellRef) {
      const col = cellRef.match(/[A-Z]+/)[0];
      const row = parseInt(cellRef.match(/\d+/)[0]);

      // Set current cell
      currentCell = cellRef;
      document.getElementById('cellRef').value = cellRef;
      document.getElementById('formulaInput').value = formulas[cellRef] || data[cellRef] || '';

      // Find the cell input and focus it
      const cellElement = document.querySelector(`[data-cell="${cellRef}"]`);
      if (cellElement) {
        cellElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        cellElement.focus();
      }

      renderSpreadsheet();
    }

    // Make watch window draggable
    (function() {
      const watchWindow = document.getElementById('watchWindow');
      const header = document.getElementById('watchWindowHeader');
      let isDragging = false;
      let currentX, currentY, initialX, initialY;

      header.addEventListener('mousedown', (e) => {
        if (e.target === header || e.target.tagName === 'H4') {
          isDragging = true;
          initialX = e.clientX - watchWindow.offsetLeft;
          initialY = e.clientY - watchWindow.offsetTop;
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          watchWindow.style.left = currentX + 'px';
          watchWindow.style.right = 'auto';
          watchWindow.style.top = currentY + 'px';
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    })();

    // Hook into recalculateAll to update watch window
    const originalRecalculateAll = recalculateAll;
    recalculateAll = function() {
      originalRecalculateAll();
      if (watchWindowVisible) {
        updateWatchWindow();
      }
    };

    // ========== Keyboard Shortcuts ==========
    function showKeyboardShortcuts() {
      document.getElementById('shortcutsModal').style.display = 'flex';
    }

    function hideKeyboardShortcuts() {
      document.getElementById('shortcutsModal').style.display = 'none';
    }

    // F1 key to show shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'F1') {
        e.preventDefault();
        showKeyboardShortcuts();
      }
    });

    // Click outside modal to close
    document.getElementById('shortcutsModal').addEventListener('click', (e) => {
      if (e.target.id === 'shortcutsModal') {
        hideKeyboardShortcuts();
      }
    });

    // ==================== CLIPBOARD & PASTE SPECIAL ====================
    let clipboardData = {
      cells: {},
      formulas: {},
      formats: {},
      comments: {},
      validation: {},
      startCell: null,
      endCell: null,
      isCut: false
    };

    function copyCells() {
      if (!selectedRange || selectedRange.length === 0) {
        if (selectedCell) {
          selectedRange = [selectedCell];
        } else {
          showToast('Select cells to copy', 'error');
          return;
        }
      }

      clipboardData = {
        cells: {},
        formulas: {},
        formats: {},
        comments: {},
        validation: {},
        startCell: selectedRange[0],
        endCell: selectedRange[selectedRange.length - 1],
        isCut: false
      };

      selectedRange.forEach(cellRef => {
        clipboardData.cells[cellRef] = data[cellRef] || '';
        clipboardData.formulas[cellRef] = formulas[cellRef] || '';
        clipboardData.formats[cellRef] = formatting[cellRef] ? {...formatting[cellRef]} : {};
        clipboardData.comments[cellRef] = cellComments[cellRef] || '';
        clipboardData.validation[cellRef] = dataValidation[cellRef] ? {...dataValidation[cellRef]} : null;
      });

      showToast(`Copied ${selectedRange.length} cell(s)`, 'success');
    }

    function cutCells() {
      copyCells();
      clipboardData.isCut = true;
      showToast(`Cut ${selectedRange.length} cell(s)`, 'success');
    }

    function pasteCells() {
      if (!clipboardData.startCell) {
        showToast('Nothing to paste', 'error');
        return;
      }

      const targetCell = selectedCell || 'A1';
      executePasteOperation('all', 'none', false, false);
      showToast('Pasted', 'success');
    }

    function showPasteSpecial() {
      if (!clipboardData.startCell) {
        showToast('Nothing to paste. Copy cells first.', 'error');
        return;
      }
      document.getElementById('pasteSpecialModal').style.display = 'flex';
    }

    function hidePasteSpecial() {
      document.getElementById('pasteSpecialModal').style.display = 'none';
    }

    function executePasteSpecial() {
      const pasteType = document.querySelector('input[name="pasteType"]:checked').value;
      const operation = document.querySelector('input[name="pasteOp"]:checked').value;
      const transpose = document.getElementById('pasteTranspose').checked;
      const skipBlanks = document.getElementById('pasteSkipBlanks').checked;

      executePasteOperation(pasteType, operation, transpose, skipBlanks);
      hidePasteSpecial();
      showToast('Paste special completed', 'success');
    }

    function executePasteOperation(pasteType, operation, transpose, skipBlanks) {
      if (!clipboardData.startCell) return;

      const targetCell = selectedCell || 'A1';
      const targetCol = targetCell.charCodeAt(0) - 65;
      const targetRow = parseInt(targetCell.slice(1));

      const startCol = clipboardData.startCell.charCodeAt(0) - 65;
      const startRow = parseInt(clipboardData.startCell.slice(1));

      Object.keys(clipboardData.cells).forEach(cellRef => {
        const srcCol = cellRef.charCodeAt(0) - 65;
        const srcRow = parseInt(cellRef.slice(1));

        let destCol, destRow;
        if (transpose) {
          destCol = targetCol + (srcRow - startRow);
          destRow = targetRow + (srcCol - startCol);
        } else {
          destCol = targetCol + (srcCol - startCol);
          destRow = targetRow + (srcRow - startRow);
        }

        if (destCol < 0 || destCol > 25 || destRow < 1 || destRow > ROWS) return;

        const destRef = String.fromCharCode(65 + destCol) + destRow;
        const srcValue = clipboardData.cells[cellRef];

        if (skipBlanks && (srcValue === '' || srcValue === null || srcValue === undefined)) {
          return;
        }

        // Apply based on paste type
        if (pasteType === 'all' || pasteType === 'values') {
          let newValue = srcValue;

          // Apply operation
          if (operation !== 'none') {
            const existingVal = parseFloat(data[destRef]) || 0;
            const pasteVal = parseFloat(srcValue) || 0;

            switch (operation) {
              case 'add': newValue = existingVal + pasteVal; break;
              case 'subtract': newValue = existingVal - pasteVal; break;
              case 'multiply': newValue = existingVal * pasteVal; break;
              case 'divide': newValue = pasteVal !== 0 ? existingVal / pasteVal : '#DIV/0!'; break;
            }
          }

          data[destRef] = newValue;
          const cell = document.getElementById(destRef);
          if (cell) cell.value = newValue;
        }

        if (pasteType === 'all' || pasteType === 'formulas') {
          if (clipboardData.formulas[cellRef]) {
            // Adjust formula references
            formulas[destRef] = adjustFormulaReferences(
              clipboardData.formulas[cellRef],
              destCol - srcCol,
              destRow - srcRow
            );
          }
        }

        if (pasteType === 'all' || pasteType === 'formats') {
          if (clipboardData.formats[cellRef] && Object.keys(clipboardData.formats[cellRef]).length > 0) {
            formatting[destRef] = {...clipboardData.formats[cellRef]};
            applyFormattingToCell(destRef);
          }
        }

        if (pasteType === 'all' || pasteType === 'comments') {
          if (clipboardData.comments[cellRef]) {
            cellComments[destRef] = clipboardData.comments[cellRef];
          }
        }

        if (pasteType === 'all' || pasteType === 'validation') {
          if (clipboardData.validation[cellRef]) {
            dataValidation[destRef] = {...clipboardData.validation[cellRef]};
          }
        }
      });

      // If it was a cut operation, clear the source cells
      if (clipboardData.isCut) {
        Object.keys(clipboardData.cells).forEach(cellRef => {
          data[cellRef] = '';
          formulas[cellRef] = '';
          const cell = document.getElementById(cellRef);
          if (cell) cell.value = '';
        });
        clipboardData.isCut = false;
      }

      recalculateAll();
    }

    function adjustFormulaReferences(formula, colOffset, rowOffset) {
      // Simple formula reference adjustment (A1, B2, etc.)
      return formula.replace(/([A-Z])(\d+)/g, (match, col, row) => {
        const newCol = String.fromCharCode(col.charCodeAt(0) + colOffset);
        const newRow = parseInt(row) + rowOffset;
        if (newCol >= 'A' && newCol <= 'Z' && newRow >= 1 && newRow <= ROWS) {
          return newCol + newRow;
        }
        return match; // Keep original if out of bounds
      });
    }

    function applyFormattingToCell(cellRef) {
      const cell = document.getElementById(cellRef);
      if (!cell || !formatting[cellRef]) return;

      const fmt = formatting[cellRef];
      if (fmt.bold) cell.style.fontWeight = 'bold';
      if (fmt.italic) cell.style.fontStyle = 'italic';
      if (fmt.underline) cell.style.textDecoration = 'underline';
      if (fmt.color) cell.style.color = fmt.color;
      if (fmt.background) cell.style.backgroundColor = fmt.background;
      if (fmt.textAlign) cell.style.textAlign = fmt.textAlign;
    }

    // ==================== INSERT HYPERLINK ====================
    let cellHyperlinks = {};

    function showInsertHyperlink() {
      if (!selectedCell) {
        showToast('Select a cell first', 'error');
        return;
      }

      // Pre-fill with existing hyperlink if any
      const existing = cellHyperlinks[selectedCell];
      if (existing) {
        document.getElementById('hyperlinkType').value = existing.type || 'url';
        document.getElementById('hyperlinkUrl').value = existing.url || '';
        document.getElementById('hyperlinkCell').value = existing.cell || '';
        document.getElementById('hyperlinkEmail').value = existing.email || '';
        document.getElementById('hyperlinkSubject').value = existing.subject || '';
        document.getElementById('hyperlinkText').value = existing.text || '';
        document.getElementById('hyperlinkTooltip').value = existing.tooltip || '';
      } else {
        document.getElementById('hyperlinkType').value = 'url';
        document.getElementById('hyperlinkUrl').value = '';
        document.getElementById('hyperlinkCell').value = '';
        document.getElementById('hyperlinkEmail').value = '';
        document.getElementById('hyperlinkSubject').value = '';
        document.getElementById('hyperlinkText').value = data[selectedCell] || '';
        document.getElementById('hyperlinkTooltip').value = '';
      }

      updateHyperlinkOptions();
      document.getElementById('hyperlinkModal').style.display = 'flex';
    }

    function hideInsertHyperlink() {
      document.getElementById('hyperlinkModal').style.display = 'none';
    }

    function updateHyperlinkOptions() {
      const type = document.getElementById('hyperlinkType').value;
      document.getElementById('hyperlinkUrlGroup').style.display = type === 'url' ? 'block' : 'none';
      document.getElementById('hyperlinkCellGroup').style.display = type === 'cell' ? 'block' : 'none';
      document.getElementById('hyperlinkEmailGroup').style.display = type === 'email' ? 'block' : 'none';
    }

    function insertHyperlink() {
      if (!selectedCell) return;

      const type = document.getElementById('hyperlinkType').value;
      const text = document.getElementById('hyperlinkText').value || 'Link';
      const tooltip = document.getElementById('hyperlinkTooltip').value;

      let href = '';
      switch (type) {
        case 'url':
          href = document.getElementById('hyperlinkUrl').value;
          if (href && !href.match(/^https?:\/\//)) href = 'https://' + href;
          break;
        case 'cell':
          href = '#' + document.getElementById('hyperlinkCell').value.toUpperCase();
          break;
        case 'email':
          const email = document.getElementById('hyperlinkEmail').value;
          const subject = document.getElementById('hyperlinkSubject').value;
          href = 'mailto:' + email + (subject ? '?subject=' + encodeURIComponent(subject) : '');
          break;
      }

      if (!href) {
        showToast('Please enter a valid link address', 'error');
        return;
      }

      cellHyperlinks[selectedCell] = {
        type,
        url: document.getElementById('hyperlinkUrl').value,
        cell: document.getElementById('hyperlinkCell').value,
        email: document.getElementById('hyperlinkEmail').value,
        subject: document.getElementById('hyperlinkSubject').value,
        text,
        tooltip,
        href
      };

      // Update cell display
      data[selectedCell] = text;
      const cell = document.getElementById(selectedCell);
      if (cell) {
        cell.value = text;
        cell.style.color = '#0066cc';
        cell.style.textDecoration = 'underline';
        cell.style.cursor = 'pointer';
        cell.title = tooltip || href;

        // Add click handler
        cell.onclick = function(e) {
          if (e.ctrlKey || e.metaKey) {
            handleHyperlinkClick(selectedCell);
          }
        };
      }

      hideInsertHyperlink();
      showToast('Hyperlink inserted (Ctrl+Click to follow)', 'success');
    }

    function handleHyperlinkClick(cellRef) {
      const link = cellHyperlinks[cellRef];
      if (!link) return;

      if (link.type === 'cell') {
        const targetCell = link.cell.replace('#', '').toUpperCase();
        selectCell(targetCell);
        showToast(`Navigated to ${targetCell}`, 'info');
      } else {
        window.open(link.href, '_blank');
      }
    }

    function removeHyperlink() {
      if (!selectedCell) return;

      if (cellHyperlinks[selectedCell]) {
        delete cellHyperlinks[selectedCell];

        const cell = document.getElementById(selectedCell);
        if (cell) {
          cell.style.color = '';
          cell.style.textDecoration = '';
          cell.style.cursor = '';
          cell.title = '';
          cell.onclick = null;
        }

        showToast('Hyperlink removed', 'success');
      }

      hideInsertHyperlink();
    }

    // ==================== FILL DOWN / FILL RIGHT ====================
    function fillDown() {
      if (!selectedRange || selectedRange.length < 2) {
        showToast('Select a range with at least 2 rows (source row at top)', 'error');
        return;
      }

      // Group by column
      const columns = {};
      selectedRange.forEach(ref => {
        const col = ref.charAt(0);
        if (!columns[col]) columns[col] = [];
        columns[col].push(ref);
      });

      // For each column, copy first cell down
      Object.keys(columns).forEach(col => {
        const cells = columns[col].sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
        if (cells.length < 2) return;

        const sourceRef = cells[0];
        const sourceValue = data[sourceRef] || '';
        const sourceFormula = formulas[sourceRef] || '';
        const sourceFormat = formatting[sourceRef] ? {...formatting[sourceRef]} : {};

        const sourceRow = parseInt(sourceRef.slice(1));

        for (let i = 1; i < cells.length; i++) {
          const targetRef = cells[i];
          const targetRow = parseInt(targetRef.slice(1));
          const rowOffset = targetRow - sourceRow;

          if (sourceFormula) {
            formulas[targetRef] = adjustFormulaReferences(sourceFormula, 0, rowOffset);
            const calculated = calculateFormula(formulas[targetRef]);
            data[targetRef] = calculated;
          } else {
            data[targetRef] = sourceValue;
          }

          if (Object.keys(sourceFormat).length > 0) {
            formatting[targetRef] = {...sourceFormat};
            applyFormattingToCell(targetRef);
          }

          const cell = document.getElementById(targetRef);
          if (cell) cell.value = data[targetRef];
        }
      });

      recalculateAll();
      showToast('Filled down', 'success');
    }

    function fillRight() {
      if (!selectedRange || selectedRange.length < 2) {
        showToast('Select a range with at least 2 columns (source column at left)', 'error');
        return;
      }

      // Group by row
      const rows = {};
      selectedRange.forEach(ref => {
        const row = ref.slice(1);
        if (!rows[row]) rows[row] = [];
        rows[row].push(ref);
      });

      // For each row, copy first cell right
      Object.keys(rows).forEach(row => {
        const cells = rows[row].sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));
        if (cells.length < 2) return;

        const sourceRef = cells[0];
        const sourceValue = data[sourceRef] || '';
        const sourceFormula = formulas[sourceRef] || '';
        const sourceFormat = formatting[sourceRef] ? {...formatting[sourceRef]} : {};

        const sourceCol = sourceRef.charCodeAt(0) - 65;

        for (let i = 1; i < cells.length; i++) {
          const targetRef = cells[i];
          const targetCol = targetRef.charCodeAt(0) - 65;
          const colOffset = targetCol - sourceCol;

          if (sourceFormula) {
            formulas[targetRef] = adjustFormulaReferences(sourceFormula, colOffset, 0);
            const calculated = calculateFormula(formulas[targetRef]);
            data[targetRef] = calculated;
          } else {
            data[targetRef] = sourceValue;
          }

          if (Object.keys(sourceFormat).length > 0) {
            formatting[targetRef] = {...sourceFormat};
            applyFormattingToCell(targetRef);
          }

          const cell = document.getElementById(targetRef);
          if (cell) cell.value = data[targetRef];
        }
      });

      recalculateAll();
      showToast('Filled right', 'success');
    }

    // Add keyboard shortcuts for clipboard operations
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !e.target.matches('input:not(.cell), textarea')) {
        e.preventDefault();
        copyCells();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'x' && !e.target.matches('input:not(.cell), textarea')) {
        e.preventDefault();
        cutCells();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !e.target.matches('input:not(.cell), textarea')) {
        e.preventDefault();
        pasteCells();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        fillDown();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.target.matches('input, textarea')) {
        e.preventDefault();
        fillRight();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        showInsertHyperlink();
      }
    });

    // ========== Recent Files ==========
    const RECENT_FILES_KEY = 'ninjacalc_recent';
    const MAX_RECENT_FILES = 10;

    function getRecentFiles() {
      try {
        return JSON.parse(localStorage.getItem(RECENT_FILES_KEY)) || [];
      } catch { return []; }
    }

    function addToRecentFiles(docId, name) {
      let recent = getRecentFiles();
      recent = recent.filter(f => f.id !== docId);
      recent.unshift({ id: docId, name: name, timestamp: Date.now() });
      recent = recent.slice(0, MAX_RECENT_FILES);
      localStorage.setItem(RECENT_FILES_KEY, JSON.stringify(recent));
      updateRecentFilesMenu();
    }

    function toggleRecentFiles(event) {
      event.stopPropagation();
      document.getElementById('recentFilesMenu').classList.toggle('show');
    }

    function updateRecentFilesMenu() {
      const menu = document.getElementById('recentFilesMenu');
      const recent = getRecentFiles();
      const docs = getSavedDocs();

      if (recent.length === 0) {
        menu.innerHTML = '<div class="submenu-empty">No recent files</div>';
        return;
      }

      menu.innerHTML = recent
        .filter(f => docs[f.id])
        .map(f => {
          const date = new Date(f.timestamp);
          return `<div class="submenu-item" onclick="openRecentFile('${f.id}')">
            <span>${f.name}</span>
            <span class="file-date">${date.toLocaleDateString()}</span>
          </div>`;
        }).join('');

      if (menu.innerHTML === '') {
        menu.innerHTML = '<div class="submenu-empty">No recent files</div>';
      }
    }

    function openRecentFile(docId) {
      const docs = getSavedDocs();
      if (docs[docId]) {
        loadSpreadsheetData(docs[docId]);
        document.getElementById('fileName').value = docs[docId].name;
        currentSpreadsheetId = docId;
        addToRecentFiles(docId, docs[docId].name);
        toggleFileMenu();
        showToast('Spreadsheet opened', 'success');
      } else {
        showToast('Spreadsheet not found', 'error');
      }
    }

    // Initialize recent files on load
    document.addEventListener('DOMContentLoaded', updateRecentFilesMenu);
    document.addEventListener('click', () => {
      document.getElementById('recentFilesMenu')?.classList.remove('show');
    });

    // ==================== FILL SERIES ====================
    function showFillSeries() {
      if (!selectedCell) {
        showToast('Select a starting cell first', 'error');
        return;
      }
      updateSeriesOptions();
      document.getElementById('fillSeriesModal').style.display = 'flex';
    }

    function hideFillSeries() {
      document.getElementById('fillSeriesModal').style.display = 'none';
    }

    function updateSeriesOptions() {
      const type = document.getElementById('seriesType').value;
      document.getElementById('linearOptions').style.display = (type === 'linear' || type === 'growth') ? 'block' : 'none';
      document.getElementById('dateOptions').style.display = type === 'date' ? 'block' : 'none';
    }

    function executeFillSeries() {
      if (!selectedCell) {
        showToast('No starting cell selected', 'error');
        return;
      }

      const type = document.getElementById('seriesType').value;
      const direction = document.querySelector('input[name="fillDirection"]:checked').value;
      const count = parseInt(document.getElementById('fillCount').value) || 10;
      const step = parseFloat(document.getElementById('seriesStep').value) || 1;
      const stopValue = document.getElementById('seriesStop').value ? parseFloat(document.getElementById('seriesStop').value) : null;

      const startCol = selectedCell.charCodeAt(0) - 65;
      const startRow = parseInt(selectedCell.slice(1));
      let startValue = parseFloat(data[selectedCell]) || 0;

      // For date series, try to parse as date
      let startDate = null;
      if (type === 'date') {
        startDate = new Date(data[selectedCell]);
        if (isNaN(startDate.getTime())) {
          startDate = new Date();
        }
      }

      let filledCount = 0;

      for (let i = 1; i <= count; i++) {
        let col, row;
        if (direction === 'down') {
          col = startCol;
          row = startRow + i;
        } else {
          col = startCol + i;
          row = startRow;
        }

        if (col > 25 || row > ROWS) break;

        let newValue;

        switch (type) {
          case 'linear':
            newValue = startValue + (step * i);
            if (stopValue !== null && newValue > stopValue) break;
            break;

          case 'growth':
            newValue = startValue * Math.pow(step, i);
            if (stopValue !== null && newValue > stopValue) break;
            break;

          case 'date':
            const dateUnit = document.getElementById('dateUnit').value;
            const newDate = new Date(startDate);

            switch (dateUnit) {
              case 'day':
                newDate.setDate(newDate.getDate() + i);
                break;
              case 'weekday':
                let daysToAdd = i;
                let currentDate = new Date(startDate);
                while (daysToAdd > 0) {
                  currentDate.setDate(currentDate.getDate() + 1);
                  if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6) {
                    daysToAdd--;
                  }
                }
                newDate.setTime(currentDate.getTime());
                break;
              case 'week':
                newDate.setDate(newDate.getDate() + (i * 7));
                break;
              case 'month':
                newDate.setMonth(newDate.getMonth() + i);
                break;
              case 'year':
                newDate.setFullYear(newDate.getFullYear() + i);
                break;
            }
            newValue = newDate.toLocaleDateString();
            break;

          case 'autofill':
            // Pattern detection - try to continue the pattern
            const prevVal = data[selectedCell] || '';
            const match = prevVal.match(/^(.*?)(\d+)(.*)$/);
            if (match) {
              const prefix = match[1];
              const num = parseInt(match[2]) + i;
              const suffix = match[3];
              newValue = prefix + num + suffix;
            } else {
              newValue = startValue + i;
            }
            break;
        }

        if (newValue === undefined) break;

        const cellRef = String.fromCharCode(65 + col) + row;
        data[cellRef] = newValue;

        const cell = document.getElementById(cellRef);
        if (cell) cell.value = newValue;

        filledCount++;
      }

      hideFillSeries();
      showToast(`Filled ${filledCount} cells`, 'success');
    }

    // ==================== ACCESSIBILITY CHECKER ====================
    function showAccessibilityChecker() {
      document.getElementById('accessibilityModal').classList.add('active');
      clearAccessibilityResults();
    }

    function hideAccessibilityChecker() {
      document.getElementById('accessibilityModal').classList.remove('active');
    }

    function clearAccessibilityResults() {
      document.getElementById('accessibilityErrors').style.display = 'none';
      document.getElementById('accessibilityWarnings').style.display = 'none';
      document.getElementById('accessibilityTips').style.display = 'none';
      document.getElementById('accessibilitySuccess').style.display = 'none';
      document.getElementById('accessibilityEmpty').style.display = 'block';
      document.getElementById('accessibilityErrorList').innerHTML = '';
      document.getElementById('accessibilityWarningList').innerHTML = '';
      document.getElementById('accessibilityTipList').innerHTML = '';
    }

    function runAccessibilityCheck() {
      const errors = [];
      const warnings = [];
      const tips = [];

      // Get current sheet data
      const sheetData = sheets[currentSheet];

      // Check for merged cells without indication
      const table = document.querySelector('.spreadsheet-table');
      if (table) {
        const mergedCells = table.querySelectorAll('[colspan], [rowspan]');
        if (mergedCells.length > 0) {
          warnings.push({
            type: 'Merged Cells',
            description: `Found ${mergedCells.length} merged cells. Screen readers may have difficulty navigating merged cells.`,
            cells: []
          });
        }
      }

      // Check for tables without headers
      const hasHeaderRow = sheetData && Object.keys(sheetData).some(key => {
        const row = parseInt(key.match(/\d+/)?.[0] || 0);
        return row === 1 && sheetData[key];
      });
      if (!hasHeaderRow) {
        tips.push({
          type: 'No Header Row',
          description: 'Consider adding a header row to help screen readers understand the data structure.',
          cells: []
        });
      }

      // Check for very long text in cells (readability)
      if (sheetData) {
        Object.entries(sheetData).forEach(([cell, value]) => {
          if (typeof value === 'string' && value.length > 500) {
            warnings.push({
              type: 'Long Cell Content',
              description: `Cell ${cell} has ${value.length} characters. Consider breaking into multiple cells for readability.`,
              cells: [cell]
            });
          }
        });
      }

      // Check for charts without alt text
      const chartContainer = document.getElementById('chartContainer');
      if (chartContainer && chartContainer.children.length > 0) {
        const charts = chartContainer.querySelectorAll('canvas, .chart-wrapper');
        charts.forEach((chart, i) => {
          if (!chart.getAttribute('aria-label') && !chart.getAttribute('alt')) {
            warnings.push({
              type: 'Chart Without Alt Text',
              description: `Chart ${i + 1} doesn't have alternative text for screen readers.`,
              cells: [],
              fix: 'addChartAlt',
              chartIndex: i
            });
          }
        });
      }

      // Check for images without alt text
      if (table) {
        const images = table.querySelectorAll('img');
        images.forEach((img, i) => {
          if (!img.alt) {
            errors.push({
              type: 'Image Without Alt Text',
              description: `Image ${i + 1} is missing alternative text.`,
              cells: [],
              fix: 'addImageAlt'
            });
          }
        });
      }

      // Check for color-only formatting conveying meaning
      if (sheetData) {
        let colorFormattedCells = 0;
        Object.entries(sheetData).forEach(([cell, value]) => {
          const cellEl = document.getElementById(cell);
          if (cellEl) {
            const style = window.getComputedStyle(cellEl);
            const bgColor = style.backgroundColor;
            if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'rgb(255, 255, 255)') {
              colorFormattedCells++;
            }
          }
        });
        if (colorFormattedCells > 5) {
          tips.push({
            type: 'Color-Coded Data',
            description: `${colorFormattedCells} cells use background colors. Consider adding text indicators for color-blind users.`,
            cells: []
          });
        }
      }

      // Check for hyperlinks without descriptive text
      if (sheetData) {
        Object.entries(sheetData).forEach(([cell, value]) => {
          if (typeof value === 'string' && (value.startsWith('http://') || value.startsWith('https://'))) {
            warnings.push({
              type: 'Raw URL',
              description: `Cell ${cell} contains a raw URL. Consider using descriptive link text.`,
              cells: [cell]
            });
          }
        });
      }

      // Check for empty sheet
      if (!sheetData || Object.keys(sheetData).length === 0) {
        tips.push({
          type: 'Empty Sheet',
          description: 'This sheet appears to be empty. Consider adding data or removing unused sheets.',
          cells: []
        });
      }

      // Check for very wide tables
      const maxCol = sheetData ? Math.max(...Object.keys(sheetData).map(k => {
        const col = k.match(/^[A-Z]+/)?.[0] || 'A';
        return col.charCodeAt(0) - 64;
      })) : 0;
      if (maxCol > 15) {
        tips.push({
          type: 'Wide Data Range',
          description: `Data spans ${maxCol} columns. Consider breaking into multiple sheets for easier navigation.`,
          cells: []
        });
      }

      // Display results
      displayAccessibilityResults(errors, warnings, tips);
    }

    function displayAccessibilityResults(errors, warnings, tips) {
      document.getElementById('accessibilityEmpty').style.display = 'none';

      if (errors.length === 0 && warnings.length === 0 && tips.length === 0) {
        document.getElementById('accessibilitySuccess').style.display = 'block';
        showToast('No accessibility issues found!', 'success');
        return;
      }

      window.accessibilityErrors = errors;
      window.accessibilityWarnings = warnings;
      window.accessibilityTips = tips;

      // Display errors
      if (errors.length > 0) {
        document.getElementById('accessibilityErrors').style.display = 'block';
        document.getElementById('accessibilityErrorList').innerHTML = errors.map((e, i) => `
          <div style="padding: 0.75rem; border-bottom: 1px solid #fce8e6; cursor: pointer;" onclick="highlightAccessibilityCells(${i}, 'error')">
            <strong style="color: #d93025;">${e.type}</strong>
            <p style="margin: 0.25rem 0 0 0; font-size: 0.9rem; color: #666;">${e.description}</p>
          </div>
        `).join('');
      }

      // Display warnings
      if (warnings.length > 0) {
        document.getElementById('accessibilityWarnings').style.display = 'block';
        document.getElementById('accessibilityWarningList').innerHTML = warnings.map((w, i) => `
          <div style="padding: 0.75rem; border-bottom: 1px solid #fef3e0; cursor: pointer;" onclick="highlightAccessibilityCells(${i}, 'warning')">
            <strong style="color: #f9ab00;">${w.type}</strong>
            <p style="margin: 0.25rem 0 0 0; font-size: 0.9rem; color: #666;">${w.description}</p>
          </div>
        `).join('');
      }

      // Display tips
      if (tips.length > 0) {
        document.getElementById('accessibilityTips').style.display = 'block';
        document.getElementById('accessibilityTipList').innerHTML = tips.map((t, i) => `
          <div style="padding: 0.75rem; border-bottom: 1px solid #e8f0fe; cursor: pointer;" onclick="highlightAccessibilityCells(${i}, 'tip')">
            <strong style="color: #1a73e8;">${t.type}</strong>
            <p style="margin: 0.25rem 0 0 0; font-size: 0.9rem; color: #666;">${t.description}</p>
          </div>
        `).join('');
      }

      showToast(`Found ${errors.length} errors, ${warnings.length} warnings, ${tips.length} tips`, errors.length > 0 ? 'error' : 'info');
    }

    function highlightAccessibilityCells(index, type) {
      // Clear previous highlights
      document.querySelectorAll('.accessibility-highlight').forEach(el => {
        el.classList.remove('accessibility-highlight');
        el.style.outline = '';
      });

      let issue;
      if (type === 'error') issue = window.accessibilityErrors[index];
      else if (type === 'warning') issue = window.accessibilityWarnings[index];
      else issue = window.accessibilityTips[index];

      if (issue && issue.cells && issue.cells.length > 0) {
        issue.cells.forEach(cellRef => {
          const cell = document.getElementById(cellRef);
          if (cell) {
            cell.classList.add('accessibility-highlight');
            cell.style.outline = '3px solid ' + (type === 'error' ? '#d93025' : type === 'warning' ? '#f9ab00' : '#1a73e8');
            cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        });
      }
    }

    // ==================== DICTATION / VOICE INPUT ====================
    let recognition = null;
    let isDictating = false;

    function toggleDictation() {
      if (isDictating) {
        stopDictation();
      } else {
        startDictation();
      }
    }

    function startDictation() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        showToast('Speech recognition not supported in this browser. Try Chrome or Edge.', 'error');
        return;
      }

      if (!selectedCell) {
        showToast('Please select a cell first to dictate into.', 'warning');
        return;
      }

      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        isDictating = true;
        const btn = document.getElementById('dictationBtn');
        btn.style.background = '#d93025';
        btn.style.color = 'white';
        btn.innerHTML = 'üé§ Stop';
        showToast('Dictation started. Speak cell values or say "next cell" to move.', 'info');
      };

      recognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            // Process voice commands
            let processed = processExcelVoiceCommands(transcript);

            if (processed !== null) {
              // Update the selected cell
              const cell = document.getElementById(selectedCell);
              if (cell) {
                const currentVal = cell.value || '';
                cell.value = currentVal + processed;
                data[selectedCell] = cell.value;
                updateFormulaBar();
              }
            }
          }
        }
      };

      recognition.onerror = (event) => {
        if (event.error === 'not-allowed') {
          showToast('Microphone access denied. Please allow microphone access.', 'error');
        } else if (event.error !== 'no-speech') {
          showToast(`Dictation error: ${event.error}`, 'error');
        }
        stopDictation();
      };

      recognition.onend = () => {
        if (isDictating) {
          try {
            recognition.start();
          } catch (e) {
            stopDictation();
          }
        }
      };

      try {
        recognition.start();
      } catch (e) {
        showToast('Could not start dictation. Please try again.', 'error');
      }
    }

    function stopDictation() {
      isDictating = false;
      if (recognition) {
        recognition.stop();
        recognition = null;
      }

      const btn = document.getElementById('dictationBtn');
      btn.style.background = '';
      btn.style.color = '';
      btn.innerHTML = 'üé§ Dictate';
      showToast('Dictation stopped', 'info');
    }

    function processExcelVoiceCommands(text) {
      const lowerText = text.toLowerCase().trim();

      // Navigation commands
      if (lowerText === 'next cell' || lowerText === 'move right') {
        navigateCell('right');
        return null;
      }
      if (lowerText === 'previous cell' || lowerText === 'move left') {
        navigateCell('left');
        return null;
      }
      if (lowerText === 'cell down' || lowerText === 'move down') {
        navigateCell('down');
        return null;
      }
      if (lowerText === 'cell up' || lowerText === 'move up') {
        navigateCell('up');
        return null;
      }
      if (lowerText === 'enter' || lowerText === 'next row') {
        navigateCell('down');
        return null;
      }
      if (lowerText === 'clear' || lowerText === 'clear cell') {
        const cell = document.getElementById(selectedCell);
        if (cell) {
          cell.value = '';
          data[selectedCell] = '';
        }
        return null;
      }

      // Number recognition
      const numberWords = {
        'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
        'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',
        'ten': '10', 'eleven': '11', 'twelve': '12', 'hundred': '100', 'thousand': '1000'
      };

      if (numberWords[lowerText]) {
        return numberWords[lowerText];
      }

      // Operators
      if (lowerText === 'plus') return '+';
      if (lowerText === 'minus') return '-';
      if (lowerText === 'times' || lowerText === 'multiply') return '*';
      if (lowerText === 'divided by' || lowerText === 'divide') return '/';
      if (lowerText === 'equals') return '=';
      if (lowerText === 'percent') return '%';
      if (lowerText === 'decimal' || lowerText === 'point') return '.';

      return text;
    }

    function navigateCell(direction) {
      if (!selectedCell) return;

      const col = selectedCell.match(/^[A-Z]+/)[0];
      const row = parseInt(selectedCell.match(/\d+/)[0]);
      let newCol = col;
      let newRow = row;

      switch (direction) {
        case 'right':
          newCol = String.fromCharCode(col.charCodeAt(0) + 1);
          break;
        case 'left':
          if (col !== 'A') newCol = String.fromCharCode(col.charCodeAt(0) - 1);
          break;
        case 'down':
          newRow = row + 1;
          break;
        case 'up':
          if (row > 1) newRow = row - 1;
          break;
      }

      const newCellRef = newCol + newRow;
      const newCell = document.getElementById(newCellRef);
      if (newCell) {
        selectCell(newCellRef);
        newCell.focus();
      }
    }

    // ========== Stock Images ==========
    let selectedStockImage = null;
    let floatingImages = [];

    function showStockImages() {
      document.getElementById('stockImagesModal').classList.add('active');
      document.getElementById('stockImageSearch').focus();
    }

    function hideStockImages() {
      document.getElementById('stockImagesModal').classList.remove('active');
      selectedStockImage = null;
      document.getElementById('stockImagePreview').style.display = 'none';
    }

    function searchStockCategory(category) {
      document.getElementById('stockImageSearch').value = category;
      searchStockImages();
    }

    async function searchStockImages() {
      const query = document.getElementById('stockImageSearch').value.trim();
      if (!query) {
        showToast('Please enter a search term', 'warning');
        return;
      }

      const resultsContainer = document.getElementById('stockImageResults');
      resultsContainer.innerHTML = '<div style="grid-column: span 4; text-align: center; padding: 2rem;">Loading images...</div>';

      const images = await fetchStockImages(query);
      displayStockImages(images);
    }

    async function fetchStockImages(query) {
      // Using Lorem Picsum for free stock images
      const images = [];
      const seedBase = query.split('').reduce((a, b) => a + b.charCodeAt(0), 0);

      for (let i = 0; i < 16; i++) {
        const seed = seedBase + i;
        images.push({
          id: seed,
          thumb: `https://picsum.photos/seed/${seed}/150/150`,
          small: `https://picsum.photos/seed/${seed}/200/200`,
          medium: `https://picsum.photos/seed/${seed}/400/400`,
          large: `https://picsum.photos/seed/${seed}/600/600`,
          alt: `${query} image ${i + 1}`
        });
      }

      return images;
    }

    function displayStockImages(images) {
      const resultsContainer = document.getElementById('stockImageResults');

      if (images.length === 0) {
        resultsContainer.innerHTML = '<div style="grid-column: span 4; text-align: center; color: #666; padding: 2rem;">No images found</div>';
        return;
      }

      resultsContainer.innerHTML = images.map(img => `
        <div class="stock-image-item" onclick="selectStockImage(${JSON.stringify(img).replace(/"/g, '&quot;')})"
             style="cursor: pointer; border: 2px solid transparent; border-radius: 8px; overflow: hidden; transition: all 0.2s;">
          <img src="${img.thumb}" alt="${img.alt}" style="width: 100%; height: 120px; object-fit: cover; display: block;">
        </div>
      `).join('');

      // Add hover effects
      resultsContainer.querySelectorAll('.stock-image-item').forEach(item => {
        item.addEventListener('mouseenter', () => item.style.borderColor = '#1a73e8');
        item.addEventListener('mouseleave', () => {
          if (!item.classList.contains('selected')) {
            item.style.borderColor = 'transparent';
          }
        });
      });
    }

    function selectStockImage(imgData) {
      selectedStockImage = imgData;

      // Show preview
      document.getElementById('stockImagePreview').style.display = 'block';
      document.getElementById('stockPreviewImg').src = imgData.medium;

      // Highlight selected
      document.querySelectorAll('.stock-image-item').forEach(item => {
        item.style.borderColor = 'transparent';
        item.classList.remove('selected');
      });
      event.currentTarget.style.borderColor = '#1a73e8';
      event.currentTarget.classList.add('selected');
    }

    function insertStockImage() {
      if (!selectedStockImage) {
        showToast('Please select an image first', 'warning');
        return;
      }

      const size = document.getElementById('stockImageSize').value;
      const insertType = document.getElementById('stockImageInsertType').value;

      let imageUrl;
      switch (size) {
        case 'small': imageUrl = selectedStockImage.small; break;
        case 'medium': imageUrl = selectedStockImage.medium; break;
        case 'large': imageUrl = selectedStockImage.large; break;
        default: imageUrl = selectedStockImage.medium;
      }

      if (insertType === 'cell') {
        insertImageInCell(imageUrl, size);
      } else {
        insertFloatingImage(imageUrl, size);
      }

      hideStockImages();
      showToast('Image inserted successfully!', 'success');
    }

    function insertImageInCell(imageUrl, size) {
      if (!selectedCell) {
        showToast('Please select a cell first', 'warning');
        return;
      }

      const cell = document.getElementById(selectedCell);
      if (!cell) return;

      const sizeMap = { small: 100, medium: 150, large: 200 };
      const imgSize = sizeMap[size] || 150;

      // Clear existing content
      cell.innerHTML = '';

      // Create image
      const img = document.createElement('img');
      img.src = imageUrl;
      img.alt = selectedStockImage.alt;
      img.style.cssText = `max-width: ${imgSize}px; max-height: ${imgSize}px; object-fit: contain;`;

      cell.appendChild(img);

      // Adjust cell height
      const td = cell.closest('td');
      if (td) {
        td.style.height = (imgSize + 10) + 'px';
      }

      // Store in data
      data[selectedCell] = `[IMAGE:${imageUrl}]`;
    }

    function insertFloatingImage(imageUrl, size) {
      const sizeMap = { small: 150, medium: 250, large: 350 };
      const imgSize = sizeMap[size] || 250;

      const container = document.getElementById('spreadsheetContainer');

      // Create floating image container
      const floatImg = document.createElement('div');
      floatImg.className = 'floating-image';
      floatImg.style.cssText = `
        position: absolute;
        top: 100px;
        left: 200px;
        width: ${imgSize}px;
        height: ${imgSize}px;
        border: 2px solid #1a73e8;
        border-radius: 4px;
        overflow: hidden;
        cursor: move;
        z-index: 100;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      `;

      const img = document.createElement('img');
      img.src = imageUrl;
      img.alt = selectedStockImage.alt;
      img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.innerHTML = '&times;';
      deleteBtn.style.cssText = `
        position: absolute;
        top: 4px;
        right: 4px;
        width: 24px;
        height: 24px;
        border: none;
        background: rgba(255,255,255,0.9);
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        color: #d93025;
        display: none;
      `;
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        floatImg.remove();
      };

      floatImg.appendChild(img);
      floatImg.appendChild(deleteBtn);

      // Show delete button on hover
      floatImg.onmouseenter = () => deleteBtn.style.display = 'block';
      floatImg.onmouseleave = () => deleteBtn.style.display = 'none';

      // Make draggable
      makeDraggable(floatImg);

      container.appendChild(floatImg);
      floatingImages.push(floatImg);
    }

    function makeDraggable(element) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

      element.onmousedown = dragMouseDown;

      function dragMouseDown(e) {
        if (e.target.tagName === 'BUTTON') return;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }

      function elementDrag(e) {
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + 'px';
        element.style.left = (element.offsetLeft - pos1) + 'px';
      }

      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }

    // ========== QR Code Generator ==========
    let currentQRType = 'url';
    let currentQRData = null;

    function showQRCodeGenerator() {
      document.getElementById('qrCodeModal').classList.add('active');
      selectQRType('url');
    }

    function hideQRCodeGenerator() {
      document.getElementById('qrCodeModal').classList.remove('active');
      currentQRData = null;
    }

    function selectQRType(type) {
      currentQRType = type;

      // Update buttons
      document.querySelectorAll('.qr-type-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });

      // Show/hide panels
      const panels = ['url', 'text', 'email', 'phone', 'cell'];
      panels.forEach(panel => {
        const el = document.getElementById(`qr${panel.charAt(0).toUpperCase() + panel.slice(1)}Panel`);
        if (el) el.style.display = (panel === type) ? 'block' : 'none';
      });

      // Update cell value display
      if (type === 'cell' && selectedCell) {
        const cellValue = data[selectedCell] || '';
        document.getElementById('qrCellValue').innerHTML = cellValue ?
          `<strong>${selectedCell}:</strong> ${cellValue}` :
          '<span style="color: #999;">Cell is empty</span>';
      }

      generateQRPreview();
    }

    function getQRContent() {
      switch (currentQRType) {
        case 'url':
          return document.getElementById('qrUrl').value.trim();
        case 'text':
          return document.getElementById('qrText').value.trim();
        case 'email':
          const email = document.getElementById('qrEmail').value.trim();
          return email ? `mailto:${email}` : '';
        case 'phone':
          const phone = document.getElementById('qrPhone').value.trim();
          return phone ? `tel:${phone}` : '';
        case 'cell':
          if (!selectedCell) return '';
          return String(data[selectedCell] || '');
        default:
          return '';
      }
    }

    function generateQRPreview() {
      const content = getQRContent();
      const size = parseInt(document.getElementById('qrSize').value);
      const preview = document.getElementById('qrPreview');

      if (!content) {
        preview.innerHTML = '<span style="color: #999;">Enter content to generate QR code</span>';
        currentQRData = null;
        return;
      }

      const qrSvg = generateQRSVG(content, size);
      preview.innerHTML = qrSvg;
      currentQRData = { content, size };
    }

    function generateQRSVG(data, size) {
      const modules = 25;
      const hash = simpleHash(data);
      const bits = [];

      for (let i = 0; i < modules * modules; i++) {
        bits.push(((hash * (i + 1) * 31) % 100) > 50);
      }

      const addFinderPattern = (startRow, startCol) => {
        for (let r = 0; r < 7; r++) {
          for (let c = 0; c < 7; c++) {
            const idx = (startRow + r) * modules + (startCol + c);
            if (r === 0 || r === 6 || c === 0 || c === 6) {
              bits[idx] = true;
            } else if (r >= 1 && r <= 5 && c >= 1 && c <= 5) {
              bits[idx] = false;
            }
            if (r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              bits[idx] = true;
            }
          }
        }
      };

      addFinderPattern(0, 0);
      addFinderPattern(0, modules - 7);
      addFinderPattern(modules - 7, 0);

      for (let i = 8; i < modules - 8; i++) {
        bits[6 * modules + i] = i % 2 === 0;
        bits[i * modules + 6] = i % 2 === 0;
      }

      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${modules} ${modules}">`;
      svg += `<rect width="${modules}" height="${modules}" fill="white"/>`;

      for (let row = 0; row < modules; row++) {
        for (let col = 0; col < modules; col++) {
          if (bits[row * modules + col]) {
            svg += `<rect x="${col}" y="${row}" width="1" height="1" fill="black"/>`;
          }
        }
      }

      svg += '</svg>';
      return svg;
    }

    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    }

    function insertQRCode() {
      if (!currentQRData) {
        showToast('Please enter content to generate a QR code', 'warning');
        return;
      }

      const preview = document.getElementById('qrPreview');
      const svg = preview.querySelector('svg');

      if (!svg) {
        showToast('No QR code generated', 'error');
        return;
      }

      // Insert as floating image in spreadsheet
      const svgData = new XMLSerializer().serializeToString(svg);
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      const container = document.getElementById('spreadsheetContainer');
      const floatImg = document.createElement('div');
      floatImg.className = 'floating-image qr-code-image';
      floatImg.style.cssText = `
        position: absolute;
        top: 100px;
        left: 200px;
        width: ${currentQRData.size}px;
        height: ${currentQRData.size}px;
        border: 2px solid #1a73e8;
        border-radius: 4px;
        overflow: hidden;
        cursor: move;
        z-index: 100;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      `;

      const img = document.createElement('img');
      img.src = url;
      img.alt = 'QR Code';
      img.style.cssText = 'width: 100%; height: 100%; object-fit: contain;';

      const deleteBtn = document.createElement('button');
      deleteBtn.innerHTML = '&times;';
      deleteBtn.style.cssText = `
        position: absolute;
        top: 4px;
        right: 4px;
        width: 24px;
        height: 24px;
        border: none;
        background: rgba(255,255,255,0.9);
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        color: #d93025;
        display: none;
      `;
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        floatImg.remove();
      };

      floatImg.appendChild(img);
      floatImg.appendChild(deleteBtn);

      floatImg.onmouseenter = () => deleteBtn.style.display = 'block';
      floatImg.onmouseleave = () => deleteBtn.style.display = 'none';

      makeDraggable(floatImg);
      container.appendChild(floatImg);

      hideQRCodeGenerator();
      showToast('QR Code inserted', 'success');
    }

    // ========== Auto-Save & Version History ==========
    // autoSaveEnabled and autoSaveInterval defined in AUTO-SAVE section below
    let autoSaveTimer = null;
    let versionHistory = [];
    const VERSION_STORAGE_KEY = 'ninjacalc_versions';
    const MAX_VERSIONS = 15;

    (function initAutoSave() {
      const saved = localStorage.getItem(VERSION_STORAGE_KEY);
      if (saved) {
        try { versionHistory = JSON.parse(saved); } catch(e) { versionHistory = []; }
      }
      if (localStorage.getItem('ninjacalc_autosave') === 'true') {
        autoSaveEnabled = true;
        startAutoSave();
        updateAutoSaveUI();
      }
    })();

    function toggleAutoSave() {
      autoSaveEnabled = !autoSaveEnabled;
      localStorage.setItem('ninjacalc_autosave', autoSaveEnabled);
      if (autoSaveEnabled) {
        startAutoSave();
        showToast('Auto-Save enabled', 'success');
      } else {
        stopAutoSave();
        showToast('Auto-Save disabled', 'info');
      }
      updateAutoSaveUI();
    }

    function toggleAutoSaveFromModal() {
      autoSaveEnabled = document.getElementById('autoSaveCheckbox').checked;
      localStorage.setItem('ninjacalc_autosave', autoSaveEnabled);
      if (autoSaveEnabled) startAutoSave(); else stopAutoSave();
      updateAutoSaveUI();
    }

    function updateAutoSaveUI() {
      const btn = document.getElementById('autoSaveBtn');
      const status = document.getElementById('autoSaveStatus');
      const checkbox = document.getElementById('autoSaveCheckbox');
      if (btn) {
        btn.innerHTML = autoSaveEnabled ? 'üíæ Auto-Save: On' : 'üíæ Auto-Save: Off';
        btn.style.background = autoSaveEnabled ? '#e8f5e9' : '';
        btn.style.color = autoSaveEnabled ? '#2e7d32' : '';
      }
      if (status) {
        status.textContent = autoSaveEnabled ? 'Enabled' : 'Disabled';
        status.style.color = autoSaveEnabled ? '#2e7d32' : '#d93025';
      }
      if (checkbox) checkbox.checked = autoSaveEnabled;
    }

    function startAutoSave() {
      stopAutoSave();
      autoSaveTimer = setInterval(() => saveVersion('auto'), autoSaveInterval);
    }

    function stopAutoSave() {
      if (autoSaveTimer) { clearInterval(autoSaveTimer); autoSaveTimer = null; }
    }

    function updateAutoSaveInterval() {
      autoSaveInterval = parseInt(document.getElementById('autoSaveInterval').value);
      if (autoSaveEnabled) startAutoSave();
    }

    function saveVersion(type = 'manual') {
      const snapshot = { data: {...data}, formulas: {...formulas}, formatting: {...formatting} };
      const content = JSON.stringify(snapshot);

      if (versionHistory.length > 0 && JSON.stringify(versionHistory[0].snapshot) === content) return;

      const cellCount = Object.keys(data).length;
      if (cellCount === 0) return;

      versionHistory.unshift({
        id: Date.now(),
        timestamp: new Date().toISOString(),
        type,
        snapshot,
        cellCount
      });

      if (versionHistory.length > MAX_VERSIONS) versionHistory = versionHistory.slice(0, MAX_VERSIONS);
      localStorage.setItem(VERSION_STORAGE_KEY, JSON.stringify(versionHistory));

      if (type === 'auto') {
        const btn = document.getElementById('autoSaveBtn');
        if (btn) {
          const orig = btn.innerHTML;
          btn.innerHTML = 'üíæ Saved!';
          setTimeout(() => btn.innerHTML = orig, 1500);
        }
      }
    }

    function createManualVersion() {
      saveVersion('manual');
      showToast('Version saved', 'success');
      renderVersionList();
    }

    function showVersionHistory() {
      document.getElementById('versionHistoryModal').classList.add('active');
      updateAutoSaveUI();
      renderVersionList();
    }

    function hideVersionHistory() {
      document.getElementById('versionHistoryModal').classList.remove('active');
    }

    function renderVersionList() {
      const container = document.getElementById('versionList');
      if (versionHistory.length === 0) {
        container.innerHTML = '<div style="padding: 1rem; text-align: center; color: #666;">No versions saved yet</div>';
        return;
      }
      container.innerHTML = versionHistory.map((v, i) => `
        <div style="padding: 0.5rem 1rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; ${i === 0 ? 'background: #e8f5e9;' : ''}">
          <div>
            <div style="font-weight: ${i === 0 ? '600' : '400'};">${v.type === 'auto' ? 'üîÑ' : 'üì∏'} ${i === 0 ? '(Current)' : ''}</div>
            <div style="font-size: 0.8rem; color: #666;">${new Date(v.timestamp).toLocaleString()} ¬∑ ${v.cellCount} cells</div>
          </div>
          <div style="display: flex; gap: 0.25rem;">
            <button class="btn btn-sm btn-secondary" onclick="restoreVersion(${i})" title="Restore">‚Ü©</button>
            <button class="btn btn-sm btn-secondary" onclick="deleteVersion(${i})" title="Delete" style="color: #d93025;">üóë</button>
          </div>
        </div>
      `).join('');
    }

    function restoreVersion(index) {
      const v = versionHistory[index];
      if (!v || !confirm('Restore this version?')) return;
      saveVersion('manual');
      Object.keys(data).forEach(k => delete data[k]);
      Object.keys(formulas).forEach(k => delete formulas[k]);
      Object.keys(formatting).forEach(k => delete formatting[k]);
      Object.assign(data, v.snapshot.data || {});
      Object.assign(formulas, v.snapshot.formulas || {});
      Object.assign(formatting, v.snapshot.formatting || {});
      renderSpreadsheet();
      showToast('Version restored', 'success');
      hideVersionHistory();
    }

    function deleteVersion(index) {
      if (!confirm('Delete this version?')) return;
      versionHistory.splice(index, 1);
      localStorage.setItem(VERSION_STORAGE_KEY, JSON.stringify(versionHistory));
      renderVersionList();
    }

    function clearVersionHistory() {
      if (!confirm('Clear all version history?')) return;
      versionHistory = [];
      localStorage.setItem(VERSION_STORAGE_KEY, JSON.stringify(versionHistory));
      renderVersionList();
      showToast('History cleared', 'info');
    }

    window.addEventListener('beforeunload', () => { if (autoSaveEnabled) saveVersion('auto'); });

    // ========== Find & Replace ==========
    let findMatches = [];
    let currentFindIndex = -1;

    function showFindReplace() {
      document.getElementById('findReplaceModal').classList.add('active');
      document.getElementById('findInput').focus();
      findMatches = [];
      currentFindIndex = -1;
      document.getElementById('findResults').innerHTML = '<span style="color: #666;">Enter text to search</span>';
      document.getElementById('findMatchList').style.display = 'none';
    }

    function hideFindReplace() {
      document.getElementById('findReplaceModal').classList.remove('active');
      clearFindHighlights();
    }

    function findInCells() {
      const searchText = document.getElementById('findInput').value;
      if (!searchText) {
        document.getElementById('findResults').innerHTML = '<span style="color: #666;">Enter text to search</span>';
        document.getElementById('findMatchList').style.display = 'none';
        return;
      }

      const matchCase = document.getElementById('findMatchCase').checked;
      const wholeCell = document.getElementById('findWholeCell').checked;
      const scope = document.getElementById('findScope').value;

      findMatches = [];
      clearFindHighlights();

      // Get cells to search
      let cellsToSearch = [];
      if (scope === 'selection' && selectedCells.length > 0) {
        cellsToSearch = selectedCells.map(c => c.id);
      } else {
        // Search all cells with data
        for (const cellId in data) {
          cellsToSearch.push(cellId);
        }
        for (const cellId in formulas) {
          if (!cellsToSearch.includes(cellId)) {
            cellsToSearch.push(cellId);
          }
        }
      }

      cellsToSearch.forEach(cellId => {
        let valueToSearch = '';
        let formulaToSearch = '';

        if (data[cellId] !== undefined) valueToSearch = String(data[cellId]);
        if (formulas[cellId]) formulaToSearch = formulas[cellId];

        let searchIn = [];
        if (scope === 'values' || scope === 'all' || scope === 'selection') {
          searchIn.push({ type: 'value', text: valueToSearch });
        }
        if (scope === 'formulas' || scope === 'all' || scope === 'selection') {
          searchIn.push({ type: 'formula', text: formulaToSearch });
        }

        searchIn.forEach(item => {
          if (!item.text) return;

          let text = item.text;
          let search = searchText;

          if (!matchCase) {
            text = text.toLowerCase();
            search = search.toLowerCase();
          }

          let matches = false;
          if (wholeCell) {
            matches = text === search;
          } else {
            matches = text.includes(search);
          }

          if (matches) {
            findMatches.push({
              cellId: cellId,
              type: item.type,
              value: item.text
            });
          }
        });
      });

      // Update results display
      if (findMatches.length === 0) {
        document.getElementById('findResults').innerHTML = '<span style="color: #d93025;">No matches found</span>';
        document.getElementById('findMatchList').style.display = 'none';
      } else {
        document.getElementById('findResults').innerHTML = `<span style="color: #1a73e8; font-weight: 500;">${findMatches.length} match${findMatches.length !== 1 ? 'es' : ''} found</span>`;
        renderFindMatchList();
        currentFindIndex = 0;
        highlightFindMatches();
        goToMatch(0);
      }
    }

    function renderFindMatchList() {
      const container = document.getElementById('findMatchList');
      container.style.display = 'block';
      container.innerHTML = findMatches.map((m, i) => `
        <div style="padding: 0.5rem; border-bottom: 1px solid #eee; cursor: pointer; display: flex; justify-content: space-between; align-items: center;${i === currentFindIndex ? 'background: #e3f2fd;' : ''}"
             onclick="goToMatch(${i})"
             onmouseover="this.style.background='#f5f5f5'"
             onmouseout="this.style.background='${i === currentFindIndex ? '#e3f2fd' : 'transparent'}'">
          <span><strong>${m.cellId}</strong>: ${escapeHtml(m.value.substring(0, 30))}${m.value.length > 30 ? '...' : ''}</span>
          <span style="font-size: 0.75rem; color: #666;">${m.type}</span>
        </div>
      `).join('');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function highlightFindMatches() {
      findMatches.forEach(m => {
        const cell = document.getElementById(m.cellId);
        if (cell) {
          cell.style.background = '#fff9c4';
        }
      });
    }

    function clearFindHighlights() {
      findMatches.forEach(m => {
        const cell = document.getElementById(m.cellId);
        if (cell) {
          cell.style.background = '';
        }
      });
    }

    function goToMatch(index) {
      if (findMatches.length === 0) return;
      currentFindIndex = index;

      const match = findMatches[currentFindIndex];
      const cell = document.getElementById(match.cellId);
      if (cell) {
        cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
        cell.style.background = '#bbdefb';
        setTimeout(() => {
          cell.style.background = '#fff9c4';
        }, 500);

        // Select the cell
        selectCell(match.cellId);
      }

      renderFindMatchList();
    }

    function findNextCell() {
      if (findMatches.length === 0) {
        findInCells();
        return;
      }
      currentFindIndex = (currentFindIndex + 1) % findMatches.length;
      goToMatch(currentFindIndex);
    }

    function findPrevCell() {
      if (findMatches.length === 0) {
        findInCells();
        return;
      }
      currentFindIndex = (currentFindIndex - 1 + findMatches.length) % findMatches.length;
      goToMatch(currentFindIndex);
    }

    function replaceInCell() {
      if (findMatches.length === 0 || currentFindIndex < 0) {
        showToast('No match selected', 'error');
        return;
      }

      const searchText = document.getElementById('findInput').value;
      const replaceText = document.getElementById('replaceInput').value;
      const matchCase = document.getElementById('findMatchCase').checked;
      const wholeCell = document.getElementById('findWholeCell').checked;

      const match = findMatches[currentFindIndex];
      const cellId = match.cellId;

      if (match.type === 'formula' && formulas[cellId]) {
        let formula = formulas[cellId];
        if (wholeCell) {
          formulas[cellId] = replaceText;
        } else {
          const regex = new RegExp(escapeRegex(searchText), matchCase ? 'g' : 'gi');
          formulas[cellId] = formula.replace(regex, replaceText);
        }
        recalculateAll();
      } else if (data[cellId] !== undefined) {
        let value = String(data[cellId]);
        if (wholeCell) {
          data[cellId] = replaceText;
        } else {
          const regex = new RegExp(escapeRegex(searchText), matchCase ? 'g' : 'gi');
          data[cellId] = value.replace(regex, replaceText);
        }
        renderCell(cellId);
      }

      // Remove from matches and find next
      findMatches.splice(currentFindIndex, 1);
      if (findMatches.length === 0) {
        document.getElementById('findResults').innerHTML = '<span style="color: #4caf50;">All matches replaced</span>';
        document.getElementById('findMatchList').style.display = 'none';
        currentFindIndex = -1;
      } else {
        currentFindIndex = currentFindIndex % findMatches.length;
        document.getElementById('findResults').innerHTML = `<span style="color: #1a73e8; font-weight: 500;">${findMatches.length} match${findMatches.length !== 1 ? 'es' : ''} remaining</span>`;
        renderFindMatchList();
        goToMatch(currentFindIndex);
      }

      showToast('Replaced', 'success');
    }

    function replaceAllInCells() {
      if (findMatches.length === 0) {
        findInCells();
        if (findMatches.length === 0) return;
      }

      const searchText = document.getElementById('findInput').value;
      const replaceText = document.getElementById('replaceInput').value;
      const matchCase = document.getElementById('findMatchCase').checked;
      const wholeCell = document.getElementById('findWholeCell').checked;

      let count = 0;
      const processedCells = new Set();

      findMatches.forEach(match => {
        if (processedCells.has(match.cellId + match.type)) return;
        processedCells.add(match.cellId + match.type);

        const cellId = match.cellId;

        if (match.type === 'formula' && formulas[cellId]) {
          let formula = formulas[cellId];
          if (wholeCell) {
            formulas[cellId] = replaceText;
          } else {
            const regex = new RegExp(escapeRegex(searchText), matchCase ? 'g' : 'gi');
            formulas[cellId] = formula.replace(regex, replaceText);
          }
          count++;
        } else if (data[cellId] !== undefined) {
          let value = String(data[cellId]);
          if (wholeCell) {
            data[cellId] = replaceText;
          } else {
            const regex = new RegExp(escapeRegex(searchText), matchCase ? 'g' : 'gi');
            data[cellId] = value.replace(regex, replaceText);
          }
          renderCell(cellId);
          count++;
        }
      });

      recalculateAll();
      clearFindHighlights();
      findMatches = [];
      currentFindIndex = -1;

      document.getElementById('findResults').innerHTML = `<span style="color: #4caf50; font-weight: 500;">Replaced ${count} occurrence${count !== 1 ? 's' : ''}</span>`;
      document.getElementById('findMatchList').style.display = 'none';
      showToast(`Replaced ${count} occurrences`, 'success');
    }

    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Keyboard shortcut for Find & Replace
    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key === 'h') {
        e.preventDefault();
        showFindReplace();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        showFindReplace();
      }
    });

    // ========== Recent Spreadsheets ==========
    const RECENT_SHEETS_KEY = 'ninjacalc_recent_spreadsheets';
    let recentSpreadsheets = [];

    (function initRecentSpreadsheets() {
      const saved = localStorage.getItem(RECENT_SHEETS_KEY);
      if (saved) { try { recentSpreadsheets = JSON.parse(saved); } catch(e) { recentSpreadsheets = []; }}
    })();

    function addToRecentSpreadsheets(name) {
      const sheet = {
        id: Date.now(),
        name: name || 'Untitled Spreadsheet',
        data: {...data},
        formulas: {...formulas},
        formatting: {...formatting},
        timestamp: new Date().toISOString(),
        cellCount: Object.keys(data).length
      };
      recentSpreadsheets = recentSpreadsheets.filter(s => s.name !== sheet.name);
      recentSpreadsheets.unshift(sheet);
      if (recentSpreadsheets.length > 15) recentSpreadsheets = recentSpreadsheets.slice(0, 15);
      localStorage.setItem(RECENT_SHEETS_KEY, JSON.stringify(recentSpreadsheets));
    }

    function showRecentSpreadsheets() {
      document.getElementById('recentSpreadsheetsModal').classList.add('active');
      renderRecentSpreadsheets();
    }

    function hideRecentSpreadsheets() {
      document.getElementById('recentSpreadsheetsModal').classList.remove('active');
    }

    function renderRecentSpreadsheets(filter = '') {
      const container = document.getElementById('recentSpreadsheetsList');
      let sheets = filter ? recentSpreadsheets.filter(s => s.name.toLowerCase().includes(filter.toLowerCase())) : recentSpreadsheets;
      document.getElementById('recentSpreadCount').textContent = `${sheets.length} spreadsheet${sheets.length !== 1 ? 's' : ''}`;

      if (sheets.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">No recent spreadsheets</div>';
        return;
      }

      container.innerHTML = sheets.map((s, i) => `
        <div style="padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 1rem; cursor: pointer;"
             onmouseenter="this.style.background='#f5f5f5'" onmouseleave="this.style.background=''" onclick="openRecentSpreadsheet(${i})">
          <div style="font-size: 2rem;">üìä</div>
          <div style="flex: 1;">
            <div style="font-weight: 600;">${s.name}</div>
            <div style="font-size: 0.8rem; color: #666;">${new Date(s.timestamp).toLocaleString()} ¬∑ ${s.cellCount} cells</div>
          </div>
          <button class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); deleteRecentSpreadsheet(${i})">üóë</button>
        </div>
      `).join('');
    }

    function filterRecentSpreadsheets() {
      renderRecentSpreadsheets(document.getElementById('recentSearchInput').value);
    }

    function openRecentSpreadsheet(index) {
      const s = recentSpreadsheets[index];
      if (!s || !confirm('Open this spreadsheet? Current data will be replaced.')) return;
      Object.keys(data).forEach(k => delete data[k]);
      Object.keys(formulas).forEach(k => delete formulas[k]);
      Object.keys(formatting).forEach(k => delete formatting[k]);
      Object.assign(data, s.data || {});
      Object.assign(formulas, s.formulas || {});
      Object.assign(formatting, s.formatting || {});
      renderSpreadsheet();
      hideRecentSpreadsheets();
      showToast(`Opened: ${s.name}`, 'success');
    }

    function deleteRecentSpreadsheet(index) {
      if (!confirm('Remove from recent?')) return;
      recentSpreadsheets.splice(index, 1);
      localStorage.setItem(RECENT_SHEETS_KEY, JSON.stringify(recentSpreadsheets));
      renderRecentSpreadsheets();
    }

    function clearRecentSpreadsheets() {
      if (!confirm('Clear all recent spreadsheets?')) return;
      recentSpreadsheets = [];
      localStorage.setItem(RECENT_SHEETS_KEY, JSON.stringify(recentSpreadsheets));
      renderRecentSpreadsheets();
    }

    // ==================== QUICK ACCESS TOOLBAR ====================
    const qatCommands = [
      { id: 'save', icon: 'üíæ', label: 'Save', action: 'saveSpreadsheet()' },
      { id: 'undo', icon: '‚Ü∂', label: 'Undo', action: 'undo()' },
      { id: 'redo', icon: '‚Ü∑', label: 'Redo', action: 'redo()' },
      { id: 'pdf', icon: 'üìÑ', label: 'Export PDF', action: 'exportPDF()' },
      { id: 'print', icon: 'üñ®Ô∏è', label: 'Print', action: 'showPrintPreview()' },
      { id: 'new', icon: 'üìù', label: 'New Spreadsheet', action: 'newSpreadsheet()' },
      { id: 'open', icon: 'üìÇ', label: 'Open', action: 'showOpenDialog()' },
      { id: 'find', icon: 'üîç', label: 'Find & Replace', action: 'showFindReplace()' },
      { id: 'chart', icon: 'üìä', label: 'Insert Chart', action: 'showChartModal()' },
      { id: 'sum', icon: 'Œ£', label: 'AutoSum', action: 'autoSum()' },
      { id: 'sort', icon: '‚Üï', label: 'Sort', action: 'sortData()' },
      { id: 'filter', icon: '‚öô', label: 'Filter', action: 'toggleFilters()' },
      { id: 'freeze', icon: '‚ùÑ', label: 'Freeze Panes', action: 'freezePane()' },
      { id: 'pivot', icon: 'üìã', label: 'Pivot Table', action: 'showPivotModal()' },
      { id: 'format', icon: 'üé®', label: 'Conditional Format', action: 'showConditionalFormat()' },
      { id: 'darkmode', icon: 'üåô', label: 'Dark Mode', action: 'toggleDarkMode()' }
    ];

    const defaultQATItems = ['save', 'undo', 'redo', 'pdf', 'print'];
    let qatItems = JSON.parse(localStorage.getItem('ninjaCalcQAT')) || [...defaultQATItems];

    function renderQAT() {
      const toolbar = document.getElementById('quickAccessToolbar');
      let html = '';

      qatItems.forEach((itemId, index) => {
        const cmd = qatCommands.find(c => c.id === itemId);
        if (cmd) {
          html += `<button class="qat-btn" onclick="${cmd.action}" title="${cmd.label}">${cmd.icon}</button>`;
          if (index === 2 && qatItems.length > 3) {
            html += '<span class="qat-separator"></span>';
          }
        }
      });

      html += '<button class="qat-btn qat-customize" onclick="showQATCustomization()" title="Customize Quick Access Toolbar">‚ñº Customize</button>';
      toolbar.innerHTML = html;
    }

    function showQATCustomization() {
      const list = document.getElementById('qatCommandsList');
      list.innerHTML = qatCommands.map(cmd => `
        <label class="qat-modal-item">
          <input type="checkbox" value="${cmd.id}" ${qatItems.includes(cmd.id) ? 'checked' : ''}>
          <span style="font-size: 1.2rem;">${cmd.icon}</span>
          <span>${cmd.label}</span>
        </label>
      `).join('');
      document.getElementById('qatModal').classList.add('active');
    }

    function hideQATCustomization() {
      document.getElementById('qatModal').classList.remove('active');
    }

    function saveQATCustomization() {
      const checkboxes = document.querySelectorAll('#qatCommandsList input[type="checkbox"]:checked');
      qatItems = Array.from(checkboxes).map(cb => cb.value);
      if (qatItems.length === 0) {
        qatItems = [...defaultQATItems];
        showToast('At least one command is required. Reset to defaults.', 'warning');
      }
      localStorage.setItem('ninjaCalcQAT', JSON.stringify(qatItems));
      renderQAT();
      hideQATCustomization();
      showToast('Quick Access Toolbar updated', 'success');
    }

    function resetQAT() {
      qatItems = [...defaultQATItems];
      localStorage.setItem('ninjaCalcQAT', JSON.stringify(qatItems));
      renderQAT();
      hideQATCustomization();
      showToast('Quick Access Toolbar reset to defaults', 'info');
    }

    // Initialize QAT on load
    document.addEventListener('DOMContentLoaded', renderQAT);

    // ==================== DRAG & DROP FILE IMPORT ====================
    const dropOverlay = document.getElementById('dropOverlay');
    let dragCounter = 0;

    document.addEventListener('dragenter', function(e) {
      e.preventDefault();
      dragCounter++;
      if (e.dataTransfer.types.includes('Files')) {
        dropOverlay.classList.add('visible');
      }
    });

    document.addEventListener('dragleave', function(e) {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        dropOverlay.classList.remove('visible');
      }
    });

    document.addEventListener('dragover', function(e) {
      e.preventDefault();
    });

    document.addEventListener('drop', function(e) {
      e.preventDefault();
      dragCounter = 0;
      dropOverlay.classList.remove('visible');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleDroppedFile(files[0]);
      }
    });

    function handleDroppedFile(file) {
      const fileName = file.name.toLowerCase();
      const extension = fileName.split('.').pop();

      if (extension === 'csv') {
        const reader = new FileReader();
        reader.onload = function(e) {
          const csv = e.target.result;
          const rows = csv.split('\n');
          rows.forEach((row, rowIndex) => {
            const cols = row.split(',');
            cols.forEach((value, colIndex) => {
              if (rowIndex < 100 && colIndex < 26) {
                sheets[currentSheet].data[rowIndex] = sheets[currentSheet].data[rowIndex] || {};
                sheets[currentSheet].data[rowIndex][colIndex] = value.trim().replace(/^"|"$/g, '');
              }
            });
          });
          renderSpreadsheet();
          document.getElementById('fileName').value = file.name.replace(/\.[^/.]+$/, '');
          showToast(`Imported: ${file.name}`, 'success');
          saveToHistory();
        };
        reader.readAsText(file);
      } else if (['xlsx', 'xls'].includes(extension)) {
        if (typeof XLSX !== 'undefined') {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const workbook = XLSX.read(e.target.result, { type: 'array' });
              const sheetName = workbook.SheetNames[0];
              const worksheet = workbook.Sheets[sheetName];
              const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

              data.forEach((row, rowIndex) => {
                if (rowIndex < 100) {
                  row.forEach((value, colIndex) => {
                    if (colIndex < 26) {
                      sheets[currentSheet].data[rowIndex] = sheets[currentSheet].data[rowIndex] || {};
                      sheets[currentSheet].data[rowIndex][colIndex] = value;
                    }
                  });
                }
              });

              renderSpreadsheet();
              document.getElementById('fileName').value = file.name.replace(/\.[^/.]+$/, '');
              showToast(`Imported: ${file.name}`, 'success');
              saveToHistory();
            } catch (err) {
              showToast('Error reading Excel file', 'error');
              console.error(err);
            }
          };
          reader.readAsArrayBuffer(file);
        } else {
          showToast('Excel import not available', 'warning');
        }
      } else {
        showToast(`Unsupported file type: .${extension}`, 'error');
      }
    }

    // ==================== AUTO-SAVE ====================
    let autoSaveEnabled = localStorage.getItem('ninjacalc_autosave') !== 'false';
    let autoSaveInterval = null;
    let lastDataHash = '';

    function initAutoSave() {
      if (autoSaveEnabled) {
        lastDataHash = JSON.stringify(sheets);
        autoSaveInterval = setInterval(checkAutoSave, 30000);
      }
    }

    function checkAutoSave() {
      if (!autoSaveEnabled) return;
      const currentHash = JSON.stringify(sheets);
      if (currentHash !== lastDataHash) {
        performAutoSave();
        lastDataHash = currentHash;
      }
    }

    function performAutoSave() {
      const indicator = document.getElementById('autosaveIndicator');
      indicator.classList.add('visible');

      const docId = 'autosave_calc_' + (document.getElementById('fileName').value || 'untitled');
      const saveData = {
        sheets: sheets,
        timestamp: Date.now(),
        name: document.getElementById('fileName').value
      };
      localStorage.setItem(docId, JSON.stringify(saveData));

      setTimeout(() => {
        indicator.classList.remove('visible');
      }, 1500);
    }

    document.addEventListener('DOMContentLoaded', initAutoSave);

    // ==================== CONTEXT MENU ====================
    const contextMenu = document.getElementById('contextMenu');
    const spreadsheetArea = document.getElementById('spreadsheetArea');

    // Show context menu on right-click in spreadsheet
    spreadsheetArea.addEventListener('contextmenu', function(e) {
      e.preventDefault();

      // Position the menu
      const menuWidth = 220;
      const menuHeight = 450;
      let x = e.clientX;
      let y = e.clientY;

      // Keep menu in viewport
      if (x + menuWidth > window.innerWidth) {
        x = window.innerWidth - menuWidth - 10;
      }
      if (y + menuHeight > window.innerHeight) {
        y = window.innerHeight - menuHeight - 10;
      }

      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
      contextMenu.classList.add('visible');
    });

    // Hide context menu on click outside
    document.addEventListener('click', function(e) {
      if (!contextMenu.contains(e.target)) {
        contextMenu.classList.remove('visible');
      }
    });

    // Hide on scroll
    spreadsheetArea.addEventListener('scroll', function() {
      contextMenu.classList.remove('visible');
    });

    // Hide on escape
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        contextMenu.classList.remove('visible');
      }
    });

    function contextMenuAction(action) {
      contextMenu.classList.remove('visible');

      switch(action) {
        case 'cut':
          cutCells();
          break;
        case 'copy':
          copyCells();
          break;
        case 'paste':
          pasteCells();
          break;
        case 'pasteSpecial':
          showPasteSpecial();
          break;
        case 'insertRow':
          insertRow();
          break;
        case 'insertCol':
          insertColumn();
          break;
        case 'deleteRow':
          deleteRow();
          break;
        case 'deleteCol':
          deleteColumn();
          break;
        case 'clearContents':
          clearSelection();
          break;
        case 'clearFormats':
          clearCellFormatting();
          break;
        case 'formatCells':
          showFormatCells();
          break;
        case 'columnWidth':
          setColumnWidth();
          break;
        case 'rowHeight':
          setRowHeight();
          break;
        case 'addComment':
          addCellComment();
          break;
        case 'addToWatch':
          addToWatch();
          break;
        default:
          showToast('Action: ' + action, 'info');
      }
    }

    // Helper functions for context menu actions
    function showPasteSpecial() {
      const options = prompt('Paste Special Options:\n1. Values only\n2. Formulas only\n3. Formatting only\n\nEnter option number:', '1');
      if (options === '1') {
        pasteCells('values');
        showToast('Pasted values only', 'success');
      } else if (options === '2') {
        pasteCells('formulas');
        showToast('Pasted formulas only', 'success');
      } else if (options === '3') {
        pasteCells('formatting');
        showToast('Pasted formatting only', 'success');
      }
    }

    function clearCellFormatting() {
      if (selectedCell) {
        const cell = selectedCell;
        cell.style.cssText = '';
        cell.className = 'cell';
        showToast('Formatting cleared', 'success');
      }
    }

    function showFormatCells() {
      showConditionalFormatting();
    }

    function setColumnWidth() {
      const width = prompt('Enter column width (in pixels):', '100');
      if (width && !isNaN(width)) {
        const colIndex = getSelectedCol();
        if (colIndex >= 0) {
          const cells = document.querySelectorAll(`#spreadsheet td:nth-child(${colIndex + 2}), #spreadsheet th:nth-child(${colIndex + 2})`);
          cells.forEach(cell => {
            cell.style.width = width + 'px';
            cell.style.minWidth = width + 'px';
          });
          showToast(`Column width set to ${width}px`, 'success');
        }
      }
    }

    function setRowHeight() {
      const height = prompt('Enter row height (in pixels):', '24');
      if (height && !isNaN(height)) {
        const rowIndex = getSelectedRow();
        if (rowIndex >= 0) {
          const row = document.querySelector(`#spreadsheet tr:nth-child(${rowIndex + 2})`);
          if (row) {
            row.style.height = height + 'px';
            showToast(`Row height set to ${height}px`, 'success');
          }
        }
      }
    }

    function getSelectedCol() {
      if (!selectedCell) return -1;
      return parseInt(selectedCell.dataset.col);
    }

    function getSelectedRow() {
      if (!selectedCell) return -1;
      return parseInt(selectedCell.dataset.row);
    }

    function addCellComment() {
      if (!selectedCell) {
        showToast('Select a cell first', 'warning');
        return;
      }
      const comment = prompt('Enter comment:');
      if (comment) {
        const row = selectedCell.dataset.row;
        const col = selectedCell.dataset.col;
        const cellRef = getCellRef(parseInt(row), parseInt(col));
        addComment(cellRef, comment);
        showToast('Comment added', 'success');
      }
    }

    // ==================== FLOATING ACTION BUTTON ====================
    let fabOpen = false;

    function toggleFab() {
      fabOpen = !fabOpen;
      const fabMain = document.getElementById('fabMain');
      const fabMenu = document.getElementById('fabMenu');
      fabMain.classList.toggle('active', fabOpen);
      fabMenu.classList.toggle('visible', fabOpen);
    }

    document.addEventListener('click', function(e) {
      if (fabOpen && !e.target.closest('.fab-container')) {
        toggleFab();
      }
    });

    function showFormulaBuilder() {
      const formula = prompt('Enter formula (e.g., SUM(A1:A10), AVERAGE(B1:B5)):');
      if (formula && selectedCell) {
        selectedCell.value = formula.startsWith('=') ? formula : '=' + formula;
        const row = parseInt(selectedCell.dataset.row);
        const col = parseInt(selectedCell.dataset.col);
        updateCell(selectedCell, row, col);
        showToast('Formula applied', 'success');
      }
    }

    // ==================== GLOBAL SEARCH SPOTLIGHT ====================
    let spotlightSelectedIndex = 0;
    let spotlightItems = [];

    const spotlightActions = [
      { icon: 'üìÑ', title: 'New Spreadsheet', desc: 'Create a blank spreadsheet', action: () => newSpreadsheet(), shortcut: 'Ctrl+N' },
      { icon: 'üíæ', title: 'Save', desc: 'Save current spreadsheet', action: () => saveSpreadsheet(), shortcut: 'Ctrl+S' },
      { icon: 'üìÇ', title: 'Open', desc: 'Open existing spreadsheet', action: () => showOpenDialog && showOpenDialog(), shortcut: 'Ctrl+O' },
      { icon: 'üñ®Ô∏è', title: 'Print', desc: 'Print spreadsheet', action: () => window.print(), shortcut: 'Ctrl+P' },
      { icon: 'üìã', title: 'Export Excel', desc: 'Export as XLSX', action: () => exportToExcel() },
      { icon: 'üìÑ', title: 'Export CSV', desc: 'Export as CSV', action: () => exportToCSV() },
      { icon: 'üìä', title: 'Insert Chart', desc: 'Create a chart', action: () => insertChart() },
      { icon: 'üåô', title: 'Toggle Dark Mode', desc: 'Switch theme', action: () => toggleDarkMode() },
      { icon: '‚ûï', title: 'Add Sheet', desc: 'Add new worksheet', action: () => addSheet() },
      { icon: 'üî¢', title: 'Format Numbers', desc: 'Number formatting', action: () => showNumberFormat && showNumberFormat() },
      { icon: '‚å®Ô∏è', title: 'Keyboard Shortcuts', desc: 'View all shortcuts', action: () => showKeyboardShortcuts && showKeyboardShortcuts(), shortcut: 'Ctrl+/' },
    ];

    const spotlightFunctions = [
      { icon: 'Œ£', title: 'SUM', desc: 'Add numbers: =SUM(A1:A10)', action: () => insertFunction('SUM') },
      { icon: 'xÃÑ', title: 'AVERAGE', desc: 'Calculate average: =AVERAGE(A1:A10)', action: () => insertFunction('AVERAGE') },
      { icon: '#', title: 'COUNT', desc: 'Count cells: =COUNT(A1:A10)', action: () => insertFunction('COUNT') },
      { icon: '‚Üë', title: 'MAX', desc: 'Find maximum: =MAX(A1:A10)', action: () => insertFunction('MAX') },
      { icon: '‚Üì', title: 'MIN', desc: 'Find minimum: =MIN(A1:A10)', action: () => insertFunction('MIN') },
      { icon: '?', title: 'IF', desc: 'Conditional: =IF(A1>5,"Yes","No")', action: () => insertFunction('IF') },
      { icon: 'üîó', title: 'CONCATENATE', desc: 'Join text: =CONCATENATE(A1,B1)', action: () => insertFunction('CONCATENATE') },
      { icon: '%', title: 'ROUND', desc: 'Round number: =ROUND(A1,2)', action: () => insertFunction('ROUND') },
    ];

    function insertFunction(funcName) {
      if (selectedCell) {
        selectedCell.focus();
        selectedCell.value = `=${funcName}()`;
        selectedCell.setSelectionRange(selectedCell.value.length - 1, selectedCell.value.length - 1);
        showToast(`${funcName} function inserted`, 'info');
      } else {
        showToast('Select a cell first', 'warning');
      }
      hideSpotlight();
    }

    function showSpotlight() {
      document.getElementById('spotlightOverlay').classList.add('visible');
      document.getElementById('spotlightInput').value = '';
      document.getElementById('spotlightInput').focus();
      spotlightSelectedIndex = 0;
      renderSpotlight('');
    }

    function hideSpotlight() {
      document.getElementById('spotlightOverlay').classList.remove('visible');
    }

    function renderSpotlight(query) {
      const actionsContainer = document.getElementById('spotlightActions');
      const functionsContainer = document.getElementById('spotlightFunctions');
      const q = query.toLowerCase();

      const filteredActions = spotlightActions
        .filter(a => !q || a.title.toLowerCase().includes(q) || a.desc.toLowerCase().includes(q))
        .slice(0, 6);

      const filteredFunctions = spotlightFunctions
        .filter(f => !q || f.title.toLowerCase().includes(q) || f.desc.toLowerCase().includes(q))
        .slice(0, 6);

      spotlightItems = [...filteredActions, ...filteredFunctions];

      actionsContainer.innerHTML = filteredActions.map((item, i) => `
        <div class="spotlight-item ${i === spotlightSelectedIndex ? 'selected' : ''}" onclick="executeSpotlightItem(${i})">
          <span class="spotlight-item-icon">${item.icon}</span>
          <div class="spotlight-item-content">
            <div class="spotlight-item-title">${item.title}</div>
            <div class="spotlight-item-desc">${item.desc}</div>
          </div>
          ${item.shortcut ? `<span class="spotlight-item-shortcut">${item.shortcut}</span>` : ''}
        </div>
      `).join('') || '<div style="padding: 10px 16px; color: #888;">No actions found</div>';

      functionsContainer.innerHTML = filteredFunctions.map((item, i) => `
        <div class="spotlight-item ${(i + filteredActions.length) === spotlightSelectedIndex ? 'selected' : ''}" onclick="executeSpotlightItem(${i + filteredActions.length})">
          <span class="spotlight-item-icon">${item.icon}</span>
          <div class="spotlight-item-content">
            <div class="spotlight-item-title">${item.title}</div>
            <div class="spotlight-item-desc">${item.desc}</div>
          </div>
        </div>
      `).join('') || '<div style="padding: 10px 16px; color: #888;">No functions found</div>';
    }

    function executeSpotlightItem(index) {
      if (spotlightItems[index] && spotlightItems[index].action) {
        spotlightItems[index].action();
      }
      hideSpotlight();
    }

    function handleSpotlightKeydown(e) {
      if (e.key === 'Escape') {
        hideSpotlight();
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        spotlightSelectedIndex = Math.min(spotlightSelectedIndex + 1, spotlightItems.length - 1);
        renderSpotlight(document.getElementById('spotlightInput').value);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        spotlightSelectedIndex = Math.max(spotlightSelectedIndex - 1, 0);
        renderSpotlight(document.getElementById('spotlightInput').value);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        executeSpotlightItem(spotlightSelectedIndex);
      }
    }

    // Ctrl+K to open spotlight
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.key === 'k') {
        e.preventDefault();
        showSpotlight();
      }
    });

    // ==================== STATUS BAR INTERACTIONS ====================
    let currentZoom = 100;
    let calcMode = 'auto';

    // Auto-save Status Toggle
    function toggleAutoSaveStatus() {
      autoSaveEnabled = !autoSaveEnabled;
      localStorage.setItem('ninjacalc_autosave', autoSaveEnabled);

      const icon = document.getElementById('autoSaveStatusIcon');
      const text = document.getElementById('autoSaveStatusText');

      if (autoSaveEnabled) {
        icon.textContent = 'üíæ';
        text.textContent = 'Auto-save On';
        initAutoSave();
        showToast('Auto-save enabled', 'success');
      } else {
        icon.textContent = '‚è∏Ô∏è';
        text.textContent = 'Auto-save Off';
        if (autoSaveInterval) {
          clearInterval(autoSaveInterval);
          autoSaveInterval = null;
        }
        showToast('Auto-save disabled', 'info');
      }
    }

    // Zoom Popup
    function showZoomPopup() {
      hideAllStatusPopups();
      document.getElementById('zoomPopup').classList.add('visible');
      document.getElementById('zoomSlider').value = currentZoom;
      updateZoomPresetButtons();
    }

    function hideZoomPopup() {
      document.getElementById('zoomPopup').classList.remove('visible');
    }

    function setZoomFromSlider(value) {
      setZoomLevel(parseInt(value));
    }

    function setZoomLevel(level) {
      currentZoom = level;
      document.getElementById('statusZoom').textContent = level + '%';
      document.getElementById('zoomSlider').value = level;

      const spreadsheetArea = document.getElementById('spreadsheetArea');
      if (spreadsheetArea) {
        spreadsheetArea.style.transform = `scale(${level / 100})`;
        spreadsheetArea.style.transformOrigin = 'top left';
      }

      updateZoomPresetButtons();
      localStorage.setItem('ninjacalc_zoom', level);
    }

    function updateZoomPresetButtons() {
      document.querySelectorAll('.zoom-preset-btn').forEach(btn => {
        const btnLevel = parseInt(btn.textContent);
        btn.classList.toggle('active', btnLevel === currentZoom);
      });
    }

    // Calculation Mode Popup
    function showCalcModePopup() {
      hideAllStatusPopups();
      document.getElementById('calcModePopup').classList.add('visible');
    }

    function hideCalcModePopup() {
      document.getElementById('calcModePopup').classList.remove('visible');
    }

    function setCalcMode(mode) {
      calcMode = mode;
      document.querySelectorAll('.calc-mode-option').forEach(opt => {
        opt.classList.toggle('active', opt.textContent.toLowerCase().includes(mode));
      });

      if (mode === 'auto') {
        document.getElementById('calcModeDisplay').textContent = 'Auto-Calculate';
        showToast('Automatic calculation enabled', 'success');
      } else {
        document.getElementById('calcModeDisplay').textContent = 'Manual (F9)';
        showToast('Manual calculation mode - Press F9 to recalculate', 'info');
      }

      localStorage.setItem('ninjacalc_calcmode', mode);
      hideCalcModePopup();
    }

    // Go To Cell
    function goToCell() {
      const cellRef = prompt('Go to cell (e.g., A1, B5, Z100):');
      if (cellRef) {
        const match = cellRef.toUpperCase().match(/^([A-Z]+)(\d+)$/);
        if (match) {
          const col = match[1].charCodeAt(0) - 65;
          const row = parseInt(match[2]) - 1;

          const cell = document.querySelector(`input[data-row="${row}"][data-col="${col}"]`);
          if (cell) {
            cell.focus();
            cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            showToast(`Navigated to ${cellRef.toUpperCase()}`, 'info');
          } else {
            showToast('Cell not found in current view', 'warning');
          }
        } else {
          showToast('Invalid cell reference', 'error');
        }
      }
    }

    // Selection Statistics
    function showSelectionStats() {
      const sum = document.getElementById('sumDisplay').textContent;
      const avg = document.getElementById('avgDisplay').textContent;
      const count = document.getElementById('countDisplay').textContent;
      const cells = document.getElementById('cellCount').textContent;

      showToast(`Selection: ${cells} cells | Sum: ${sum} | Average: ${avg} | Count: ${count}`, 'info');
    }

    // Helper to hide all popups
    function hideAllStatusPopups() {
      hideZoomPopup();
      hideCalcModePopup();
    }

    // Close popups when clicking outside
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.zoom-popup') && !e.target.closest('.status-bar-item[onclick*="showZoomPopup"]')) {
        hideZoomPopup();
      }
      if (!e.target.closest('.calc-mode-popup') && !e.target.closest('.status-bar-item[onclick*="showCalcModePopup"]')) {
        hideCalcModePopup();
      }
    });

    // Load saved preferences
    document.addEventListener('DOMContentLoaded', function() {
      // Load zoom
      const savedZoom = localStorage.getItem('ninjacalc_zoom');
      if (savedZoom) {
        setZoomLevel(parseInt(savedZoom));
      }

      // Load calc mode
      const savedCalcMode = localStorage.getItem('ninjacalc_calcmode');
      if (savedCalcMode) {
        setCalcMode(savedCalcMode);
      }

      // Load auto-save status display
      const savedAutoSave = localStorage.getItem('ninjacalc_autosave');
      if (savedAutoSave === 'false') {
        document.getElementById('autoSaveStatusIcon').textContent = '‚è∏Ô∏è';
        document.getElementById('autoSaveStatusText').textContent = 'Auto-save Off';
      }
    });

    // F9 to recalculate in manual mode
    document.addEventListener('keydown', function(e) {
      if (e.key === 'F9' && calcMode === 'manual') {
        e.preventDefault();
        renderSpreadsheet();
        showToast('Spreadsheet recalculated', 'success');
      }
    });

    // ==================== FORMULA AUTOCOMPLETE ====================
    const formulaDatabase = [
      // Math & Trig
      { name: 'SUM', syntax: '=SUM(number1, [number2], ...)', desc: 'Adds all numbers in a range', category: 'Math', icon: 'Œ£', iconClass: 'math' },
      { name: 'AVERAGE', syntax: '=AVERAGE(number1, [number2], ...)', desc: 'Returns the average of numbers', category: 'Math', icon: 'xÃÑ', iconClass: 'math' },
      { name: 'COUNT', syntax: '=COUNT(value1, [value2], ...)', desc: 'Counts cells with numbers', category: 'Math', icon: '#', iconClass: 'math' },
      { name: 'COUNTA', syntax: '=COUNTA(value1, [value2], ...)', desc: 'Counts non-empty cells', category: 'Math', icon: '#', iconClass: 'math' },
      { name: 'MAX', syntax: '=MAX(number1, [number2], ...)', desc: 'Returns the largest value', category: 'Math', icon: '‚Üë', iconClass: 'math' },
      { name: 'MIN', syntax: '=MIN(number1, [number2], ...)', desc: 'Returns the smallest value', category: 'Math', icon: '‚Üì', iconClass: 'math' },
      { name: 'ABS', syntax: '=ABS(number)', desc: 'Returns absolute value', category: 'Math', icon: '||', iconClass: 'math' },
      { name: 'ROUND', syntax: '=ROUND(number, num_digits)', desc: 'Rounds to specified digits', category: 'Math', icon: '‚âà', iconClass: 'math' },
      { name: 'ROUNDUP', syntax: '=ROUNDUP(number, num_digits)', desc: 'Rounds up away from zero', category: 'Math', icon: '‚åà', iconClass: 'math' },
      { name: 'ROUNDDOWN', syntax: '=ROUNDDOWN(number, num_digits)', desc: 'Rounds down toward zero', category: 'Math', icon: '‚åä', iconClass: 'math' },
      { name: 'CEILING', syntax: '=CEILING(number, significance)', desc: 'Rounds up to multiple', category: 'Math', icon: '‚åà', iconClass: 'math' },
      { name: 'FLOOR', syntax: '=FLOOR(number, significance)', desc: 'Rounds down to multiple', category: 'Math', icon: '‚åä', iconClass: 'math' },
      { name: 'SQRT', syntax: '=SQRT(number)', desc: 'Returns square root', category: 'Math', icon: '‚àö', iconClass: 'math' },
      { name: 'POWER', syntax: '=POWER(number, power)', desc: 'Returns number raised to power', category: 'Math', icon: 'x‚Åø', iconClass: 'math' },
      { name: 'MOD', syntax: '=MOD(number, divisor)', desc: 'Returns remainder after division', category: 'Math', icon: '%', iconClass: 'math' },
      { name: 'PI', syntax: '=PI()', desc: 'Returns value of œÄ', category: 'Math', icon: 'œÄ', iconClass: 'math' },
      { name: 'RAND', syntax: '=RAND()', desc: 'Returns random number 0-1', category: 'Math', icon: '?', iconClass: 'math' },
      { name: 'RANDBETWEEN', syntax: '=RANDBETWEEN(bottom, top)', desc: 'Random integer between values', category: 'Math', icon: '?', iconClass: 'math' },

      // Statistical
      { name: 'MEDIAN', syntax: '=MEDIAN(number1, [number2], ...)', desc: 'Returns the median', category: 'Statistics', icon: 'M', iconClass: 'stat' },
      { name: 'MODE', syntax: '=MODE(number1, [number2], ...)', desc: 'Returns most frequent value', category: 'Statistics', icon: 'M', iconClass: 'stat' },
      { name: 'STDEV', syntax: '=STDEV(number1, [number2], ...)', desc: 'Standard deviation (sample)', category: 'Statistics', icon: 'œÉ', iconClass: 'stat' },
      { name: 'VAR', syntax: '=VAR(number1, [number2], ...)', desc: 'Variance (sample)', category: 'Statistics', icon: 's¬≤', iconClass: 'stat' },
      { name: 'LARGE', syntax: '=LARGE(array, k)', desc: 'Returns k-th largest value', category: 'Statistics', icon: 'k‚Üë', iconClass: 'stat' },
      { name: 'SMALL', syntax: '=SMALL(array, k)', desc: 'Returns k-th smallest value', category: 'Statistics', icon: 'k‚Üì', iconClass: 'stat' },
      { name: 'COUNTIF', syntax: '=COUNTIF(range, criteria)', desc: 'Counts cells matching criteria', category: 'Statistics', icon: '#?', iconClass: 'stat' },
      { name: 'SUMIF', syntax: '=SUMIF(range, criteria, [sum_range])', desc: 'Sums cells matching criteria', category: 'Statistics', icon: 'Œ£?', iconClass: 'stat' },
      { name: 'AVERAGEIF', syntax: '=AVERAGEIF(range, criteria, [avg_range])', desc: 'Averages cells matching criteria', category: 'Statistics', icon: 'xÃÑ?', iconClass: 'stat' },

      // Text
      { name: 'CONCAT', syntax: '=CONCAT(text1, [text2], ...)', desc: 'Joins text strings', category: 'Text', icon: 'AB', iconClass: 'text' },
      { name: 'LEFT', syntax: '=LEFT(text, [num_chars])', desc: 'Returns leftmost characters', category: 'Text', icon: '‚Üê', iconClass: 'text' },
      { name: 'RIGHT', syntax: '=RIGHT(text, [num_chars])', desc: 'Returns rightmost characters', category: 'Text', icon: '‚Üí', iconClass: 'text' },
      { name: 'MID', syntax: '=MID(text, start_num, num_chars)', desc: 'Returns middle characters', category: 'Text', icon: '‚Üî', iconClass: 'text' },
      { name: 'LEN', syntax: '=LEN(text)', desc: 'Returns text length', category: 'Text', icon: '#', iconClass: 'text' },
      { name: 'UPPER', syntax: '=UPPER(text)', desc: 'Converts to uppercase', category: 'Text', icon: 'AA', iconClass: 'text' },
      { name: 'LOWER', syntax: '=LOWER(text)', desc: 'Converts to lowercase', category: 'Text', icon: 'aa', iconClass: 'text' },
      { name: 'PROPER', syntax: '=PROPER(text)', desc: 'Capitalizes each word', category: 'Text', icon: 'Aa', iconClass: 'text' },
      { name: 'TRIM', syntax: '=TRIM(text)', desc: 'Removes extra spaces', category: 'Text', icon: '‚åß', iconClass: 'text' },
      { name: 'SUBSTITUTE', syntax: '=SUBSTITUTE(text, old, new, [instance])', desc: 'Replaces text', category: 'Text', icon: '‚Üî', iconClass: 'text' },
      { name: 'FIND', syntax: '=FIND(find_text, within_text, [start])', desc: 'Finds text position (case-sensitive)', category: 'Text', icon: 'üîç', iconClass: 'text' },
      { name: 'SEARCH', syntax: '=SEARCH(find_text, within_text, [start])', desc: 'Finds text position (case-insensitive)', category: 'Text', icon: 'üîé', iconClass: 'text' },
      { name: 'REPT', syntax: '=REPT(text, number_times)', desc: 'Repeats text n times', category: 'Text', icon: '√ón', iconClass: 'text' },
      { name: 'TEXT', syntax: '=TEXT(value, format_text)', desc: 'Formats number as text', category: 'Text', icon: 'Tx', iconClass: 'text' },
      { name: 'VALUE', syntax: '=VALUE(text)', desc: 'Converts text to number', category: 'Text', icon: '‚Ññ', iconClass: 'text' },

      // Logic
      { name: 'IF', syntax: '=IF(condition, value_if_true, value_if_false)', desc: 'Conditional logic', category: 'Logic', icon: '?:', iconClass: 'logic' },
      { name: 'AND', syntax: '=AND(logical1, [logical2], ...)', desc: 'Returns TRUE if all true', category: 'Logic', icon: '&&', iconClass: 'logic' },
      { name: 'OR', syntax: '=OR(logical1, [logical2], ...)', desc: 'Returns TRUE if any true', category: 'Logic', icon: '||', iconClass: 'logic' },
      { name: 'NOT', syntax: '=NOT(logical)', desc: 'Reverses logic', category: 'Logic', icon: '!', iconClass: 'logic' },
      { name: 'IFS', syntax: '=IFS(condition1, value1, [condition2, value2], ...)', desc: 'Multiple conditions', category: 'Logic', icon: '?!', iconClass: 'logic' },
      { name: 'IFERROR', syntax: '=IFERROR(value, value_if_error)', desc: 'Returns value if no error', category: 'Logic', icon: '‚ö†', iconClass: 'logic' },
      { name: 'ISBLANK', syntax: '=ISBLANK(value)', desc: 'Checks if cell is empty', category: 'Logic', icon: '‚àÖ', iconClass: 'logic' },
      { name: 'ISNUMBER', syntax: '=ISNUMBER(value)', desc: 'Checks if value is number', category: 'Logic', icon: '#?', iconClass: 'logic' },
      { name: 'ISTEXT', syntax: '=ISTEXT(value)', desc: 'Checks if value is text', category: 'Logic', icon: 'T?', iconClass: 'logic' },

      // Lookup
      { name: 'VLOOKUP', syntax: '=VLOOKUP(lookup_value, table, col_index, [range_lookup])', desc: 'Vertical lookup', category: 'Lookup', icon: '‚Üì', iconClass: 'lookup' },
      { name: 'HLOOKUP', syntax: '=HLOOKUP(lookup_value, table, row_index, [range_lookup])', desc: 'Horizontal lookup', category: 'Lookup', icon: '‚Üí', iconClass: 'lookup' },
      { name: 'INDEX', syntax: '=INDEX(array, row_num, [col_num])', desc: 'Returns value at position', category: 'Lookup', icon: '[]', iconClass: 'lookup' },
      { name: 'MATCH', syntax: '=MATCH(lookup_value, lookup_array, [match_type])', desc: 'Returns position of value', category: 'Lookup', icon: '=?', iconClass: 'lookup' },
      { name: 'CHOOSE', syntax: '=CHOOSE(index_num, value1, [value2], ...)', desc: 'Chooses from list by index', category: 'Lookup', icon: '‚òê', iconClass: 'lookup' },
      { name: 'LOOKUP', syntax: '=LOOKUP(lookup_value, lookup_vector, [result_vector])', desc: 'Looks up value in range', category: 'Lookup', icon: '‚ü≥', iconClass: 'lookup' },

      // Date & Time
      { name: 'TODAY', syntax: '=TODAY()', desc: 'Returns current date', category: 'Date', icon: 'üìÖ', iconClass: 'date' },
      { name: 'NOW', syntax: '=NOW()', desc: 'Returns current date and time', category: 'Date', icon: 'üïê', iconClass: 'date' },
      { name: 'DATE', syntax: '=DATE(year, month, day)', desc: 'Creates date from parts', category: 'Date', icon: 'üìÜ', iconClass: 'date' },
      { name: 'YEAR', syntax: '=YEAR(date)', desc: 'Extracts year from date', category: 'Date', icon: 'Y', iconClass: 'date' },
      { name: 'MONTH', syntax: '=MONTH(date)', desc: 'Extracts month from date', category: 'Date', icon: 'M', iconClass: 'date' },
      { name: 'DAY', syntax: '=DAY(date)', desc: 'Extracts day from date', category: 'Date', icon: 'D', iconClass: 'date' },
      { name: 'WEEKDAY', syntax: '=WEEKDAY(date, [return_type])', desc: 'Returns day of week', category: 'Date', icon: 'W', iconClass: 'date' },
      { name: 'HOUR', syntax: '=HOUR(time)', desc: 'Extracts hour from time', category: 'Date', icon: 'H', iconClass: 'date' },
      { name: 'MINUTE', syntax: '=MINUTE(time)', desc: 'Extracts minute from time', category: 'Date', icon: 'm', iconClass: 'date' },
      { name: 'SECOND', syntax: '=SECOND(time)', desc: 'Extracts second from time', category: 'Date', icon: 's', iconClass: 'date' },
      { name: 'DATEDIF', syntax: '=DATEDIF(start_date, end_date, unit)', desc: 'Calculates date difference', category: 'Date', icon: 'Œî', iconClass: 'date' },
      { name: 'EDATE', syntax: '=EDATE(start_date, months)', desc: 'Date plus/minus months', category: 'Date', icon: '+M', iconClass: 'date' },
      { name: 'EOMONTH', syntax: '=EOMONTH(start_date, months)', desc: 'End of month date', category: 'Date', icon: '‚åÅ', iconClass: 'date' },
    ];

    let autocompleteSelectedIndex = -1;
    let autocompleteVisible = false;
    let autocompleteMatches = [];

    function handleFormulaAutocomplete(e) {
      const input = e.target;
      const value = input.value;
      const dropdown = document.getElementById('formulaAutocomplete');

      // Only show autocomplete when typing a formula (starts with =)
      if (!value.startsWith('=')) {
        hideFormulaAutocomplete();
        return;
      }

      // Get the current function being typed (after = or after a comma/parenthesis)
      const formulaPart = value.substring(1); // Remove the =
      const lastFuncMatch = formulaPart.match(/([A-Za-z]+)$/);

      if (!lastFuncMatch || lastFuncMatch[1].length < 1) {
        hideFormulaAutocomplete();
        return;
      }

      const searchTerm = lastFuncMatch[1].toUpperCase();

      // Find matching formulas
      autocompleteMatches = formulaDatabase.filter(f =>
        f.name.startsWith(searchTerm) || f.name.includes(searchTerm)
      ).sort((a, b) => {
        // Prioritize exact prefix matches
        const aStarts = a.name.startsWith(searchTerm) ? 0 : 1;
        const bStarts = b.name.startsWith(searchTerm) ? 0 : 1;
        if (aStarts !== bStarts) return aStarts - bStarts;
        return a.name.localeCompare(b.name);
      }).slice(0, 10); // Limit to 10 results

      if (autocompleteMatches.length === 0) {
        hideFormulaAutocomplete();
        return;
      }

      // Render dropdown
      dropdown.innerHTML = autocompleteMatches.map((f, i) => `
        <div class="formula-autocomplete-item ${i === autocompleteSelectedIndex ? 'selected' : ''}"
             onclick="selectFormulaAutocomplete(${i})"
             onmouseenter="autocompleteSelectedIndex = ${i}; updateAutocompleteSelection()">
          <div class="formula-icon ${f.iconClass}">${f.icon}</div>
          <div class="formula-info">
            <div class="formula-name">${f.name}</div>
            <div class="formula-syntax">${f.syntax}</div>
            <div class="formula-desc">${f.desc}</div>
          </div>
          <span class="formula-category">${f.category}</span>
        </div>
      `).join('');

      dropdown.classList.add('visible');
      autocompleteVisible = true;
      autocompleteSelectedIndex = 0;
      updateAutocompleteSelection();
    }

    function hideFormulaAutocomplete() {
      const dropdown = document.getElementById('formulaAutocomplete');
      dropdown.classList.remove('visible');
      autocompleteVisible = false;
      autocompleteSelectedIndex = -1;
      autocompleteMatches = [];
    }

    function updateAutocompleteSelection() {
      const items = document.querySelectorAll('.formula-autocomplete-item');
      items.forEach((item, i) => {
        item.classList.toggle('selected', i === autocompleteSelectedIndex);
      });

      // Scroll selected item into view
      if (autocompleteSelectedIndex >= 0 && items[autocompleteSelectedIndex]) {
        items[autocompleteSelectedIndex].scrollIntoView({ block: 'nearest' });
      }
    }

    function selectFormulaAutocomplete(index) {
      if (index < 0 || index >= autocompleteMatches.length) return;

      const formula = autocompleteMatches[index];
      const input = document.getElementById('formulaInput');
      const value = input.value;

      // Replace the partial function name with the complete one
      const lastFuncMatch = value.match(/([A-Za-z]+)$/);
      if (lastFuncMatch) {
        const beforeFunc = value.substring(0, value.length - lastFuncMatch[1].length);
        input.value = beforeFunc + formula.name + '(';
        input.focus();

        // Position cursor inside the parentheses
        const cursorPos = input.value.length;
        input.setSelectionRange(cursorPos, cursorPos);
      }

      hideFormulaAutocomplete();
    }

    // Handle keyboard navigation in autocomplete
    const originalHandleFormulaInput = handleFormulaInput;
    handleFormulaInput = function(e) {
      if (autocompleteVisible) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, autocompleteMatches.length - 1);
          updateAutocompleteSelection();
          return;
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, 0);
          updateAutocompleteSelection();
          return;
        } else if (e.key === 'Enter' || e.key === 'Tab') {
          if (autocompleteSelectedIndex >= 0) {
            e.preventDefault();
            selectFormulaAutocomplete(autocompleteSelectedIndex);
            return;
          }
        } else if (e.key === 'Escape') {
          hideFormulaAutocomplete();
          return;
        }
      }

      // Call original handler for other keys
      if (typeof originalHandleFormulaInput === 'function') {
        originalHandleFormulaInput(e);
      }
    };

    // Close autocomplete when clicking outside
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.formula-bar')) {
        hideFormulaAutocomplete();
      }
    });

    // ==================== FORMULA RANGE HIGHLIGHTING ====================
    const rangeHighlightColors = ['formula-ref-1', 'formula-ref-2', 'formula-ref-3', 'formula-ref-4', 'formula-ref-5', 'formula-ref-6'];

    function clearFormulaHighlights() {
      rangeHighlightColors.forEach(cls => {
        document.querySelectorAll('.' + cls).forEach(el => el.classList.remove(cls));
      });
    }

    function highlightFormulaRanges(formulaText) {
      clearFormulaHighlights();
      if (!formulaText || !formulaText.startsWith('=')) return;

      // Find all cell references and ranges in the formula
      const cellPattern = /([A-Z]+)(\d+)/gi;
      const rangePattern = /([A-Z]+\d+):([A-Z]+\d+)/gi;

      const references = [];

      // Find ranges first (e.g., A1:B10)
      let rangeMatch;
      while ((rangeMatch = rangePattern.exec(formulaText)) !== null) {
        references.push({ type: 'range', start: rangeMatch[1].toUpperCase(), end: rangeMatch[2].toUpperCase() });
      }

      // Find single cell references
      const formulaWithoutRanges = formulaText.replace(rangePattern, '');
      let cellMatch;
      while ((cellMatch = cellPattern.exec(formulaWithoutRanges)) !== null) {
        const cellRef = cellMatch[0].toUpperCase();
        // Check if this cell is not already part of a range
        if (!references.some(r => r.type === 'range' && isCellInRange(cellRef, r.start, r.end))) {
          references.push({ type: 'cell', ref: cellRef });
        }
      }

      // Apply highlighting
      references.forEach((ref, index) => {
        const colorClass = rangeHighlightColors[index % rangeHighlightColors.length];

        if (ref.type === 'cell') {
          highlightCell(ref.ref, colorClass);
        } else if (ref.type === 'range') {
          highlightRange(ref.start, ref.end, colorClass);
        }
      });
    }

    function highlightCell(cellRef, colorClass) {
      const cell = document.querySelector(`[data-cell="${cellRef}"]`);
      if (cell) {
        cell.classList.add(colorClass);
      }
    }

    function highlightRange(startRef, endRef, colorClass) {
      const startCol = startRef.match(/[A-Z]+/)[0];
      const startRow = parseInt(startRef.match(/\d+/)[0]);
      const endCol = endRef.match(/[A-Z]+/)[0];
      const endRow = parseInt(endRef.match(/\d+/)[0]);

      const startColNum = colToNum(startCol);
      const endColNum = colToNum(endCol);

      const minCol = Math.min(startColNum, endColNum);
      const maxCol = Math.max(startColNum, endColNum);
      const minRow = Math.min(startRow, endRow);
      const maxRow = Math.max(startRow, endRow);

      for (let row = minRow; row <= maxRow; row++) {
        for (let col = minCol; col <= maxCol; col++) {
          const cellRef = numToCol(col) + row;
          highlightCell(cellRef, colorClass);
        }
      }
    }

    function isCellInRange(cellRef, startRef, endRef) {
      const cellCol = colToNum(cellRef.match(/[A-Z]+/)[0]);
      const cellRow = parseInt(cellRef.match(/\d+/)[0]);

      const startCol = colToNum(startRef.match(/[A-Z]+/)[0]);
      const startRow = parseInt(startRef.match(/\d+/)[0]);
      const endCol = colToNum(endRef.match(/[A-Z]+/)[0]);
      const endRow = parseInt(endRef.match(/\d+/)[0]);

      return cellCol >= Math.min(startCol, endCol) &&
             cellCol <= Math.max(startCol, endCol) &&
             cellRow >= Math.min(startRow, endRow) &&
             cellRow <= Math.max(startRow, endRow);
    }

    function colToNum(col) {
      let num = 0;
      for (let i = 0; i < col.length; i++) {
        num = num * 26 + (col.charCodeAt(i) - 64);
      }
      return num;
    }

    function numToCol(num) {
      let col = '';
      while (num > 0) {
        num--;
        col = String.fromCharCode(65 + (num % 26)) + col;
        num = Math.floor(num / 26);
      }
      return col;
    }

    // Hook into formula input to highlight ranges as user types
    document.getElementById('formulaInput').addEventListener('input', function(e) {
      highlightFormulaRanges(e.target.value);
    });

    document.getElementById('formulaInput').addEventListener('focus', function(e) {
      highlightFormulaRanges(e.target.value);
    });

    document.getElementById('formulaInput').addEventListener('blur', function(e) {
      // Delay clearing to allow clicking on cells
      setTimeout(clearFormulaHighlights, 200);
    });

    // ==================== ERROR TOOLTIPS ====================
    const errorExplanations = {
      '#DIV/0!': {
        title: '#DIV/0! - Division by Zero',
        desc: 'This error occurs when a formula tries to divide a number by zero or an empty cell.',
        fix: 'Check that the divisor cell is not empty or zero. Use =IFERROR(A1/B1, 0) to handle this gracefully.'
      },
      '#VALUE!': {
        title: '#VALUE! - Wrong Value Type',
        desc: 'This error occurs when a formula expects a number but receives text, or vice versa.',
        fix: 'Check that all referenced cells contain the correct data type. Use VALUE() to convert text to numbers.'
      },
      '#REF!': {
        title: '#REF! - Invalid Reference',
        desc: 'This error occurs when a formula refers to a cell that has been deleted or is invalid.',
        fix: 'Check if you deleted rows/columns that were referenced. Update the formula with valid cell references.'
      },
      '#NAME?': {
        title: '#NAME? - Unrecognized Name',
        desc: 'This error occurs when a formula contains a function name or range name that is not recognized.',
        fix: 'Check spelling of function names. Make sure text strings are enclosed in quotes.'
      },
      '#NUM!': {
        title: '#NUM! - Invalid Number',
        desc: 'This error occurs when a formula produces a number too large/small or an invalid numeric operation.',
        fix: 'Check for invalid arguments like negative numbers in SQRT() or very large calculations.'
      },
      '#N/A': {
        title: '#N/A - Value Not Available',
        desc: 'This error occurs when a lookup function cannot find the requested value.',
        fix: 'Verify the lookup value exists in the range. Check for extra spaces or formatting differences.'
      },
      '#NULL!': {
        title: '#NULL! - Null Intersection',
        desc: 'This error occurs when two ranges that should intersect do not have any common cells.',
        fix: 'Check range references for correct syntax. Use comma (,) for union or colon (:) for range.'
      },
      '#ERROR!': {
        title: '#ERROR! - General Error',
        desc: 'This error indicates a general problem with the formula that could not be evaluated.',
        fix: 'Review the formula syntax and ensure all functions are properly closed with parentheses.'
      },
      '#CIRCULAR': {
        title: '#CIRCULAR - Circular Reference',
        desc: 'This error occurs when a formula refers to its own cell, creating an infinite loop.',
        fix: 'Remove the self-reference from the formula. A cell cannot depend on itself.'
      }
    };

    let errorTooltipTimeout = null;

    function showErrorTooltip(cell, errorType, x, y) {
      const tooltip = document.getElementById('errorTooltip');
      const info = errorExplanations[errorType] || errorExplanations['#ERROR!'];

      document.getElementById('errorTooltipTitle').textContent = info.title;
      document.getElementById('errorTooltipDesc').textContent = info.desc;
      document.getElementById('errorTooltipFix').innerHTML = `<strong>Tip:</strong> ${info.fix}`;

      // Position tooltip
      const tooltipWidth = 320;
      const tooltipHeight = 150;
      let left = x + 10;
      let top = y + 10;

      // Keep tooltip within viewport
      if (left + tooltipWidth > window.innerWidth) {
        left = x - tooltipWidth - 10;
      }
      if (top + tooltipHeight > window.innerHeight) {
        top = y - tooltipHeight - 10;
      }

      tooltip.style.left = Math.max(10, left) + 'px';
      tooltip.style.top = Math.max(10, top) + 'px';
      tooltip.classList.add('visible');
    }

    function hideErrorTooltip() {
      document.getElementById('errorTooltip').classList.remove('visible');
    }

    // Add hover handlers to cells with errors
    document.addEventListener('mouseover', function(e) {
      const cell = e.target.closest('.cell.error');
      if (cell) {
        const content = cell.textContent.trim();
        const errorMatch = content.match(/#[A-Z!/0?]+/);
        if (errorMatch) {
          clearTimeout(errorTooltipTimeout);
          errorTooltipTimeout = setTimeout(() => {
            showErrorTooltip(cell, errorMatch[0], e.clientX, e.clientY);
          }, 400);
        }
      }
    });

    document.addEventListener('mouseout', function(e) {
      const cell = e.target.closest('.cell.error');
      if (cell) {
        clearTimeout(errorTooltipTimeout);
        hideErrorTooltip();
      }
    });

    // Hide tooltip when scrolling
    document.querySelector('.spreadsheet-area')?.addEventListener('scroll', hideErrorTooltip);

    // ==================== WELCOME MODAL ====================
    function showWelcome() {
      document.getElementById('welcomeModal').classList.add('visible');
    }

    function closeWelcome() {
      const dontShow = document.getElementById('dontShowAgain').checked;
      if (dontShow) {
        localStorage.setItem('ninjacalc_welcome_shown', 'true');
      }
      document.getElementById('welcomeModal').classList.remove('visible');
    }

    // Show welcome on first visit
    document.addEventListener('DOMContentLoaded', function() {
      const welcomed = localStorage.getItem('ninjacalc_welcome_shown');
      if (!welcomed) {
        setTimeout(showWelcome, 500);
      }
    });

    // Close welcome with Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && document.getElementById('welcomeModal').classList.contains('visible')) {
        closeWelcome();
      }
    });

    // Close welcome when clicking outside
    document.getElementById('welcomeModal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeWelcome();
      }
    });

    // ==================== ROW/COLUMN HIGHLIGHTER ====================
    let rowColHighlightEnabled = localStorage.getItem('ninjacalc_row_col_highlight') === 'true';

    function toggleRowColumnHighlight() {
      rowColHighlightEnabled = !rowColHighlightEnabled;
      localStorage.setItem('ninjacalc_row_col_highlight', rowColHighlightEnabled);

      const btn = document.getElementById('rowColHighlightBtn');
      const container = document.getElementById('spreadsheetContainer');

      if (rowColHighlightEnabled) {
        btn.classList.add('active');
        container.classList.add('row-highlight-active');
        updateRowColumnHighlight();
        showToast('Row/Column highlighting enabled', 'success');
      } else {
        btn.classList.remove('active');
        container.classList.remove('row-highlight-active');
        clearRowColumnHighlight();
        showToast('Row/Column highlighting disabled', 'info');
      }
    }

    function updateRowColumnHighlight() {
      if (!rowColHighlightEnabled) return;

      // Clear previous highlights
      clearRowColumnHighlight();

      // Get current selection
      const selectedCellEl = document.querySelector('.cell.selected');
      if (!selectedCellEl) return;

      const row = selectedCellEl.closest('tr');
      const cellIndex = Array.from(row.cells).indexOf(selectedCellEl.closest('td'));

      // Highlight the entire row
      if (row) {
        row.classList.add('row-highlighted');
      }

      // Highlight the entire column
      const table = document.querySelector('.spreadsheet-table');
      if (table) {
        const rows = table.querySelectorAll('tr');
        rows.forEach(r => {
          const cell = r.cells[cellIndex];
          if (cell) {
            cell.classList.add('col-highlighted');
          }
        });
      }
    }

    function clearRowColumnHighlight() {
      document.querySelectorAll('.row-highlighted').forEach(el => el.classList.remove('row-highlighted'));
      document.querySelectorAll('.col-highlighted').forEach(el => el.classList.remove('col-highlighted'));
    }

    // Initialize row/column highlight state on load
    document.addEventListener('DOMContentLoaded', function() {
      if (rowColHighlightEnabled) {
        const btn = document.getElementById('rowColHighlightBtn');
        const container = document.getElementById('spreadsheetContainer');
        if (btn) btn.classList.add('active');
        if (container) container.classList.add('row-highlight-active');
      }
    });

    // Update highlights when cell selection changes - hook into existing selectCell
    const wrappedSelectCellForHighlight = typeof selectCell === 'function' ? selectCell : null;
    if (wrappedSelectCellForHighlight) {
      selectCell = function(cellId) {
        const result = wrappedSelectCellForHighlight.apply(this, arguments);
        if (rowColHighlightEnabled) {
          setTimeout(updateRowColumnHighlight, 10);
        }
        return result;
      };
    }

    // Also update on click for direct cell clicks
    document.addEventListener('click', function(e) {
      const cell = e.target.closest('.cell');
      if (cell && rowColHighlightEnabled) {
        setTimeout(updateRowColumnHighlight, 50);
      }
    });

    // Update highlights on keyboard navigation
    document.addEventListener('keydown', function(e) {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'].includes(e.key)) {
        if (rowColHighlightEnabled) {
          setTimeout(updateRowColumnHighlight, 50);
        }
      }
    });

    // ==================== MINI CHART TOOLTIPS ====================
    let miniChartEnabled = localStorage.getItem('ninjacalc_mini_chart') !== 'false'; // Enabled by default
    let miniChartTimeout = null;

    function showMiniChartTooltip(cellEl, cellId, x, y) {
      if (!miniChartEnabled) return;

      const cellValue = data[cellId];
      if (cellValue === undefined || cellValue === '' || isNaN(parseFloat(cellValue))) return;

      const value = parseFloat(cellValue);
      const tooltip = document.getElementById('miniChartTooltip');

      // Get row data for context
      const match = cellId.match(/^([A-Z]+)(\d+)$/);
      if (!match) return;

      const col = match[1];
      const row = parseInt(match[2]);
      const colIndex = col.charCodeAt(0) - 65;

      // Collect row values (up to 10 cells in each direction)
      const rowValues = [];
      let currentIndex = -1;

      for (let c = Math.max(0, colIndex - 5); c <= Math.min(COLS - 1, colIndex + 5); c++) {
        const checkCellId = String.fromCharCode(65 + c) + row;
        const checkValue = data[checkCellId];
        if (checkValue !== undefined && !isNaN(parseFloat(checkValue))) {
          rowValues.push({ col: String.fromCharCode(65 + c), value: parseFloat(checkValue) });
          if (c === colIndex) currentIndex = rowValues.length - 1;
        }
      }

      // Need at least 2 values for a meaningful chart
      if (rowValues.length < 2) {
        // Try column data instead
        const colValues = [];
        currentIndex = -1;

        for (let r = Math.max(1, row - 5); r <= Math.min(ROWS, row + 5); r++) {
          const checkCellId = col + r;
          const checkValue = data[checkCellId];
          if (checkValue !== undefined && !isNaN(parseFloat(checkValue))) {
            colValues.push({ row: r, value: parseFloat(checkValue) });
            if (r === row) currentIndex = colValues.length - 1;
          }
        }

        if (colValues.length < 2) return;

        // Use column data
        renderMiniChart(tooltip, cellId, value, colValues.map(v => v.value), currentIndex, `Column ${col}`);
      } else {
        // Use row data
        renderMiniChart(tooltip, cellId, value, rowValues.map(v => v.value), currentIndex, `Row ${row}`);
      }

      // Position tooltip
      const tooltipWidth = 200;
      const tooltipHeight = 160;
      let left = x + 15;
      let top = y + 15;

      if (left + tooltipWidth > window.innerWidth) {
        left = x - tooltipWidth - 15;
      }
      if (top + tooltipHeight > window.innerHeight) {
        top = y - tooltipHeight - 15;
      }

      tooltip.style.left = Math.max(10, left) + 'px';
      tooltip.style.top = Math.max(10, top) + 'px';
      tooltip.classList.add('visible');
    }

    function renderMiniChart(tooltip, cellId, value, values, currentIndex, rangeLabel) {
      document.getElementById('miniChartCell').textContent = cellId;
      document.getElementById('miniChartRange').textContent = rangeLabel;
      document.getElementById('miniChartValue').textContent = formatNumber(value);

      // Calculate stats
      const sum = values.reduce((a, b) => a + b, 0);
      const avg = sum / values.length;
      const min = Math.min(...values);
      const max = Math.max(...values);

      document.getElementById('miniChartStats').innerHTML = `
        <span>Avg: ${formatNumber(avg)}</span>
        <span>Sum: ${formatNumber(sum)}</span>
        <span>Min: ${formatNumber(min)}</span>
        <span>Max: ${formatNumber(max)}</span>
      `;

      // Render bars
      const maxAbs = Math.max(...values.map(v => Math.abs(v)));
      const barsContainer = document.getElementById('miniChartBars');
      barsContainer.innerHTML = values.map((v, i) => {
        const height = maxAbs > 0 ? Math.abs(v) / maxAbs * 100 : 0;
        const isNegative = v < 0;
        const isCurrent = i === currentIndex;
        return `<div class="mini-chart-bar ${isNegative ? 'negative' : ''} ${isCurrent ? 'current' : ''}"
                     style="height: ${Math.max(4, height)}%;"
                     title="${formatNumber(v)}"></div>`;
      }).join('');
    }

    function formatNumber(num) {
      if (Math.abs(num) >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (Math.abs(num) >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      } else if (Number.isInteger(num)) {
        return num.toString();
      } else {
        return num.toFixed(2);
      }
    }

    function hideMiniChartTooltip() {
      document.getElementById('miniChartTooltip').classList.remove('visible');
    }

    // Add hover handlers for mini chart tooltips
    document.addEventListener('mouseover', function(e) {
      const cell = e.target.closest('.cell');
      if (cell && miniChartEnabled) {
        const cellId = cell.id || cell.querySelector('input')?.id;
        if (cellId && data[cellId] !== undefined) {
          clearTimeout(miniChartTimeout);
          miniChartTimeout = setTimeout(() => {
            showMiniChartTooltip(cell, cellId, e.clientX, e.clientY);
          }, 600); // Show after 600ms hover
        }
      }
    });

    document.addEventListener('mouseout', function(e) {
      const cell = e.target.closest('.cell');
      if (cell) {
        clearTimeout(miniChartTimeout);
        hideMiniChartTooltip();
      }
    });

    // Hide mini chart on scroll
    document.querySelector('.spreadsheet-area')?.addEventListener('scroll', hideMiniChartTooltip);

    // Toggle mini chart tooltips
    function toggleMiniChartTooltips() {
      miniChartEnabled = !miniChartEnabled;
      localStorage.setItem('ninjacalc_mini_chart', miniChartEnabled);

      const btn = document.getElementById('miniChartBtn');
      if (btn) {
        btn.classList.toggle('active', miniChartEnabled);
      }

      showToast(miniChartEnabled ? 'Mini chart tooltips enabled' : 'Mini chart tooltips disabled', 'info');
    }

    // Initialize mini chart button state on load
    document.addEventListener('DOMContentLoaded', function() {
      const btn = document.getElementById('miniChartBtn');
      if (btn && miniChartEnabled) {
        btn.classList.add('active');
      }
    });

    // ==================== CELL NOTES PREVIEW ====================
    const cellNotes = JSON.parse(localStorage.getItem('ninjacalc_cell_notes') || '{}');
    let cellNoteTimeout = null;

    function addCellNote(cellId, note) {
      if (!cellId) {
        cellId = selectedCell;
      }
      if (!cellId) {
        showToast('Please select a cell first', 'warning');
        return;
      }

      if (!note) {
        note = prompt('Enter note for cell ' + cellId + ':', cellNotes[cellId] || '');
        if (note === null) return; // Cancelled
      }

      if (note.trim()) {
        cellNotes[cellId] = {
          text: note,
          author: 'You',
          date: new Date().toISOString()
        };
        markCellWithNote(cellId);
        showToast('Note added to ' + cellId, 'success');
      } else {
        delete cellNotes[cellId];
        unmarkCellNote(cellId);
        showToast('Note removed from ' + cellId, 'info');
      }

      localStorage.setItem('ninjacalc_cell_notes', JSON.stringify(cellNotes));
    }

    function markCellWithNote(cellId) {
      const cell = document.getElementById(cellId);
      if (cell) {
        cell.classList.add('cell-has-note');
      }
    }

    function unmarkCellNote(cellId) {
      const cell = document.getElementById(cellId);
      if (cell) {
        cell.classList.remove('cell-has-note');
      }
    }

    function showCellNoteTooltip(cellId, x, y) {
      const note = cellNotes[cellId];
      if (!note) return;

      const tooltip = document.getElementById('cellNoteTooltip');
      document.getElementById('cellNoteCell').textContent = cellId;
      document.getElementById('cellNoteContent').textContent = note.text;

      const date = new Date(note.date);
      document.getElementById('cellNoteFooter').textContent =
        `${note.author} ‚Ä¢ ${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

      // Position tooltip
      const tooltipWidth = 280;
      const tooltipHeight = 100;
      let left = x + 15;
      let top = y + 15;

      if (left + tooltipWidth > window.innerWidth) {
        left = x - tooltipWidth - 15;
      }
      if (top + tooltipHeight > window.innerHeight) {
        top = y - tooltipHeight - 15;
      }

      tooltip.style.left = Math.max(10, left) + 'px';
      tooltip.style.top = Math.max(10, top) + 'px';
      tooltip.classList.add('visible');
    }

    function hideCellNoteTooltip() {
      document.getElementById('cellNoteTooltip').classList.remove('visible');
    }

    // Show note tooltip on hover
    document.addEventListener('mouseover', function(e) {
      const cell = e.target.closest('.cell-has-note');
      if (cell) {
        const cellId = cell.id || cell.querySelector('input')?.id;
        if (cellId && cellNotes[cellId]) {
          clearTimeout(cellNoteTimeout);
          cellNoteTimeout = setTimeout(() => {
            showCellNoteTooltip(cellId, e.clientX, e.clientY);
          }, 300);
        }
      }
    });

    document.addEventListener('mouseout', function(e) {
      const cell = e.target.closest('.cell-has-note');
      if (cell) {
        clearTimeout(cellNoteTimeout);
        hideCellNoteTooltip();
      }
    });

    // Load existing notes on page load
    document.addEventListener('DOMContentLoaded', function() {
      Object.keys(cellNotes).forEach(cellId => {
        markCellWithNote(cellId);
      });
    });

    // Keyboard shortcut: Ctrl+Shift+N to add note
    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        addCellNote();
      }
    });

    // Hide note tooltip on scroll
    document.querySelector('.spreadsheet-area')?.addEventListener('scroll', hideCellNoteTooltip);

    // ========== Quick Formula Buttons ==========

    const formulaHelp = {
      SUM: { syntax: '=SUM(number1, [number2], ...)', desc: 'Adds all the numbers in a range of cells.', example: '=SUM(A1:A10)' },
      AVERAGE: { syntax: '=AVERAGE(number1, [number2], ...)', desc: 'Returns the average of the arguments.', example: '=AVERAGE(B1:B20)' },
      COUNT: { syntax: '=COUNT(value1, [value2], ...)', desc: 'Counts cells containing numbers.', example: '=COUNT(A1:A50)' },
      COUNTA: { syntax: '=COUNTA(value1, [value2], ...)', desc: 'Counts non-empty cells.', example: '=COUNTA(A1:A50)' },
      MIN: { syntax: '=MIN(number1, [number2], ...)', desc: 'Returns the smallest number.', example: '=MIN(C1:C100)' },
      MAX: { syntax: '=MAX(number1, [number2], ...)', desc: 'Returns the largest number.', example: '=MAX(C1:C100)' },
      MEDIAN: { syntax: '=MEDIAN(number1, [number2], ...)', desc: 'Returns the median of the given numbers.', example: '=MEDIAN(A1:A100)' },
      STDEV: { syntax: '=STDEV(number1, [number2], ...)', desc: 'Calculates standard deviation.', example: '=STDEV(A1:A50)' },
      ROUND: { syntax: '=ROUND(number, num_digits)', desc: 'Rounds a number to specified digits.', example: '=ROUND(A1, 2)' },
      ABS: { syntax: '=ABS(number)', desc: 'Returns the absolute value.', example: '=ABS(A1)' },
      SQRT: { syntax: '=SQRT(number)', desc: 'Returns the square root.', example: '=SQRT(A1)' },
      POWER: { syntax: '=POWER(number, power)', desc: 'Raises number to a power.', example: '=POWER(A1, 2)' },
      MOD: { syntax: '=MOD(number, divisor)', desc: 'Returns the remainder after division.', example: '=MOD(A1, 3)' },
      CEILING: { syntax: '=CEILING(number, significance)', desc: 'Rounds up to nearest multiple.', example: '=CEILING(A1, 10)' },
      FLOOR: { syntax: '=FLOOR(number, significance)', desc: 'Rounds down to nearest multiple.', example: '=FLOOR(A1, 10)' },
      IF: { syntax: '=IF(condition, value_if_true, value_if_false)', desc: 'Returns one value if true, another if false.', example: '=IF(A1>10, "High", "Low")' },
      AND: { syntax: '=AND(logical1, [logical2], ...)', desc: 'Returns TRUE if all arguments are true.', example: '=AND(A1>0, B1>0)' },
      OR: { syntax: '=OR(logical1, [logical2], ...)', desc: 'Returns TRUE if any argument is true.', example: '=OR(A1>10, B1>10)' },
      NOT: { syntax: '=NOT(logical)', desc: 'Reverses the logic of the argument.', example: '=NOT(A1>10)' },
      IFERROR: { syntax: '=IFERROR(value, value_if_error)', desc: 'Returns value_if_error if formula results in error.', example: '=IFERROR(A1/B1, 0)' },
      CONCAT: { syntax: '=CONCAT(text1, [text2], ...)', desc: 'Joins text strings together.', example: '=CONCAT(A1, " ", B1)' },
      LEFT: { syntax: '=LEFT(text, [num_chars])', desc: 'Returns leftmost characters.', example: '=LEFT(A1, 3)' },
      RIGHT: { syntax: '=RIGHT(text, [num_chars])', desc: 'Returns rightmost characters.', example: '=RIGHT(A1, 3)' },
      MID: { syntax: '=MID(text, start_num, num_chars)', desc: 'Returns characters from middle of text.', example: '=MID(A1, 2, 3)' },
      LEN: { syntax: '=LEN(text)', desc: 'Returns the length of a text string.', example: '=LEN(A1)' },
      UPPER: { syntax: '=UPPER(text)', desc: 'Converts text to uppercase.', example: '=UPPER(A1)' },
      LOWER: { syntax: '=LOWER(text)', desc: 'Converts text to lowercase.', example: '=LOWER(A1)' },
      TRIM: { syntax: '=TRIM(text)', desc: 'Removes extra spaces from text.', example: '=TRIM(A1)' },
      VLOOKUP: { syntax: '=VLOOKUP(lookup_value, table_array, col_index, [range_lookup])', desc: 'Looks up value in leftmost column and returns value from specified column.', example: '=VLOOKUP(A1, D1:F10, 2, FALSE)' },
      HLOOKUP: { syntax: '=HLOOKUP(lookup_value, table_array, row_index, [range_lookup])', desc: 'Looks up value in top row and returns value from specified row.', example: '=HLOOKUP(A1, D1:F10, 2, FALSE)' },
      INDEX: { syntax: '=INDEX(array, row_num, [col_num])', desc: 'Returns value at given position.', example: '=INDEX(A1:C10, 2, 3)' },
      MATCH: { syntax: '=MATCH(lookup_value, lookup_array, [match_type])', desc: 'Returns relative position of item.', example: '=MATCH(A1, B1:B10, 0)' },
      TODAY: { syntax: '=TODAY()', desc: 'Returns the current date.', example: '=TODAY()' },
      NOW: { syntax: '=NOW()', desc: 'Returns the current date and time.', example: '=NOW()' },
      DATE: { syntax: '=DATE(year, month, day)', desc: 'Creates a date from components.', example: '=DATE(2024, 1, 15)' },
      YEAR: { syntax: '=YEAR(serial_number)', desc: 'Extracts the year from a date.', example: '=YEAR(A1)' },
      MONTH: { syntax: '=MONTH(serial_number)', desc: 'Extracts the month from a date.', example: '=MONTH(A1)' },
      DAY: { syntax: '=DAY(serial_number)', desc: 'Extracts the day from a date.', example: '=DAY(A1)' }
    };

    let quickFormulaBarVisible = false;

    function showQuickFormulaBar() {
      document.getElementById('quickFormulaBar').classList.add('visible');
      quickFormulaBarVisible = true;
      updateQuickFormulaResult();
    }

    function hideQuickFormulaBar() {
      document.getElementById('quickFormulaBar').classList.remove('visible');
      quickFormulaBarVisible = false;
    }

    function toggleQuickFormulaBar() {
      if (quickFormulaBarVisible) {
        hideQuickFormulaBar();
      } else {
        showQuickFormulaBar();
      }
    }

    function getSelectedRangeString() {
      if (selectedRange.length < 2) {
        return selectedCell || 'A1';
      }

      const cells = selectedRange.map(cell => {
        const col = cell.match(/[A-Z]+/)[0];
        const row = parseInt(cell.match(/\d+/)[0]);
        return { col, row, colNum: col.charCodeAt(0) - 64 };
      });

      const minCol = Math.min(...cells.map(c => c.colNum));
      const maxCol = Math.max(...cells.map(c => c.colNum));
      const minRow = Math.min(...cells.map(c => c.row));
      const maxRow = Math.max(...cells.map(c => c.row));

      const startCol = String.fromCharCode(64 + minCol);
      const endCol = String.fromCharCode(64 + maxCol);

      return `${startCol}${minRow}:${endCol}${maxRow}`;
    }

    function quickFormula(formulaName) {
      const range = getSelectedRangeString();
      const formula = `=${formulaName}(${range})`;

      // Find an empty cell below or to the right of the selection
      let targetCell = selectedCell || 'A1';

      if (selectedRange.length >= 2) {
        // Place result below the range
        const cells = selectedRange.map(cell => {
          const row = parseInt(cell.match(/\d+/)[0]);
          return row;
        });
        const maxRow = Math.max(...cells);
        const col = selectedCell.match(/[A-Z]+/)[0];
        targetCell = col + (maxRow + 1);
      }

      // Insert the formula
      const cellInput = document.querySelector(`[data-cell="${targetCell}"]`);
      if (cellInput) {
        cellInput.value = formula;
        handleCellChange(targetCell);
        selectCell(targetCell);
        showToast(`${formulaName} formula applied to ${targetCell}`, 'success');
      }
    }

    function updateQuickFormulaResult() {
      if (!quickFormulaBarVisible) return;

      const resultEl = document.getElementById('quickFormulaResult');
      const range = getSelectedRangeString();

      try {
        // Get values from selected range
        const values = getValuesFromRange(range);
        const numbers = values.filter(v => !isNaN(parseFloat(v)) && v !== '').map(v => parseFloat(v));

        if (numbers.length === 0) {
          resultEl.textContent = '-';
          resultEl.classList.remove('error');
          return;
        }

        const sum = numbers.reduce((a, b) => a + b, 0);
        resultEl.textContent = `Œ£ ${formatNumber(sum)}`;
        resultEl.title = `Sum: ${sum}\nAvg: ${(sum / numbers.length).toFixed(2)}\nCount: ${numbers.length}`;
        resultEl.classList.remove('error');
      } catch (e) {
        resultEl.textContent = 'Error';
        resultEl.classList.add('error');
      }
    }

    function getValuesFromRange(rangeStr) {
      const values = [];

      if (rangeStr.includes(':')) {
        const [start, end] = rangeStr.split(':');
        const startCol = start.match(/[A-Z]+/)[0].charCodeAt(0) - 64;
        const startRow = parseInt(start.match(/\d+/)[0]);
        const endCol = end.match(/[A-Z]+/)[0].charCodeAt(0) - 64;
        const endRow = parseInt(end.match(/\d+/)[0]);

        for (let row = startRow; row <= endRow; row++) {
          for (let col = startCol; col <= endCol; col++) {
            const cellId = String.fromCharCode(64 + col) + row;
            values.push(data[cellId] || '');
          }
        }
      } else {
        values.push(data[rangeStr] || '');
      }

      return values;
    }

    function formatNumber(num) {
      if (Math.abs(num) >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (Math.abs(num) >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toFixed(2);
    }

    function showFormulaPalette() {
      document.getElementById('formulaPalette').classList.add('visible');
      document.getElementById('formulaSearchInput').focus();
    }

    function hideFormulaPalette() {
      document.getElementById('formulaPalette').classList.remove('visible');
      document.getElementById('formulaSearchInput').value = '';
      filterFormulas('');
    }

    function filterFormulas(query) {
      const categories = document.querySelectorAll('.formula-category');
      const lowerQuery = query.toLowerCase();

      categories.forEach(category => {
        const items = category.querySelectorAll('.formula-item');
        let hasVisible = false;

        items.forEach(item => {
          const name = item.querySelector('.formula-item-name').textContent.toLowerCase();
          const desc = item.querySelector('.formula-item-desc').textContent.toLowerCase();

          if (name.includes(lowerQuery) || desc.includes(lowerQuery)) {
            item.style.display = '';
            hasVisible = true;
          } else {
            item.style.display = 'none';
          }
        });

        category.style.display = hasVisible ? '' : 'none';
      });
    }

    function insertFormula(formulaName) {
      const range = getSelectedRangeString();
      const help = formulaHelp[formulaName];

      let formula;
      if (['TODAY', 'NOW'].includes(formulaName)) {
        formula = `=${formulaName}()`;
      } else if (['SUM', 'AVERAGE', 'COUNT', 'COUNTA', 'MIN', 'MAX', 'MEDIAN', 'STDEV'].includes(formulaName)) {
        formula = `=${formulaName}(${range})`;
      } else {
        formula = `=${formulaName}(`;
      }

      // Insert into formula bar
      const formulaBar = document.getElementById('formulaBar');
      if (formulaBar) {
        formulaBar.value = formula;
        formulaBar.focus();

        // Position cursor before closing paren if applicable
        if (!['TODAY', 'NOW'].includes(formulaName) && !['SUM', 'AVERAGE', 'COUNT', 'COUNTA', 'MIN', 'MAX', 'MEDIAN', 'STDEV'].includes(formulaName)) {
          formulaBar.setSelectionRange(formula.length, formula.length);
        }
      }

      // Also insert into current cell
      if (selectedCell) {
        const cellInput = document.querySelector(`[data-cell="${selectedCell}"]`);
        if (cellInput) {
          cellInput.value = formula;
          if (!['TODAY', 'NOW'].includes(formulaName) && !['SUM', 'AVERAGE', 'COUNT', 'COUNTA', 'MIN', 'MAX', 'MEDIAN', 'STDEV'].includes(formulaName)) {
            cellInput.focus();
            cellInput.setSelectionRange(formula.length, formula.length);
          } else {
            handleCellChange(selectedCell);
          }
        }
      }

      hideFormulaPalette();
      showFormulaHelper(formulaName);
    }

    function showFormulaHelper(formulaName) {
      const help = formulaHelp[formulaName];
      if (!help) return;

      const popup = document.getElementById('formulaHelperPopup');
      document.getElementById('formulaHelperName').textContent = formulaName;
      document.getElementById('formulaHelperSyntax').textContent = help.syntax;
      document.getElementById('formulaHelperDesc').textContent = help.desc;
      document.getElementById('formulaHelperExample').textContent = help.example;

      // Position near formula bar
      const formulaBar = document.getElementById('formulaBar');
      if (formulaBar) {
        const rect = formulaBar.getBoundingClientRect();
        popup.style.left = rect.left + 'px';
        popup.style.top = (rect.bottom + 8) + 'px';
      }

      popup.classList.add('visible');

      // Auto-hide after 5 seconds
      setTimeout(() => {
        popup.classList.remove('visible');
      }, 5000);
    }

    function hideFormulaHelper() {
      document.getElementById('formulaHelperPopup').classList.remove('visible');
    }

    // Show quick formula bar when cells are selected
    const wrappedSelectCellForFormula = selectCell;
    selectCell = function(cellId) {
      wrappedSelectCellForFormula(cellId);
      updateQuickFormulaResult();
    };

    // Update result when selection changes
    document.addEventListener('mouseup', function() {
      if (selectedRange.length > 0) {
        showQuickFormulaBar();
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // F2 to show formula palette
      if (e.key === 'F2' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        showFormulaPalette();
      }

      // Escape to close popups
      if (e.key === 'Escape') {
        hideFormulaPalette();
        hideFormulaHelper();
        hideQuickFormulaBar();
      }

      // Alt+= for quick SUM
      if (e.altKey && e.key === '=') {
        e.preventDefault();
        quickFormula('SUM');
      }
    });

    // Close formula palette on click outside
    document.addEventListener('click', function(e) {
      const palette = document.getElementById('formulaPalette');
      if (palette.classList.contains('visible') && !palette.contains(e.target) && !e.target.closest('.quick-formula-btn')) {
        hideFormulaPalette();
      }
    });

    // Show formula bar on initial load if localStorage setting
    if (localStorage.getItem('ninjacalc_quick_formula_bar') === 'visible') {
      showQuickFormulaBar();
    }

    // Auto-show when range is selected
    const spreadsheetAreaForFormula = document.querySelector('.spreadsheet-area');
    if (spreadsheetAreaForFormula) {
      spreadsheetAreaForFormula.addEventListener('mouseup', function() {
        setTimeout(() => {
          if (selectedRange.length >= 2) {
            showQuickFormulaBar();
          }
        }, 100);
      });
    }
  </script>
</body>
</html>
