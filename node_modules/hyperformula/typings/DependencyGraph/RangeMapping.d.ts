/**
 * @license
 * Copyright (c) 2025 Handsoncode. All rights reserved.
 */
import { AbsoluteCellRange } from '../AbsoluteCellRange';
import { SimpleCellAddress } from '../Cell';
import { Maybe } from '../Maybe';
import { Span } from '../Span';
import { RangeVertex } from './';
export interface AdjustRangesResult {
    verticesWithChangedSize: RangeVertex[];
}
export interface TruncateRangesResult extends AdjustRangesResult {
    verticesToRemove: RangeVertex[];
    verticesToMerge: [RangeVertex, RangeVertex][];
    verticesWithChangedSize: RangeVertex[];
}
/**
 * Maintains a per-sheet map from serialized start/end coordinates to `RangeVertex`.
 * - Every range vertex in dependency graph should be stored in this mapping.
 * - Guarantees uniqueness: one vertex per distinct rectangle, enabling cache reuse.
 * - Implements "smaller prefix + tail row" optimization: if A1:A4 exists, A1:A5 depends on it + only A5.
 * - RangeVertex stores cached results for associative aggregates (SUM, COUNT) and criterion functions.
 */
export declare class RangeMapping {
    /**
     * Map sheetId -> address of start and end (as string) -> vertex
     */
    private rangeMapping;
    /**
     * Returns number of ranges in the sheet or 0 if the sheet does not exist
     */
    getNumberOfRangesInSheet(sheet: number): number;
    /**
     * Adds or updates vertex in the mapping
     */
    addOrUpdateVertex(vertex: RangeVertex): void;
    /**
     * Removes vertex from the mapping if it exists
     */
    removeVertexIfExists(vertex: RangeVertex): void;
    /**
     * Returns associated vertex for given range
     */
    getRangeVertex(start: SimpleCellAddress, end: SimpleCellAddress): Maybe<RangeVertex>;
    /**
     * Returns associated vertex for given range or throws an error if not found
     */
    getVertexOrThrow(start: SimpleCellAddress, end: SimpleCellAddress): RangeVertex;
    truncateRanges(span: Span, coordinate: (address: SimpleCellAddress) => number): TruncateRangesResult;
    moveAllRangesInSheetAfterAddingRows(sheet: number, row: number, numberOfRows: number): AdjustRangesResult;
    moveAllRangesInSheetAfterAddingColumns(sheet: number, column: number, numberOfColumns: number): AdjustRangesResult;
    moveRangesInsideSourceRange(sourceRange: AbsoluteCellRange, toRight: number, toBottom: number, toSheet: number): void;
    rangesInSheet(sheet: number): IterableIterator<RangeVertex>;
    rangeVerticesContainedInRange(sourceRange: AbsoluteCellRange): IterableIterator<RangeVertex>;
    /**
     * Finds smaller range if exists.
     */
    findSmallerRange(range: AbsoluteCellRange): {
        smallerRangeVertex?: RangeVertex;
        restRange: AbsoluteCellRange;
    };
    /**
     * Calculates a string key from start and end addresses
     */
    private static calculateRangeKey;
    /**
     * Compares two range vertices by their start and end addresses using the provided coordinate function
     */
    private static compareBy;
    private entriesFromSheet;
    private removeByKey;
    private getByKey;
    private updateVerticesFromSheet;
}
