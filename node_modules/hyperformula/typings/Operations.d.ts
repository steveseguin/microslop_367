/**
 * @license
 * Copyright (c) 2025 Handsoncode. All rights reserved.
 */
import { AbsoluteCellRange } from './AbsoluteCellRange';
import { ArraySize, ArraySizePredictor } from './ArraySize';
import { SimpleCellAddress } from './Cell';
import { CellContentParser, RawCellContent } from './CellContentParser';
import { ClipboardCell } from './ClipboardOperations';
import { Config } from './Config';
import { ContentChanges } from './ContentChanges';
import { ColumnRowIndex } from './CrudOperations';
import { DependencyGraph } from './DependencyGraph';
import { RawAndParsedValue } from './DependencyGraph/ValueCellVertex';
import { LazilyTransformingAstService } from './LazilyTransformingAstService';
import { ColumnSearchStrategy } from './Lookup/SearchStrategy';
import { Maybe } from './Maybe';
import { InternalNamedExpression, NamedExpressionOptions, NamedExpressions } from './NamedExpressions';
import { ParserWithCaching } from './parser';
import { ParsingError } from './parser/Ast';
import { ParsingResult } from './parser/ParserWithCaching';
import { ColumnsSpan, RowsSpan } from './Span';
import { Statistics } from './statistics';
export declare class RemoveRowsCommand {
    readonly sheet: number;
    readonly indexes: ColumnRowIndex[];
    constructor(sheet: number, indexes: ColumnRowIndex[]);
    normalizedIndexes(): ColumnRowIndex[];
    rowsSpans(): RowsSpan[];
}
export declare class AddRowsCommand {
    readonly sheet: number;
    readonly indexes: ColumnRowIndex[];
    constructor(sheet: number, indexes: ColumnRowIndex[]);
    normalizedIndexes(): ColumnRowIndex[];
    rowsSpans(): RowsSpan[];
}
export declare class AddColumnsCommand {
    readonly sheet: number;
    readonly indexes: ColumnRowIndex[];
    constructor(sheet: number, indexes: ColumnRowIndex[]);
    normalizedIndexes(): ColumnRowIndex[];
    columnsSpans(): ColumnsSpan[];
}
export declare class RemoveColumnsCommand {
    readonly sheet: number;
    readonly indexes: ColumnRowIndex[];
    constructor(sheet: number, indexes: ColumnRowIndex[]);
    normalizedIndexes(): ColumnRowIndex[];
    columnsSpans(): ColumnsSpan[];
}
export interface ChangedCell {
    address: SimpleCellAddress;
    cellType: ClipboardCell;
}
export interface RowsRemoval {
    rowFrom: number;
    rowCount: number;
    version: number;
    removedCells: ChangedCell[];
}
export interface ColumnsRemoval {
    columnFrom: number;
    columnCount: number;
    version: number;
    removedCells: ChangedCell[];
}
export interface MoveCellsResult {
    version: number;
    overwrittenCellsData: [SimpleCellAddress, ClipboardCell][];
    addedGlobalNamedExpressions: string[];
}
export declare class Operations {
    private readonly dependencyGraph;
    private readonly columnSearch;
    private readonly cellContentParser;
    private readonly parser;
    private readonly stats;
    private readonly lazilyTransformingAstService;
    private readonly namedExpressions;
    private readonly arraySizePredictor;
    private changes;
    private readonly maxRows;
    private readonly maxColumns;
    constructor(config: Config, dependencyGraph: DependencyGraph, columnSearch: ColumnSearchStrategy, cellContentParser: CellContentParser, parser: ParserWithCaching, stats: Statistics, lazilyTransformingAstService: LazilyTransformingAstService, namedExpressions: NamedExpressions, arraySizePredictor: ArraySizePredictor);
    private get sheetMapping();
    private get addressMapping();
    removeRows(cmd: RemoveRowsCommand): RowsRemoval[];
    addRows(cmd: AddRowsCommand): void;
    addColumns(cmd: AddColumnsCommand): void;
    removeColumns(cmd: RemoveColumnsCommand): ColumnsRemoval[];
    /**
     * Clears the sheet content.
     */
    clearSheet(sheetId: number): void;
    /**
     * Adds a new sheet to the workbook.
     */
    addSheet(name?: string): {
        sheetName: string;
        sheetId: number;
    };
    /**
     * Adds a sheet with a specific ID for redo operations.
     */
    addSheetWithId(sheetId: number, name: string): void;
    /**
     * Adds a placeholder sheet with a specific ID for undo operations.
     * Used to restore previously merged placeholder sheets.
     *
     * Note: Unlike `addSheetWithId`, this does NOT call `dependencyGraph.addSheet()`
     * because placeholders don't need dirty marking or strategy changes - they only
     * need to exist in the mappings so formulas can reference them again.
     */
    addPlaceholderSheetWithId(sheetId: number, name: string): void;
    /**
     * Removes a sheet from the workbook.
     */
    removeSheet(sheetId: number): [InternalNamedExpression, ClipboardCell][];
    /**
     * Removes a sheet from the workbook by name.
     */
    removeSheetByName(sheetName: string): [InternalNamedExpression, ClipboardCell][];
    /**
     * Renames a sheet in the workbook.
     */
    renameSheet(sheetId: number, newName: string): {
        previousDisplayName: Maybe<string>;
        version?: number;
        mergedPlaceholderSheetId?: number;
    };
    moveRows(sheet: number, startRow: number, numberOfRows: number, targetRow: number): number;
    moveColumns(sheet: number, startColumn: number, numberOfColumns: number, targetColumn: number): number;
    moveCells(sourceLeftCorner: SimpleCellAddress, width: number, height: number, destinationLeftCorner: SimpleCellAddress): MoveCellsResult;
    setRowOrder(sheetId: number, rowMapping: [number, number][]): [SimpleCellAddress, ClipboardCell][];
    setColumnOrder(sheetId: number, columnMapping: [number, number][]): [SimpleCellAddress, ClipboardCell][];
    addNamedExpression(expressionName: string, expression: RawCellContent, sheetId?: number, options?: NamedExpressionOptions): void;
    restoreNamedExpression(namedExpression: InternalNamedExpression, content: ClipboardCell, sheetId?: number): void;
    changeNamedExpressionExpression(expressionName: string, newExpression: RawCellContent, sheetId?: number, options?: NamedExpressionOptions): [InternalNamedExpression, ClipboardCell];
    removeNamedExpression(expressionName: string, sheetId?: number): [InternalNamedExpression, ClipboardCell];
    ensureItIsPossibleToMoveCells(sourceLeftCorner: SimpleCellAddress, width: number, height: number, destinationLeftCorner: SimpleCellAddress): void;
    restoreClipboardCells(sourceSheetId: number, cells: IterableIterator<[SimpleCellAddress, ClipboardCell]>): string[];
    /**
     * Restores a single cell.
     */
    restoreCell(address: SimpleCellAddress, clipboardCell: ClipboardCell): void;
    getOldContent(address: SimpleCellAddress): [SimpleCellAddress, ClipboardCell];
    getClipboardCell(address: SimpleCellAddress): ClipboardCell;
    getSheetClipboardCells(sheet: number): ClipboardCell[][];
    getRangeClipboardCells(range: AbsoluteCellRange): [SimpleCellAddress, ClipboardCell][];
    setCellContent(address: SimpleCellAddress, newCellContent: RawCellContent): [SimpleCellAddress, ClipboardCell];
    setSheetContent(sheetId: number, newSheetContent: RawCellContent[][]): void;
    /**
     * Sets cell content to an instance of parsing error.
     * Creates a ParsingErrorVertex and updates the dependency graph and column search index.
     */
    setParsingErrorToCell(rawInput: string, errors: ParsingError[], address: SimpleCellAddress): void;
    /**
     * Sets cell content to a formula.
     * Creates a ScalarFormulaVertex and updates the dependency graph and column search index.
     */
    setFormulaToCell(address: SimpleCellAddress, size: ArraySize, { ast, hasVolatileFunction, hasStructuralChangeFunction, dependencies }: ParsingResult): void;
    /**
     * Sets cell content to a value.
     * Creates a ValueCellVertex and updates the dependency graph and column search index.
     */
    setValueToCell(value: RawAndParsedValue, address: SimpleCellAddress): void;
    /**
     * Sets cell content to an empty value.
     * Creates an EmptyCellVertex and updates the dependency graph and column search index.
     */
    setCellEmpty(address: SimpleCellAddress): void;
    setFormulaToCellFromCache(formulaHash: string, address: SimpleCellAddress): void;
    /**
     * Returns true if row number is outside of given sheet.
     * @param {number} row - row number
     * @param {number} sheet - sheet ID number
     */
    rowEffectivelyNotInSheet(row: number, sheet: number): boolean;
    getAndClearContentChanges(): ContentChanges;
    forceApplyPostponedTransformations(): void;
    /**
     * Removes multiple rows from sheet. </br>
     * Does nothing if rows are outside of effective sheet size.
     * @param {RowsSpan} rowsToRemove - rows to remove
     */
    private doRemoveRows;
    /**
     * Removes multiple columns from sheet. </br>
     * Does nothing if columns are outside of effective sheet size.
     * @param {ColumnsSpan} columnsToRemove - columns to remove
     */
    private doRemoveColumns;
    /**
     * Add multiple rows to sheet. </br>
     * Does nothing if rows are outside of effective sheet size.
     * @param {RowsSpan} addedRows - rows to add
     */
    private doAddRows;
    private rewriteAffectedArrays;
    /**
     * Add multiple columns to sheet </br>
     * Does nothing if columns are outside of effective sheet size
     * @param {ColumnsSpan} addedColumns - object containing information about columns to add
     */
    private doAddColumns;
    /**
     * Returns true if row number is outside of given sheet.
     * @param {number} column - row number
     * @param {number} sheet - sheet ID number
     */
    private columnEffectivelyNotInSheet;
    private adjustNamedExpressionEdges;
    private storeNamedExpressionInCell;
    private updateNamedExpressionsForMovedCells;
    private updateNamedExpressionsForTargetAddress;
    private allocateNamedExpressionAddressSpace;
    private copyOrFetchGlobalNamedExpressionVertex;
    /**
     * Removes a cell value from the columnSearch index.
     * Ignores the non-computed formula vertices.
     */
    private removeCellValueFromColumnSearch;
    /**
     * Changes a cell value in the columnSearch index.
     * Ignores the non-computed formula vertices.
     */
    private changeCellValueInColumnSearch;
    /**
     * Checks if the ScalarFormulaVertex or ArrayFormulaVertex at the given address is not computed.
     */
    private isNotComputed;
}
export declare function normalizeRemovedIndexes(indexes: ColumnRowIndex[]): ColumnRowIndex[];
export declare function normalizeAddedIndexes(indexes: ColumnRowIndex[]): ColumnRowIndex[];
